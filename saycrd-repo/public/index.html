<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SAYCRD — A Place To Go In The Moment</title>
    <!-- v2.6-async-fix -->
    <meta name="description" content="SAYCRD: the space between journaling, coaching, and productivity." />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&family=Fraunces:opsz,wght@9..144,300;9..144,500;9..144,700&family=Space+Grotesk:wght@300;400;500;600&display=swap" rel="stylesheet" />
    <style>
:root {
  color-scheme: dark;
  --bg: #0b0d0f; --bg-soft: #111418; --bg-card: #14191f;
  --ink: #f4f1ea; --ink-soft: rgba(244,241,234,0.72);
  --accent: #d6b26d; --accent-2: #7db7ae; --accent-3: #c46e5f;
  --line: rgba(244,241,234,0.12); --glow: rgba(214,178,109,0.35);
  --shadow: 0 20px 60px rgba(0,0,0,0.45); --radius: 24px;
  --mono: "Space Grotesk", system-ui, sans-serif;
  --display: "Fraunces", serif;
}
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:var(--mono);background:var(--bg);color:var(--ink);min-height:100vh;line-height:1.6;overflow-x:hidden}
a{color:inherit;text-decoration:none}
main{padding:0 6vw 8rem}

/* Ambient */
.ambient{position:fixed;inset:0;pointer-events:none;z-index:-1;overflow:hidden}
.orb{position:absolute;width:480px;height:480px;border-radius:50%;filter:blur(40px);opacity:.6;animation:drift 18s ease-in-out infinite}
.orb-a{top:-120px;right:-60px;background:radial-gradient(circle,rgba(214,178,109,.55),transparent 65%)}
.orb-b{bottom:-160px;left:-80px;background:radial-gradient(circle,rgba(125,183,174,.5),transparent 70%);animation-delay:-6s}
.orb-c{top:30%;left:40%;width:360px;height:360px;background:radial-gradient(circle,rgba(196,110,95,.45),transparent 65%);animation-delay:-12s}
.grain{position:absolute;inset:0;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='160' height='160'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2'/%3E%3C/filter%3E%3Crect width='160' height='160' filter='url(%23noise)' opacity='0.08'/%3E%3C/svg%3E");mix-blend-mode:soft-light;opacity:.3}
@keyframes drift{0%,100%{transform:translate(0,0) scale(1)}50%{transform:translate(60px,-40px) scale(1.08)}}

/* Nav */
.nav{display:flex;justify-content:space-between;align-items:center;padding:2.5rem 6vw 1rem;position:sticky;top:0;background:linear-gradient(180deg,rgba(11,13,15,.9),rgba(11,13,15,0));backdrop-filter:blur(16px);z-index:10}
.logo{font-family:var(--display);font-size:1.4rem;letter-spacing:.2rem}
.nav-links{display:flex;gap:2rem;font-size:.95rem;color:var(--ink-soft)}
.cta{border:none;padding:.85rem 1.8rem;border-radius:999px;background:var(--accent);color:#1a1410;font-weight:600;font-family:var(--mono);cursor:pointer;transition:transform .2s ease,box-shadow .2s ease;box-shadow:0 12px 30px rgba(214,178,109,.25);font-size:.95rem}
.cta:hover{transform:translateY(-2px)}
.cta:disabled{opacity:.4;cursor:not-allowed;box-shadow:none;transform:none}
.cta.ghost{background:transparent;color:var(--ink);border:1px solid var(--line);box-shadow:none}

/* Hero */
.hero{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:4rem;padding:6rem 0 4rem;align-items:center}
.hero-copy h1{font-family:var(--display);font-size:clamp(2.4rem,4vw,4.2rem);line-height:1.1;margin-bottom:1.5rem}
.eyebrow{text-transform:uppercase;letter-spacing:.3rem;font-size:.75rem;color:var(--ink-soft);margin-bottom:1.5rem}
.lead{font-size:1.1rem;color:var(--ink-soft);margin-bottom:2rem}
.hero-actions{display:flex;gap:1rem;flex-wrap:wrap;margin-bottom:2.5rem}
.micro-proof{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:1.5rem;border-top:1px solid var(--line);padding-top:1.5rem;color:var(--ink-soft)}
.micro-proof span{font-size:1.2rem;font-weight:600;color:var(--ink);display:block}
.hero-visual{background:radial-gradient(circle at top,rgba(214,178,109,.15),transparent 60%),var(--bg-card);border-radius:var(--radius);padding:2rem;box-shadow:var(--shadow);border:1px solid rgba(244,241,234,.08)}
.field{position:relative;height:340px;border-radius:20px;background:linear-gradient(140deg,rgba(21,26,33,.8),rgba(15,18,22,.9));overflow:hidden;border:1px solid rgba(244,241,234,.08)}
.field-center{position:absolute;inset:0;display:grid;place-items:center;pointer-events:none}
#demo-field .field-center{padding-top:10%}
.pulse{width:90px;height:90px;border-radius:50%;background:radial-gradient(circle,rgba(214,178,109,.8),transparent 70%);animation:breathe 4s ease-in-out infinite}
@keyframes breathe{0%,100%{transform:scale(.8);opacity:.6}50%{transform:scale(1.1);opacity:1}}
.presence{position:absolute;padding:.6rem 1rem;border-radius:999px;font-size:.85rem;background:rgba(244,241,234,.08);border:1px solid rgba(244,241,234,.12);color:var(--ink-soft);backdrop-filter:blur(10px)}
.p1{top:18%;left:12%}.p2{top:46%;right:16%;color:var(--ink);border-color:rgba(214,178,109,.4)}.p3{bottom:18%;left:24%;opacity:.6}.p4{bottom:26%;right:28%;background:rgba(125,183,174,.12)}
.veins{position:absolute;inset:0;stroke:rgba(214,178,109,.3);stroke-width:1;fill:none;opacity:.6}
.caption{margin-top:1.5rem;color:var(--ink-soft);font-size:.95rem}

/* Story */
.story{padding:5rem 0 2rem}
.story-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:2.5rem}
.story h2,.system h2,.cta-block h2{font-family:var(--display);font-size:2rem;margin-bottom:1rem}
.story p,.system p,.cta-block p{color:var(--ink-soft)}

/* Demo */
.demo{margin-top:4rem;display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:3.5rem;background:var(--bg-card);border:1px solid rgba(244,241,234,.06);border-radius:var(--radius);padding:3.2rem;box-shadow:var(--shadow)}
.demo-copy h2{font-family:var(--display);font-size:2.3rem;margin-bottom:1.2rem;letter-spacing:-.01rem}

/* Phase tabs */
.phase-tabs{display:flex;gap:.6rem;margin:2rem 0 1.5rem;flex-wrap:wrap}
.phase-tab{border:1px solid var(--line);background:transparent;color:var(--ink-soft);padding:.4rem .9rem;border-radius:999px;font-size:.85rem;font-family:var(--mono);cursor:pointer;transition:all .2s ease}
.phase-tab.is-active{background:rgba(214,178,109,.2);color:var(--ink);border-color:rgba(214,178,109,.4)}
.phase-tab.is-locked{opacity:.35;cursor:not-allowed}
.phase-panel{display:none}.phase-panel.is-active{display:block}

/* Reply */
.ai-reply{margin:1.5rem 0;padding:1rem 1.2rem;border-radius:16px;background:rgba(125,183,174,.1);border:1px solid rgba(125,183,174,.3);color:var(--ink);transition:opacity .25s ease;min-height:3rem}
textarea{width:100%;background:rgba(14,17,21,.8);border:1px solid rgba(244,241,234,.12);border-radius:16px;color:var(--ink);padding:1rem;font-family:var(--mono);font-size:1rem;min-height:180px;resize:vertical;transition:border-color .2s ease}
textarea:focus{outline:none;border-color:rgba(214,178,109,.6)}
.helper{margin-top:.8rem;color:var(--ink-soft);font-size:.92rem}
.demo-actions{display:flex;gap:1rem;margin-top:1.5rem;flex-wrap:wrap}

/* Reading / synthesis */
.reading{padding:1.8rem;border-radius:18px;background:rgba(214,178,109,.05);border:1px solid rgba(214,178,109,.15);font-family:var(--display);font-size:1.18rem;color:var(--ink);line-height:1.7;overflow:visible}

/* Guide */
.guide{display:grid;gap:1.1rem}
.guide-item{border-radius:16px;border:1px solid rgba(244,241,234,.1);padding:1.2rem 1.4rem;background:rgba(16,20,26,.8);opacity:0;animation:guide-in .5s ease forwards}
.guide-item:nth-child(1){animation-delay:.1s}.guide-item:nth-child(2){animation-delay:.25s}.guide-item:nth-child(3){animation-delay:.4s}.guide-item:nth-child(4){animation-delay:.55s}.guide-item:nth-child(5){animation-delay:.7s}
@keyframes guide-in{to{opacity:1}}
.guide-item p{color:var(--ink-soft);margin:0;line-height:1.55;font-size:.95rem}
.tag{display:inline-block;font-size:.75rem;text-transform:uppercase;letter-spacing:.12rem;margin-bottom:.55rem;font-weight:600}
.tag.act{color:#d6b26d}.tag.sit{color:#7db7ae}.tag.deepen{color:#9fb2d8}.tag.release{color:#c46e5f}.tag.surrender{color:#b8b0a4}
.tag.do{color:#d6b26d}.tag.notice{color:#7db7ae}.tag.ask{color:#9fb2d8}
.guide-source-badge{display:flex;align-items:center;gap:.35rem;margin-top:.5rem;margin-bottom:.2rem;flex-wrap:wrap}
.guide-source-dot{width:8px;height:8px;border-radius:50%;display:inline-block;flex-shrink:0}
.guide-source-label{font-size:.7rem;letter-spacing:.08em;text-transform:uppercase;color:rgba(247,241,231,.4);font-family:'Space Grotesk',sans-serif;font-weight:600}
.guide-source-arrow{font-size:.7rem;color:rgba(247,241,231,.2);margin:0 .1rem}

/* Loading */
.loading-state{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:3rem 1rem;gap:1.2rem;min-height:200px}
.loading-dots{display:flex;gap:.5rem}
.loading-dots span{width:8px;height:8px;border-radius:50%;background:var(--accent);opacity:.3;animation:dot-pulse 1.2s ease-in-out infinite}
.loading-dots span:nth-child(2){animation-delay:.2s}.loading-dots span:nth-child(3){animation-delay:.4s}
@keyframes dot-pulse{0%,100%{opacity:.3;transform:scale(1)}50%{opacity:1;transform:scale(1.3)}}
.loading-text{color:var(--ink-soft);font-size:.92rem}

/* Map field */
.demo-field{position:relative;min-height:500px;border-radius:22px;background:radial-gradient(circle at top,rgba(214,178,109,.12),transparent 65%),linear-gradient(130deg,rgba(16,18,22,.92),rgba(10,12,15,.92));border:1px solid rgba(244,241,234,.06);overflow:hidden;touch-action:none}
@media(min-width:900px){.demo-field{min-height:600px}}
.field-glow{position:absolute;inset:0;background:radial-gradient(circle at 30% 30%,rgba(125,183,174,.15),transparent 50%);animation:glow 6s ease-in-out infinite}
@keyframes glow{0%,100%{opacity:.6}50%{opacity:1}}
.field-grid{position:absolute;inset:0;background-image:linear-gradient(rgba(244,241,234,.03) 1px,transparent 1px),linear-gradient(90deg,rgba(244,241,234,.03) 1px,transparent 1px);background-size:44px 44px;opacity:.35}

/* Nodes */
.map-node{position:absolute;border-radius:999px;padding:.45rem .95rem;font-size:.85rem;color:var(--ink);background:rgba(244,241,234,.08);border:1px solid rgba(244,241,234,.18);backdrop-filter:blur(8px);transition:all .8s cubic-bezier(.25,.46,.45,.94);cursor:grab;user-select:none;z-index:2;touch-action:none;white-space:nowrap;letter-spacing:.01rem;overflow:visible}
@media(min-width:900px){.map-node{padding:.5rem 1.1rem;font-size:.92rem}}
.map-node:hover{border-color:rgba(214,178,109,.5)}
.map-node.heavy{background:rgba(214,178,109,.18);border-color:rgba(214,178,109,.5);font-weight:500}
.map-node.fading{opacity:.15!important;transform:scale(.75)!important;pointer-events:none;filter:blur(1px)}
.map-node.ai-placed{box-shadow:0 0 20px rgba(214,178,109,.2)}
.map-node.echo-engaged{border-color:rgba(125,183,174,.7)!important;box-shadow:0 0 18px rgba(125,183,174,.35),0 0 40px rgba(125,183,174,.1);background:rgba(125,183,174,.12)!important;animation:engagedPulse 3s ease-in-out infinite}
.map-node .depth-ring{position:absolute;inset:-4px;border-radius:999px;border:1px solid rgba(125,183,174,.25);opacity:0;animation:depthRingIn .8s ease forwards;pointer-events:none}
.map-node .depth-ring:nth-child(2){inset:-8px;border-color:rgba(125,183,174,.18)}
.map-node .depth-ring:nth-child(3){inset:-12px;border-color:rgba(125,183,174,.12)}
.map-node .depth-ring:nth-child(4){inset:-16px;border-color:rgba(125,183,174,.08)}
@keyframes depthRingIn{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}
.map-symbol{position:absolute;display:flex;align-items:center;gap:.3rem;z-index:3;opacity:0;transform:translateX(-8px);transition:all .6s cubic-bezier(.25,.46,.45,.94);pointer-events:none}
.map-symbol.visible{opacity:1;transform:translateX(0)}
.map-symbol-glyph{font-size:1rem;line-height:1}
.map-symbol-label{font-size:.58rem;letter-spacing:.1em;text-transform:uppercase;font-family:'Space Grotesk',sans-serif;font-weight:600}
@keyframes engagedPulse{0%,100%{box-shadow:0 0 18px rgba(125,183,174,.3),0 0 40px rgba(125,183,174,.08)}50%{box-shadow:0 0 24px rgba(125,183,174,.45),0 0 50px rgba(125,183,174,.15)}}
.conn-line.emerged-connection{animation:emergedLine 1.2s ease forwards}
@keyframes emergedLine{0%{stroke-dashoffset:200;opacity:0}100%{stroke-dashoffset:0;opacity:1}}
.map-node.dragging{cursor:grabbing;z-index:10;transition:none!important;box-shadow:0 0 24px rgba(214,178,109,.4);border-color:rgba(214,178,109,.8);transform:scale(1.12)!important}
.map-node.snap-target{border-color:rgba(125,183,174,.8)!important;box-shadow:0 0 20px rgba(125,183,174,.4);animation:snap-pulse .8s ease-in-out infinite}
@keyframes snap-pulse{0%,100%{box-shadow:0 0 20px rgba(125,183,174,.3)}50%{box-shadow:0 0 32px rgba(125,183,174,.55)}}

/* SVG connections */
.connections-svg{position:absolute;inset:0;width:100%;height:100%;pointer-events:none;z-index:1}
.conn-line{stroke:rgba(214,178,109,.3);stroke-width:1.5;fill:none;stroke-dasharray:6 4;opacity:0;animation:line-in .6s ease forwards}
@keyframes line-in{to{opacity:1}}
.conn-label{position:absolute;padding:.4rem .85rem;border-radius:999px;font-size:.85rem;text-transform:uppercase;letter-spacing:.1rem;color:var(--accent-2);background:rgba(125,183,174,.1);border:1px solid rgba(125,183,174,.25);backdrop-filter:blur(6px);z-index:4;white-space:nowrap;opacity:0;animation:label-in .5s .3s ease forwards;transform:translate(-50%,-50%);cursor:pointer;transition:all .25s ease;pointer-events:auto;min-height:32px;display:grid;place-items:center}
@media(min-width:900px){.conn-label{font-size:.9rem;padding:.45rem .95rem}}
.conn-label:hover{background:rgba(125,183,174,.2);border-color:rgba(125,183,174,.5);transform:translate(-50%,-50%) scale(1.08)}
.conn-label.active{background:rgba(125,183,174,.2);border-color:rgba(125,183,174,.6);box-shadow:0 0 16px rgba(125,183,174,.25)}
.conn-insight-text{font-size:.95rem;color:var(--ink);line-height:1.5}
@keyframes insight-in{from{opacity:0;transform:translate(-50%,4px)}to{opacity:1;transform:translate(-50%,8px)}}
.map-title{position:absolute;top:36px;left:1rem;right:1rem;text-align:center;font-family:var(--display);font-size:1.25rem;color:var(--accent);opacity:0;animation:label-in .6s .8s ease forwards;z-index:3;pointer-events:none;letter-spacing:.01rem;font-weight:500;text-shadow:0 2px 12px rgba(11,13,15,.6)}
@keyframes label-in{to{opacity:1}}

/* Phase transitions on map */
.demo-field.synthesizing .map-node{transition:all 1.2s cubic-bezier(.25,.46,.45,.94)}
.demo-field.synthesizing .field-glow{background:radial-gradient(circle at 50% 50%,rgba(214,178,109,.2),transparent 50%);transition:all 1s ease}
.demo-field.morphing .field-glow{background:radial-gradient(circle at 50% 50%,rgba(125,183,174,.2),transparent 55%);opacity:.9;transition:all 1s ease}
.demo-field.morphing .map-node{filter:blur(.4px)}

/* ── User-interactive map ── */
.map-node.user-added{background:rgba(244,241,234,.08);border-color:rgba(244,241,234,.18);box-shadow:0 0 20px rgba(154,208,255,.1)}
.map-node.user-added:hover{border-color:rgba(214,178,109,.5)}
@keyframes user-node-in{from{opacity:0;transform:scale(.5)}to{opacity:1;transform:scale(1)}}
.map-add-input{position:absolute;z-index:8;background:none;border:none;padding:0;font-family:var(--display);font-size:1.4rem;color:rgba(244,241,234,.85);outline:none;min-width:40px;max-width:280px;letter-spacing:-.01em;font-weight:300;caret-color:rgba(244,196,109,.6);opacity:0;animation:add-text-in .3s ease forwards}
.map-add-input::placeholder{color:rgba(244,241,234,.12);font-style:normal}
@keyframes add-text-in{from{opacity:0;transform:translateY(4px)}to{opacity:1;transform:translateY(0)}}
.map-add-input:focus{outline:none}
.map-node.morphing-in{animation:morph-to-orb .45s cubic-bezier(.25,.46,.45,.94) forwards}
@keyframes morph-to-orb{0%{font-family:var(--display);font-size:1.4rem;font-weight:300;background:none;border-color:transparent;padding:.1rem .2rem;opacity:.85}40%{font-size:.85rem;padding:.35rem .7rem;opacity:.6}100%{font-size:.85rem;font-weight:400;padding:.45rem .95rem;opacity:1}}
.map-connect-hint{position:absolute;z-index:6;font-size:.7rem;letter-spacing:.1rem;color:rgba(125,183,174,.6);pointer-events:none;transform:translate(-50%,-100%);white-space:nowrap;animation:hint-fade 3s ease forwards}
@keyframes hint-fade{0%{opacity:0}15%{opacity:1}85%{opacity:1}100%{opacity:0}}
.map-particle{position:absolute;width:3px;height:3px;border-radius:50%;background:rgba(154,208,255,.2);pointer-events:none;z-index:0;animation:particle-drift 8s linear infinite}
@keyframes particle-drift{0%{opacity:0;transform:translateY(0) scale(1)}10%{opacity:.5}30%{opacity:.2}50%{transform:translateY(-15px) scale(1.3)}70%{opacity:.4}90%{opacity:.2}100%{opacity:0;transform:translateY(-45px) scale(.8)}}
.system{padding:5rem 0 3rem}
.pillars{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:2rem}
.pillars article{padding:1.8rem;border-radius:20px;background:rgba(20,24,30,.8);border:1px solid rgba(244,241,234,.08)}
.cta-block{margin-top:4rem;padding:3rem;border-radius:var(--radius);background:linear-gradient(120deg,rgba(214,178,109,.2),rgba(125,183,174,.1));display:flex;flex-wrap:wrap;gap:2rem;justify-content:space-between;align-items:center}
.cta-actions{display:flex;gap:1rem;flex-wrap:wrap}
.footer{display:flex;justify-content:space-between;align-items:center;padding:2rem 6vw 3rem;border-top:1px solid var(--line);color:var(--ink-soft)}

/* Error state */
.error-msg{padding:1rem 1.2rem;border-radius:16px;background:rgba(196,110,95,.1);border:1px solid rgba(196,110,95,.3);color:var(--accent-3);font-size:.9rem;display:flex;flex-direction:column;align-items:flex-start;gap:.5rem}

/* === SESSION CARD === */
.session-card{border-radius:22px;border:1px solid rgba(214,178,109,.18);background:linear-gradient(160deg,rgba(20,25,31,.96),rgba(14,17,21,.96));padding:2.4rem;overflow:hidden;position:relative}
.session-card::before{content:"";position:absolute;top:0;left:0;right:0;height:3px;background:linear-gradient(90deg,var(--accent),var(--accent-2),var(--accent-3));opacity:.6}
.session-card-header{margin-bottom:2rem;padding-bottom:1.4rem;border-bottom:1px solid rgba(244,241,234,.06)}
.session-card-date{font-size:.85rem;text-transform:uppercase;letter-spacing:.22rem;color:var(--ink-soft);margin-bottom:.4rem}
.session-card-title{font-family:var(--display);font-size:1.7rem;color:var(--ink);letter-spacing:-.01rem}

.session-section{margin-bottom:1.8rem}
.session-section-label{font-size:.92rem;text-transform:uppercase;letter-spacing:.2rem;color:var(--accent);margin-bottom:.75rem;font-weight:500}

.session-themes{display:flex;flex-wrap:wrap;gap:.5rem}
.session-theme-pill{padding:.42rem .95rem;border-radius:999px;font-size:.95rem;border:1px solid rgba(244,241,234,.12);background:rgba(244,241,234,.04);color:var(--ink-soft);transition:all .3s ease}
.session-theme-pill.heavy{background:rgba(214,178,109,.12);border-color:rgba(214,178,109,.3);color:var(--ink)}

.session-synthesis{font-family:var(--display);color:var(--ink-soft);line-height:1.7;font-size:1.18rem;padding:1rem 1.2rem;border-radius:14px;background:rgba(214,178,109,.03);border-left:2px solid rgba(214,178,109,.2)}

.session-guide{display:grid;gap:.7rem}
.session-guide-item{display:flex;flex-direction:column;gap:.25rem;font-size:1.08rem;color:var(--ink-soft);line-height:1.6;margin-bottom:1.1rem;padding-bottom:1.1rem;border-bottom:1px solid rgba(244,241,234,.04)}
.session-guide-item:last-child{margin-bottom:0;padding-bottom:0;border-bottom:none}
.session-guide-tag{font-size:.85rem;text-transform:uppercase;letter-spacing:.16rem;font-weight:600;white-space:nowrap}

.session-clarity-section{margin-top:2.2rem;padding-top:1.8rem;border-top:1px solid rgba(244,241,234,.06)}
.clarity-input{width:100%;background:rgba(14,17,21,.8);border:1px solid rgba(214,178,109,.18);border-radius:14px;color:var(--ink);padding:.9rem 1.2rem;font-family:var(--display);font-size:1.12rem;transition:border-color .2s ease}
.clarity-input:focus{outline:none;border-color:rgba(214,178,109,.6)}
.clarity-input::placeholder{color:rgba(244,241,234,.25)}
.clarity-saved{display:none;padding:1rem 1.2rem;border-radius:14px;background:rgba(125,183,174,.06);border:1px solid rgba(125,183,174,.2);text-align:center}
.clarity-saved.visible{display:block}
.clarity-saved .clarity-text{font-family:var(--display);font-size:1.22rem;color:var(--accent);line-height:1.55;font-style:italic}
.clarity-saved .clarity-tag{font-size:.88rem;text-transform:uppercase;letter-spacing:.22rem;color:var(--accent-2);margin-top:.6rem}

/* Session card entrance */
.session-card{opacity:0;animation:card-in .8s .1s ease forwards}
@keyframes card-in{to{opacity:1}}

/* === CO-AUTHORED GUIDE === */
.guide-section-label{font-size:.85rem;text-transform:uppercase;letter-spacing:.15rem;color:var(--accent-2);margin:1.5rem 0 .75rem;font-weight:500}
.guide-section-label:first-of-type{margin-top:0}


/* Add your own */
.add-own-wrap{margin-top:1.2rem}
.add-own-label{font-size:.92rem;color:var(--ink-soft);margin-bottom:.5rem}
.add-own-row{display:flex;gap:.5rem}
.add-own-input{flex:1;background:rgba(14,17,21,.8);border:1px solid rgba(244,241,234,.12);border-radius:12px;color:var(--ink);padding:.7rem 1rem;font-family:var(--mono);font-size:.88rem;transition:border-color .2s ease}
.add-own-input:focus{outline:none;border-color:rgba(214,178,109,.5)}
.add-own-input::placeholder{color:rgba(244,241,234,.25)}
.add-own-btn{padding:.7rem 1.2rem;border-radius:12px;border:1px solid rgba(214,178,109,.3);background:rgba(214,178,109,.1);color:var(--accent);font-family:var(--mono);font-size:.85rem;cursor:pointer;transition:all .2s ease;white-space:nowrap}
.add-own-btn:hover{background:rgba(214,178,109,.2);border-color:rgba(214,178,109,.5)}

/* Custom items in guide */
.guide-item.yours{border-color:rgba(125,183,174,.2);background:rgba(125,183,174,.04)}
.tag.yours{color:var(--accent-2)}

/* Session card: yours tag */
.session-guide-tag.yours{color:var(--accent-2)!important}

/* === AI NOTICING === */
.noticing-section{margin-top:2.2rem;padding-top:2rem;border-top:1px solid rgba(244,241,234,.04)}
.noticing-card{padding:1.4rem 1.6rem;border-radius:18px;background:rgba(125,183,174,.035);border:1px solid rgba(125,183,174,.12);opacity:0;animation:noticing-in 1s ease forwards}
@keyframes noticing-in{0%{opacity:0;transform:translateY(10px)}100%{opacity:1;transform:translateY(0)}}
.noticing-icon{font-size:.75rem;color:var(--accent-2);margin-bottom:.55rem;letter-spacing:.3rem}
.noticing-text{font-family:var(--display);font-size:1.18rem;color:var(--ink-mid);line-height:1.65}

/* === WHAT'S GROWING — Insight-first === */
.growing-viewer{min-height:300px;padding:2.5rem 2.8rem;border-radius:24px;border:1px solid rgba(125,183,174,.1);background:linear-gradient(165deg,rgba(18,22,28,.97),rgba(12,14,18,.97));position:relative;overflow:hidden;margin-left:-1.5rem;margin-right:-1.5rem;width:calc(100% + 3rem)}
.growing-viewer::before{content:"";position:absolute;top:0;left:0;right:0;height:2px;background:linear-gradient(90deg,var(--accent-2),var(--accent),var(--accent-3));opacity:.35}
.growing-head{display:flex;justify-content:space-between;align-items:center;margin-bottom:2.5rem;padding-bottom:1.2rem;border-bottom:1px solid rgba(244,241,234,.04)}
.growing-title{font-family:var(--display);font-size:2.2rem;color:var(--ink);font-weight:500;letter-spacing:-.01rem}
.growing-empty{color:var(--ink-soft);font-size:1.1rem;padding:4rem 2rem;text-align:center;line-height:1.7}
.growing-list{display:grid;gap:2.5rem}

/* Single session state */
.growing-single{padding:2.5rem 2rem;text-align:center}
.growing-single-icon{font-size:1rem;color:var(--accent-2);margin-bottom:1rem;letter-spacing:.4rem}
.growing-single-title{font-family:var(--display);font-size:1.6rem;color:var(--ink);margin-bottom:.8rem}
.growing-single-body{font-size:1rem;color:var(--ink-soft);line-height:1.7;max-width:420px;margin:0 auto 2rem}
.growing-single-words-label{font-size:.85rem;text-transform:uppercase;letter-spacing:.2rem;color:var(--accent);margin-bottom:1rem;font-weight:500}
.growing-single-quote{text-align:left;padding:1.1rem 1.3rem;border-radius:14px;background:rgba(244,241,234,.02);border:1px solid rgba(244,241,234,.05);margin-bottom:.7rem}
.growing-single-quote-label{font-size:.85rem;text-transform:uppercase;letter-spacing:.12rem;color:var(--ink-soft);margin-bottom:.4rem;font-weight:500}
.growing-single-quote-text{font-family:var(--display);font-size:1.08rem;color:var(--ink);line-height:1.6}

/* Loading state for insight generation */
.growing-insight-loading{display:flex;flex-direction:column;align-items:center;gap:1rem;padding:3.5rem 1rem}
.growing-insight-loading .loading-dots{display:flex;gap:.4rem}
.growing-insight-loading .loading-dots span{width:7px;height:7px;border-radius:50%;background:var(--accent);opacity:.3;animation:dot-pulse 1.2s ease-in-out infinite}
.growing-insight-loading .loading-dots span:nth-child(2){animation-delay:.2s}
.growing-insight-loading .loading-dots span:nth-child(3){animation-delay:.4s}
.growing-insight-loading .loading-text{color:var(--ink-soft);font-size:1rem}

/* === GENERATED INSIGHT SECTIONS === */
.growing-insight-wrap{display:grid;gap:0;font-family:'DM Sans',var(--body),sans-serif}
.gi-section{padding:2.2rem 0;border-bottom:1px solid rgba(244,241,234,.04)}
.gi-section:first-child{padding-top:.5rem}
.gi-section:last-child{border-bottom:none;padding-bottom:.5rem}

/* Section header with icon */
.gi-head{display:flex;align-items:center;gap:.7rem;margin-bottom:1.2rem}
.gi-icon{width:36px;height:36px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:1rem;flex-shrink:0}
.gi-label{font-size:.85rem;font-weight:600;text-transform:uppercase;letter-spacing:.18rem;margin:0}

/* Arc */
.gi-arc .gi-icon{background:rgba(214,178,109,.1)}
.gi-arc .gi-label{color:var(--accent)}
.gi-arc-text{font-family:'Fraunces',var(--display),serif;font-size:1.5rem;color:var(--ink);line-height:1.75;font-weight:300}

/* Recurring gravity */
.gi-gravity .gi-icon{background:rgba(214,178,109,.1)}
.gi-gravity .gi-label{color:var(--accent)}
.gi-gravity-list{display:grid;gap:1rem}
.gi-gravity-item{padding:1.3rem 1.5rem;border-radius:16px;background:rgba(214,178,109,.03);border:1px solid rgba(214,178,109,.07)}
.gi-gravity-label{font-size:.85rem;font-weight:600;text-transform:uppercase;letter-spacing:.12rem;color:var(--accent);margin-bottom:.5rem}
.gi-gravity-insight{font-size:1.15rem;color:var(--ink-soft);line-height:1.7}

/* Contradiction */
.gi-contradiction{background:rgba(196,110,95,.025);border-radius:16px;padding:2.2rem!important;border:1px solid rgba(196,110,95,.08)!important;border-bottom:1px solid rgba(196,110,95,.08)!important}
.gi-contradiction .gi-icon{background:rgba(196,110,95,.1);color:var(--accent-3)}
.gi-contradiction .gi-label{color:var(--accent-3)}
.gi-contradiction-text{font-size:1.15rem;color:var(--ink);line-height:1.7}

/* Shifts */
.gi-shifts .gi-icon{background:rgba(125,183,174,.1)}
.gi-shifts .gi-label{color:var(--accent-2)}
.gi-shift-item{padding:1.3rem 1.5rem;border-radius:14px;background:rgba(125,183,174,.025);border:1px solid rgba(125,183,174,.06);margin-bottom:.8rem}
.gi-shift-item:last-child{margin-bottom:0}
.gi-shift-label{font-size:.85rem;font-weight:600;text-transform:uppercase;letter-spacing:.12rem;color:var(--accent-2);margin-bottom:.5rem}
.gi-shift-text{font-size:1.15rem;color:var(--ink-soft);line-height:1.7}

/* Mirror — their words reflected */
.gi-mirror .gi-icon{background:rgba(160,140,200,.1);color:#a08cc8}
.gi-mirror .gi-label{color:#a08cc8}
.gi-mirror-item{padding:1.4rem 1.6rem;border-radius:16px;background:rgba(160,140,200,.02);border:1px solid rgba(160,140,200,.06);margin-bottom:.9rem;position:relative}
.gi-mirror-item:last-child{margin-bottom:0}
.gi-mirror-quote{font-family:'Fraunces',var(--display),serif;font-size:1.15rem;color:var(--ink);font-style:italic;line-height:1.65;margin-bottom:.8rem}
.gi-mirror-reveals{font-size:1.15rem;color:var(--ink-soft);line-height:1.65;border-left:2px solid rgba(160,140,200,.2);padding-left:1rem}

/* The unsaid */
.gi-unsaid{text-align:center;padding:2.8rem 1.5rem!important;border-bottom:none!important}
.gi-unsaid .gi-icon{background:rgba(196,110,95,.1);color:var(--accent-3)}
.gi-unsaid .gi-head{justify-content:center}
.gi-unsaid .gi-label{color:var(--accent-3)}
.gi-unsaid-text{font-family:'Fraunces',var(--display),serif;font-size:1.45rem;color:var(--ink);line-height:1.75;font-style:italic;font-weight:300;max-width:540px;margin:0 auto}
.gi-unsaid-invitation{font-size:.92rem;color:var(--ink-soft);opacity:.35;margin-top:1.6rem;line-height:1.55;max-width:400px;margin-left:auto;margin-right:auto}

/* Press-and-hold resonance glow */
.gi-held{position:relative}
.gi-held::after{content:"";position:absolute;inset:-2px;border-radius:inherit;background:radial-gradient(ellipse at center,rgba(214,178,109,.08),transparent 70%);opacity:0;animation:held-glow .8s ease forwards;pointer-events:none}
@keyframes held-glow{0%{opacity:0;transform:scale(.98)}40%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(1.01)}}
.gi-held-dot{position:absolute;top:.8rem;right:.8rem;width:6px;height:6px;border-radius:50%;background:rgba(214,178,109,.4);opacity:0;animation:dot-in .4s ease .3s forwards}
@keyframes dot-in{to{opacity:1}}

/* Who you're becoming — the capstone */
.gi-becoming{text-align:center;padding:3rem 2rem!important;border-bottom:none!important;background:linear-gradient(160deg,rgba(214,178,109,.045),rgba(125,183,174,.035));border-radius:20px;margin-top:.5rem;position:relative;overflow:hidden}
.gi-becoming::before{content:'';position:absolute;inset:0;background:radial-gradient(ellipse at 50% 120%,rgba(214,178,109,.06),transparent 70%);pointer-events:none}
.gi-becoming .gi-icon{width:40px;height:40px;border-radius:12px;background:linear-gradient(135deg,rgba(214,178,109,.15),rgba(125,183,174,.12));font-size:1.1rem}
.gi-becoming .gi-head{justify-content:center}
.gi-becoming .gi-label{color:var(--accent);position:relative;z-index:1}
.gi-becoming-text{font-family:'Fraunces',var(--display),serif;font-size:1.35rem;font-weight:300;color:var(--ink);line-height:1.8;max-width:580px;margin:0 auto;position:relative;z-index:1}

/* 8. Post-reading reflection */
.gi-reflection{padding:2.8rem 2rem!important;border-bottom:none!important;text-align:center;margin-top:.5rem;opacity:0;animation:reflection-in 1s ease .4s forwards}
@keyframes reflection-in{from{opacity:0;transform:translateY(12px)}to{opacity:1;transform:translateY(0)}}
.gi-reflection .gi-icon{background:rgba(214,178,109,.08)}
.gi-reflection .gi-label{color:var(--ink-soft)}
.gi-reflection-question{font-family:'Fraunces',var(--display),serif;font-size:1.25rem;font-weight:300;color:var(--ink);line-height:1.7;max-width:500px;margin:0 auto 1.8rem;font-style:italic}
.gi-reflection-input{width:100%;max-width:480px;margin:0 auto;display:block;background:rgba(14,17,21,.6);border:1px solid rgba(214,178,109,.15);border-radius:16px;color:var(--ink);padding:1.1rem 1.3rem;font-family:'Fraunces',var(--display),serif;font-size:1.05rem;font-style:italic;line-height:1.6;resize:none;transition:border-color .3s ease;min-height:80px}
.gi-reflection-input:focus{outline:none;border-color:rgba(214,178,109,.4)}
.gi-reflection-input::placeholder{color:rgba(244,241,234,.15);font-style:italic}
.gi-reflection-hint{font-size:.85rem;color:var(--ink-soft);opacity:.3;margin-top:.6rem;letter-spacing:.03rem}
.gi-reflection-response{max-width:480px;margin:0 auto;opacity:0;animation:reflection-in .8s ease forwards}
.gi-reflection-naming{font-family:'Fraunces',var(--display),serif;font-size:1.15rem;color:var(--accent);line-height:1.65;font-style:italic;font-weight:300;margin-bottom:1rem}
.gi-reflection-saved{font-size:.85rem;color:var(--ink-soft);opacity:.4;letter-spacing:.04rem}
.gi-reflection-toggle{font-size:.88rem;color:var(--ink-soft);opacity:.35;margin-top:1.2rem;cursor:pointer;transition:all .25s ease;letter-spacing:.02rem}
.gi-reflection-toggle:hover{opacity:.7;color:var(--accent-3)}

/* === Collapsed session history === */
.growing-history-wrap{padding-top:.5rem}
.growing-history-toggle{width:100%;background:none;border:1px solid rgba(244,241,234,.04);border-radius:12px;padding:.75rem 1rem;color:var(--ink-soft);font-family:var(--mono);font-size:.85rem;cursor:pointer;transition:all .2s ease;text-align:left;letter-spacing:.04rem;display:flex;align-items:center;gap:.5rem}
.growing-history-toggle::before{content:"\u25B8";font-size:.65rem;transition:transform .2s ease}
.growing-history-toggle.open::before{transform:rotate(90deg)}
.growing-history-toggle:hover{border-color:rgba(244,241,234,.1);color:var(--ink)}
.growing-history-inner{padding:.8rem 0}
.growing-history-row{display:grid;grid-template-columns:auto 1fr;gap:.4rem .8rem;padding:.6rem .8rem;border-radius:10px;font-size:.85rem;line-height:1.5;transition:background .2s ease}
.growing-history-row:hover{background:rgba(244,241,234,.02)}
.growing-history-date{color:var(--accent-2);font-size:.85rem;white-space:nowrap;padding-top:.1rem}
.growing-history-themes{color:var(--ink-soft)}
.growing-history-clarity{grid-column:2;font-family:var(--display);font-size:.88rem;color:var(--accent);opacity:.6}

@media(max-width:900px){.nav-links{display:none}.nav{gap:1rem}}
/* ── Takeaway Infographic v5 — THE GIFT ── */

/* Overlay */
.takeaway-overlay{position:fixed;inset:0;z-index:9999;display:flex;align-items:flex-start;justify-content:center;padding:.8rem;opacity:0;overflow-y:auto;-webkit-overflow-scrolling:touch;background:radial-gradient(700px 400px at 30% 0%,rgba(244,196,109,.12),transparent 50%),radial-gradient(500px 350px at 75% 5%,rgba(94,211,192,.10),transparent 50%),radial-gradient(400px 300px at 50% 95%,rgba(240,139,115,.08),transparent 50%),#020406;backdrop-filter:blur(30px);animation:tk-ov .5s ease forwards}
@keyframes tk-ov{to{opacity:1}}

/* Card */
.takeaway-card{--gold:#f4c46d;--teal:#5ed3c0;--coral:#f08b73;--sky:#9ad0ff;--violet:#b4a0dc;--ink:#f7f1e7;--hi:rgba(247,241,231,.92);--mid:rgba(247,241,231,.65);--lo:rgba(247,241,231,.35);--bg:#060910;--display:"Fraunces",serif;--sans:"Space Grotesk","DM Sans",sans-serif;width:100%;max-width:640px;margin:1rem auto;position:relative;overflow:hidden;border-radius:24px;font-family:var(--sans);color:var(--ink);background:var(--bg);border:1px solid rgba(244,196,109,.12);box-shadow:0 40px 100px rgba(0,0,0,.7);opacity:0;transform:translateY(14px);animation:tk-ci .6s ease .1s forwards}
@keyframes tk-ci{to{opacity:1;transform:translateY(0)}}
.takeaway-card::after{content:"";position:absolute;inset:0;background:url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.85' numOctaves='3'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='.02'/%3E%3C/svg%3E");pointer-events:none;border-radius:24px}
.takeaway-close{position:absolute;top:.8rem;right:.8rem;background:rgba(247,241,231,.05);border:1px solid rgba(247,241,231,.08);color:var(--mid);font-size:1rem;cursor:pointer;opacity:.4;transition:all .2s;z-index:3;padding:.3rem .5rem;border-radius:8px;line-height:1}
.takeaway-close:hover{opacity:1;background:rgba(247,241,231,.1)}

/* ── Session History Viewer ── */
.history-overlay{position:fixed;inset:0;z-index:9998;display:flex;flex-direction:column;background:var(--bg);overflow-y:auto;-webkit-overflow-scrolling:touch;opacity:0;animation:tk-ov .4s ease forwards}
.history-header{position:sticky;top:0;z-index:2;display:flex;align-items:center;justify-content:space-between;padding:1.2rem 1.5rem;background:rgba(6,9,16,.95);backdrop-filter:blur(20px);border-bottom:1px solid rgba(244,241,234,.06)}
.history-title{font-family:var(--mono);font-size:1rem;letter-spacing:.15em;text-transform:uppercase;color:var(--accent)}
.history-close{background:none;border:1px solid rgba(244,241,234,.1);color:var(--ink-soft);padding:.3rem .7rem;border-radius:8px;cursor:pointer;font-size:.85rem;transition:all .2s}
.history-close:hover{background:rgba(244,241,234,.05);color:var(--ink)}
.history-list{padding:1rem 1.2rem 3rem;max-width:680px;margin:0 auto;width:100%}
.history-card{border:1px solid rgba(244,241,234,.06);border-radius:16px;background:rgba(244,241,234,.02);margin-bottom:.8rem;overflow:hidden;transition:border-color .2s}
.history-card:hover{border-color:rgba(214,178,109,.2)}
.history-card-head{display:flex;align-items:center;justify-content:space-between;padding:1rem 1.2rem;cursor:pointer;gap:.8rem}
.history-card-date{font-family:var(--mono);font-size:.78rem;letter-spacing:.08em;color:var(--ink-soft);white-space:nowrap}
.history-card-title{font-family:'Fraunces',serif;font-size:.95rem;color:var(--ink);font-weight:300;flex:1;text-align:right;opacity:.6}
.history-card-arrow{color:var(--ink-soft);opacity:.3;font-size:.8rem;transition:transform .25s}
.history-card.is-open .history-card-arrow{transform:rotate(90deg)}
.history-card-pills{display:flex;gap:.35rem;flex-wrap:wrap;padding:0 1.2rem .8rem}
.history-card-pill{font-size:.72rem;padding:.2rem .6rem;border-radius:999px;background:rgba(214,178,109,.1);color:var(--accent);font-family:var(--mono);letter-spacing:.04em}
.history-card-body{max-height:0;overflow:hidden;transition:max-height .4s ease}
.history-card.is-open .history-card-body{max-height:2000px}
.history-card-inner{padding:0 1.2rem 1.2rem}
.history-section{margin-bottom:1rem}
.history-section-label{font-family:var(--mono);font-size:.72rem;letter-spacing:.14em;text-transform:uppercase;color:var(--ink-soft);opacity:.5;margin-bottom:.4rem}
.history-reading{font-family:'Fraunces',serif;font-size:1.05rem;color:var(--ink);line-height:1.65;font-weight:300}
.history-clarity{font-family:'Fraunces',serif;font-size:1rem;color:var(--accent);font-style:italic;line-height:1.55}
.history-guide-item{display:flex;gap:.6rem;align-items:baseline;margin-bottom:.5rem;font-size:.95rem;color:var(--ink-soft);line-height:1.55}
.history-guide-tag{font-size:.72rem;text-transform:uppercase;letter-spacing:.1em;font-weight:700;white-space:nowrap}
.history-guide-response{color:rgba(165,235,220,.8);font-style:italic;margin-top:.2rem;padding-left:1rem;font-size:.95rem}
.history-guide-echo{color:rgba(165,235,220,.4);font-size:.88rem;font-style:italic;margin-top:.15rem;padding-left:1rem}
@media print{.history-overlay{position:static;overflow:visible}.history-card-body{max-height:none!important}.history-header{position:static}.history-close{display:none}.history-card{break-inside:avoid;page-break-inside:avoid;border:1px solid #ccc}}

/* Section anim */
.tk-s{opacity:0;transform:translateY(14px);animation:tk-si .55s ease forwards}
@keyframes tk-si{to{opacity:1;transform:translateY(0)}}
.tk-d1{animation-delay:.12s}.tk-d2{animation-delay:.22s}.tk-d3{animation-delay:.32s}.tk-d4{animation-delay:.42s}.tk-d5{animation-delay:.52s}.tk-d6{animation-delay:.62s}.tk-d7{animation-delay:.72s}.tk-d8{animation-delay:.82s}.tk-d9{animation-delay:.92s}.tk-d10{animation-delay:1.02s}.tk-d11{animation-delay:1.12s}.tk-d12{animation-delay:1.22s}.tk-d13{animation-delay:1.32s}.tk-d14{animation-delay:1.42s}.tk-d15{animation-delay:1.52s}.tk-d16{animation-delay:1.62s}.tk-d17{animation-delay:1.72s}.tk-d18{animation-delay:1.82s}.tk-d19{animation-delay:1.92s}.tk-d20{animation-delay:2.02s}

/* ── Constellation hero ── */
.tk-constellation{width:100%;position:relative;z-index:1;background:linear-gradient(180deg,rgba(244,196,109,.025) 0%,transparent 60%)}
.tk-constellation svg{width:100%;display:block}

/* ── Map title — BIG ── */
.tk-map-title{padding:.2rem 2rem 1rem;text-align:center;position:relative;z-index:1}
.tk-map-title-text{font-family:var(--display);font-size:2.2rem;color:var(--ink);line-height:1.25;font-weight:300;letter-spacing:-.02em}
.tk-map-title-sub{font-size:.82rem;letter-spacing:.25rem;text-transform:uppercase;color:var(--gold);opacity:.55;margin-top:.4rem}

/* ── Section header pattern ── */
.tk-sheader{display:flex;align-items:center;gap:.6rem;margin-bottom:.8rem}
.tk-sheader-icon{font-size:1.4rem;line-height:1}
.tk-sheader-text{font-size:1.05rem;letter-spacing:.25rem;text-transform:uppercase;font-weight:700}

/* ── Reading pullquote ── */
.tk-reading{padding:1rem 2.2rem 1.4rem;text-align:center;position:relative;z-index:1}
.tk-reading::before{content:"\201C";position:absolute;top:-.2rem;left:50%;transform:translateX(-50%);font-family:var(--display);font-size:5rem;color:var(--gold);opacity:.08;line-height:1;pointer-events:none}
.tk-reading-text{font-family:var(--display);font-size:1.45rem;color:var(--hi);line-height:1.55;font-weight:300;max-width:500px;margin:0 auto}

/* ── TENSIONS & CONNECTIONS — the star section ── */
.tk-tensions{padding:.8rem 1.6rem 1rem;position:relative;z-index:1}
.tk-tension-card{padding:1rem 1.2rem;border-radius:14px;margin-bottom:.6rem;position:relative;overflow:hidden}
.tk-tension-card::before{content:"";position:absolute;inset:0;border-radius:14px;opacity:.06}
.tk-tension-from-to{display:flex;align-items:center;gap:.5rem;margin-bottom:.5rem;flex-wrap:wrap}
.tk-tension-node{font-size:.8rem;letter-spacing:.1rem;text-transform:uppercase;font-weight:700;padding:.3rem .7rem;border-radius:99px;background:rgba(244,196,109,.08);border:1px solid rgba(244,196,109,.2);color:var(--gold)}
.tk-tension-arrow{font-size:1rem;color:var(--gold);opacity:.4}
.tk-tension-label{font-size:1.08rem;font-weight:700;color:var(--hi);margin-bottom:.3rem}
.tk-tension-insight{font-size:1rem;color:var(--mid);line-height:1.55}
.tk-tension-card:nth-child(2){border:1px solid rgba(244,196,109,.12)}.tk-tension-card:nth-child(2)::before{background:var(--gold)}
.tk-tension-card:nth-child(3){border:1px solid rgba(94,211,192,.12)}.tk-tension-card:nth-child(3)::before{background:var(--teal)}
.tk-tension-card:nth-child(4){border:1px solid rgba(240,139,115,.12)}.tk-tension-card:nth-child(4)::before{background:var(--coral)}
.tk-tension-card:nth-child(5){border:1px solid rgba(154,208,255,.12)}.tk-tension-card:nth-child(5)::before{background:var(--sky)}
.tk-tension-card:nth-child(2) .tk-tension-node{background:rgba(244,196,109,.08);border-color:rgba(244,196,109,.2);color:var(--gold)}
.tk-tension-card:nth-child(3) .tk-tension-node{background:rgba(94,211,192,.08);border-color:rgba(94,211,192,.2);color:var(--teal)}
.tk-tension-card:nth-child(4) .tk-tension-node{background:rgba(240,139,115,.08);border-color:rgba(240,139,115,.2);color:var(--coral)}
.tk-tension-card:nth-child(5) .tk-tension-node{background:rgba(154,208,255,.08);border-color:rgba(154,208,255,.2);color:var(--sky)}

/* ── Guide grid ── */
.tk-guide{padding:.6rem 1.6rem 1rem;position:relative;z-index:1}
.tk-guide-grid{display:grid;grid-template-columns:1fr 1fr;gap:.5rem}
.tk-guide-item{padding:.7rem .9rem;border-radius:12px;position:relative;overflow:hidden}
.tk-guide-item::before{content:"";position:absolute;inset:0;opacity:.07;border-radius:12px}
.tk-gi-head{display:flex;align-items:center;gap:.4rem;margin-bottom:.25rem}
.tk-gi-icon{font-size:1rem}
.tk-gi-type{font-size:.88rem;letter-spacing:.14rem;text-transform:uppercase;font-weight:700}
.tk-guide-text{font-size:1.08rem;color:var(--hi);line-height:1.45}
.tk-guide-item.tk-wide{grid-column:1/-1}
.tk-guide-item[data-type="act"]{border:1px solid rgba(94,211,192,.2)}.tk-guide-item[data-type="act"]::before{background:var(--teal)}.tk-guide-item[data-type="act"] .tk-gi-type{color:var(--teal)}.tk-guide-item[data-type="act"] .tk-gi-icon{color:var(--teal)}
.tk-guide-item[data-type="sit"]{border:1px solid rgba(154,208,255,.2)}.tk-guide-item[data-type="sit"]::before{background:var(--sky)}.tk-guide-item[data-type="sit"] .tk-gi-type{color:var(--sky)}.tk-guide-item[data-type="sit"] .tk-gi-icon{color:var(--sky)}
.tk-guide-item[data-type="deepen"]{border:1px solid rgba(244,196,109,.2)}.tk-guide-item[data-type="deepen"]::before{background:var(--gold)}.tk-guide-item[data-type="deepen"] .tk-gi-type{color:var(--gold)}.tk-guide-item[data-type="deepen"] .tk-gi-icon{color:var(--gold)}
.tk-guide-item[data-type="release"]{border:1px solid rgba(240,139,115,.2)}.tk-guide-item[data-type="release"]::before{background:var(--coral)}.tk-guide-item[data-type="release"] .tk-gi-type{color:var(--coral)}.tk-guide-item[data-type="release"] .tk-gi-icon{color:var(--coral)}
.tk-guide-item[data-type="surrender"]{border:1px solid rgba(180,160,220,.2)}.tk-guide-item[data-type="surrender"]::before{background:var(--violet)}.tk-guide-item[data-type="surrender"] .tk-gi-type{color:var(--violet)}.tk-guide-item[data-type="surrender"] .tk-gi-icon{color:var(--violet)}
.tk-guide-item[data-type="do"]{border:1px solid rgba(94,211,192,.2)}.tk-guide-item[data-type="do"]::before{background:var(--teal)}.tk-guide-item[data-type="do"] .tk-gi-type{color:var(--teal)}.tk-guide-item[data-type="do"] .tk-gi-icon{color:var(--teal)}
.tk-guide-item[data-type="notice"]{border:1px solid rgba(154,208,255,.2)}.tk-guide-item[data-type="notice"]::before{background:var(--sky)}.tk-guide-item[data-type="notice"] .tk-gi-type{color:var(--sky)}.tk-guide-item[data-type="notice"] .tk-gi-icon{color:var(--sky)}
.tk-guide-item[data-type="ask"]{border:1px solid rgba(244,196,109,.2)}.tk-guide-item[data-type="ask"]::before{background:var(--gold)}.tk-guide-item[data-type="ask"] .tk-gi-type{color:var(--gold)}.tk-guide-item[data-type="ask"] .tk-gi-icon{color:var(--gold)}

/* ── Gravity bars ── */
.tk-gravity{padding:.6rem 2rem 1rem;position:relative;z-index:1}
.tk-gbar{margin-bottom:.65rem}
.tk-gbar-name{font-size:.92rem;color:var(--hi);margin-bottom:.25rem;font-weight:600;letter-spacing:.02rem}
.tk-gbar-track{height:12px;background:rgba(247,241,231,.03);border-radius:99px;overflow:hidden}
.tk-gbar-fill{height:100%;border-radius:99px;position:relative;transition:width 1s cubic-bezier(.25,.46,.45,.94)}
.tk-gbar:nth-child(2) .tk-gbar-fill{background:linear-gradient(90deg,rgba(244,196,109,.9),rgba(244,196,109,.4));box-shadow:0 0 20px rgba(244,196,109,.25)}
.tk-gbar:nth-child(3) .tk-gbar-fill{background:linear-gradient(90deg,rgba(94,211,192,.9),rgba(94,211,192,.4));box-shadow:0 0 20px rgba(94,211,192,.2)}
.tk-gbar:nth-child(4) .tk-gbar-fill{background:linear-gradient(90deg,rgba(240,139,115,.9),rgba(240,139,115,.4));box-shadow:0 0 20px rgba(240,139,115,.2)}
.tk-gbar:nth-child(5) .tk-gbar-fill{background:linear-gradient(90deg,rgba(154,208,255,.9),rgba(154,208,255,.4));box-shadow:0 0 20px rgba(154,208,255,.15)}
.tk-gbar-fill::after{content:"";position:absolute;top:0;right:0;bottom:0;width:40%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.15));border-radius:99px}

/* ── Arc timeline ── */
.tk-arc{padding:.6rem 2rem 1rem;position:relative;z-index:1}
.tk-arc svg{width:100%;display:block}
.tk-arc-text{font-size:1rem;color:var(--mid);line-height:1.6;text-align:center;margin-top:.7rem}

/* ── Contradiction ── */
.tk-contra{padding:.6rem 1.6rem 1rem;position:relative;z-index:1}
.tk-contra-visual{position:relative;margin-bottom:.7rem}
.tk-contra-visual svg{width:100%;display:block}
.tk-contra-row{display:flex;gap:.4rem;align-items:stretch}
.tk-contra-side{flex:1;padding:1rem 1.1rem;border-radius:14px;font-size:1rem;color:var(--hi);line-height:1.5}
.tk-contra-left{background:rgba(240,139,115,.06);border:1px solid rgba(240,139,115,.15);text-align:right}
.tk-contra-right{background:rgba(94,211,192,.05);border:1px solid rgba(94,211,192,.12);text-align:left}
.tk-contra-vs{display:flex;align-items:center;font-size:1rem;color:var(--coral);opacity:.5;padding:0 .2rem}

/* ── The Unsaid ── */
.tk-unsaid{text-align:center;padding:2rem 1.5rem;position:relative;margin:.2rem 0}
.tk-unsaid::before{content:"";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:220px;height:220px;border-radius:50%;background:radial-gradient(circle,rgba(240,139,115,.1),transparent 60%);pointer-events:none;animation:tk-br 5s ease-in-out infinite}
@keyframes tk-br{0%,100%{transform:translate(-50%,-50%) scale(1);opacity:1}50%{transform:translate(-50%,-50%) scale(1.2);opacity:.35}}
.tk-unsaid::after{content:"";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:280px;height:280px;border-radius:50%;border:1px solid rgba(240,139,115,.06);pointer-events:none;animation:tk-rg 7s ease-in-out infinite}
@keyframes tk-rg{0%,100%{transform:translate(-50%,-50%) scale(1);opacity:.35}50%{transform:translate(-50%,-50%) scale(1.1);opacity:.08}}
.tk-unsaid-text{font-family:var(--display);font-size:1.55rem;color:var(--ink);line-height:1.5;font-weight:300;max-width:420px;margin:0 auto;position:relative;z-index:1}

/* ── Becoming ── */
.tk-becoming{padding:.6rem 2rem 1.4rem;text-align:center;position:relative;z-index:1;background:linear-gradient(180deg,transparent,rgba(244,196,109,.025))}
.tk-becoming-text{font-family:var(--display);font-size:1.4rem;color:var(--hi);line-height:1.5;font-weight:300;max-width:440px;margin:0 auto}

/* ── Mirror quotes ── */
.tk-mirror{padding:.6rem 2rem 1rem;position:relative;z-index:1}
.tk-mirror-item{padding:.85rem 1.2rem;border-left:3px solid rgba(154,208,255,.3);margin-bottom:.9rem;background:linear-gradient(90deg,rgba(154,208,255,.05),transparent 40%);border-radius:0 10px 10px 0}
.tk-mirror-quote{font-family:var(--display);font-size:1.2rem;font-style:italic;color:var(--hi);line-height:1.55}
.tk-mirror-insight{font-family:'Space Grotesk',sans-serif;font-size:1rem;color:rgba(154,208,255,.65);line-height:1.55;margin-top:.45rem;font-style:normal}

/* ── Noticing ── */
.tk-noticing{padding:.6rem 2rem 1rem;position:relative;z-index:1}
.tk-noticing-text{font-size:1.15rem;color:var(--mid);line-height:1.65;font-style:italic}

/* ── Annotations ── */
.tk-annot{padding:.4rem 2rem;position:relative;z-index:1}
.tk-annot-item{font-size:.98rem;color:var(--mid);line-height:1.5;padding:.55rem 1rem;border-left:3px solid rgba(94,211,192,.25);background:rgba(94,211,192,.03);border-radius:0 10px 10px 0;margin-bottom:.4rem}

/* ── Divider ── */
.tk-div{height:1px;margin:.6rem 2rem;position:relative;overflow:hidden}
.tk-div::after{content:"";position:absolute;inset:0;background:linear-gradient(90deg,transparent 5%,rgba(244,196,109,.1) 50%,transparent 95%)}

/* ── Hold dots ── */
.tk-holds{text-align:center;padding:.5rem 1.5rem;position:relative;z-index:1}
.tk-holds-dots{display:flex;gap:7px;justify-content:center;flex-wrap:wrap}
.tk-hold-dot{width:7px;height:7px;border-radius:50%;background:var(--gold);opacity:.45;animation:tk-hp 3.2s ease-in-out infinite}
.tk-hold-dot:nth-child(odd){animation-delay:.6s}.tk-hold-dot:nth-child(3n){animation-delay:1.2s}
@keyframes tk-hp{0%,100%{opacity:.35;transform:scale(1)}50%{opacity:.9;transform:scale(1.2)}}

/* ── Footer ── */
.tk-parting{padding:1.8rem 2.2rem 1.2rem;text-align:center;position:relative;z-index:1}
.tk-parting-label{font-size:.68rem;letter-spacing:.35em;text-transform:uppercase;color:rgba(214,178,109,.35);margin-bottom:1rem}
.tk-parting-text{font-family:var(--display);font-size:1.25rem;color:rgba(247,241,231,.6);line-height:1.65;font-weight:300;font-style:italic;max-width:420px;margin:0 auto}
.tk-parting-source{font-size:.72rem;color:rgba(247,241,231,.25);margin-top:.8rem;letter-spacing:.06em}
.tk-parting-loading{color:rgba(247,241,231,.15);font-size:.8rem;font-style:italic}
@keyframes parting-in{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:translateY(0)}}
.tk-parting.visible .tk-parting-text,.tk-parting.visible .tk-parting-source{animation:parting-in .8s ease forwards}
.tk-footer{padding:.8rem 2rem 1.4rem;display:flex;justify-content:space-between;font-size:.72rem;letter-spacing:.12rem;color:var(--lo);text-transform:uppercase;position:relative;z-index:1}

@media(prefers-reduced-motion:reduce){.takeaway-overlay,.takeaway-card,.tk-s,.tk-unsaid::before,.tk-unsaid::after,.tk-hold-dot,.tk-div::after{animation:none!important;opacity:1!important;transform:none!important}}

/* ── Reading Gallery ── */
.reading-gallery{margin-top:2rem;padding-top:1.5rem;border-top:1px solid rgba(244,241,234,.04)}
.reading-gallery-title{font-size:.82rem;letter-spacing:.2rem;text-transform:uppercase;color:var(--accent);margin-bottom:1rem;font-weight:600;display:flex;align-items:center;gap:.5rem}
.reading-gallery-title::before{content:"\u25C8";font-size:.7rem}
.reading-gallery-row{display:flex;gap:.6rem;overflow-x:auto;padding-bottom:.6rem;-webkit-overflow-scrolling:touch;scrollbar-width:thin;scrollbar-color:rgba(214,178,109,.15) transparent}
.reading-gallery-card{flex:0 0 140px;padding:.9rem;border-radius:14px;background:rgba(214,178,109,.04);border:1px solid rgba(214,178,109,.1);cursor:pointer;transition:all .25s ease;position:relative;overflow:hidden}
.reading-gallery-card:hover{border-color:rgba(214,178,109,.3);background:rgba(214,178,109,.07);transform:translateY(-2px)}
.reading-gallery-card.rgc-current{border-color:rgba(214,178,109,.25);background:rgba(214,178,109,.06)}
.reading-gallery-card.rgc-current::after{content:"latest";position:absolute;top:.5rem;right:.5rem;font-size:.5rem;letter-spacing:.1rem;text-transform:uppercase;color:var(--accent);opacity:.5}
.rgc-date{font-size:.72rem;color:var(--ink-soft);letter-spacing:.08rem;margin-bottom:.4rem}
.rgc-title{font-family:var(--display);font-size:.88rem;color:var(--ink);line-height:1.35;display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;overflow:hidden}
.rgc-themes{font-size:.62rem;color:var(--accent-2);margin-top:.4rem;opacity:.5;display:-webkit-box;-webkit-line-clamp:1;-webkit-box-orient:vertical;overflow:hidden}

/* ── Download Action Bar ── */
.tk-actions{display:flex;justify-content:center;gap:.6rem;padding:.4rem 2rem 1rem;position:relative;z-index:3}
.tk-action-btn{background:rgba(247,241,231,.04);border:1px solid rgba(247,241,231,.08);color:rgba(247,241,231,.45);font-size:.72rem;letter-spacing:.1rem;text-transform:uppercase;padding:.45rem .9rem;border-radius:99px;cursor:pointer;transition:all .25s ease;display:flex;align-items:center;gap:.35rem;font-family:var(--sans)}
.tk-action-btn:hover{background:rgba(247,241,231,.08);color:rgba(247,241,231,.7);border-color:rgba(247,241,231,.15)}
.tk-action-btn .tk-action-icon{font-size:.85rem}
.tk-action-btn.tk-saving{pointer-events:none;opacity:.3}

/* ── Portrait dimension styles ── */
.tk-portrait-section{padding:.6rem 1.6rem 1rem;position:relative;z-index:1}
.tk-portrait-section svg{width:100%;display:block;margin:.3rem 0}

.tk-strengths-grid{display:grid;grid-template-columns:1fr 1fr;gap:.7rem}
@media(max-width:420px){.tk-strengths-grid{grid-template-columns:1fr}}
.tk-strength-item{padding:1rem 1.2rem;border-radius:12px;border:1px solid rgba(247,241,231,.06);position:relative;overflow:hidden}
.tk-strength-name{font-size:1rem;letter-spacing:.12rem;text-transform:uppercase;font-weight:700;margin-bottom:.4rem}
.tk-strength-evidence{font-size:.95rem;color:rgba(247,241,231,.55);line-height:1.6;font-style:italic}

/* ── Print styles ── */
@media print{
body,body *{visibility:hidden!important}
.takeaway-overlay,.takeaway-overlay *{visibility:visible!important}
.takeaway-overlay{position:absolute!important;inset:0!important;background:#020406!important;backdrop-filter:none!important;overflow:visible!important;padding:0!important}
.takeaway-card{margin:0!important;max-width:100%!important;box-shadow:none!important;border:none!important;border-radius:0!important}
.takeaway-close,.tk-actions{display:none!important}
.tk-s{opacity:1!important;transform:none!important;animation:none!important}
@page{margin:.5cm;size:auto}
}


/* ── Tap to Interact ── */
.clarify-sentence{cursor:pointer;transition:color .2s ease;border-radius:2px}
.clarify-sentence:hover{color:var(--accent)}
.clarify-sentence.tapped{color:var(--accent);opacity:.85}
.tap-inline{display:inline;font-family:'Fraunces',var(--display),serif;font-size:inherit;line-height:inherit;color:var(--accent);background:transparent;border:none;border-bottom:1px solid rgba(214,178,109,.25);outline:none;padding:0 0 1px;margin:0 2px;min-width:60px;caret-color:var(--accent);font-style:italic}
.tap-inline::placeholder{color:rgba(214,178,109,.2);font-style:italic}
.tap-response{display:block;margin:.5rem 0 .3rem;padding:.7rem 1.1rem;background:rgba(214,178,109,.06);border-left:2px solid rgba(214,178,109,.3);border-radius:0 10px 10px 0;animation:tap-resp-in .4s ease forwards;opacity:0}
@keyframes tap-resp-in{to{opacity:1}}
.tap-response-yours{display:block;font-size:.88rem;color:var(--accent);font-style:italic;margin-bottom:.4rem;line-height:1.5;font-weight:400}
.tap-response-text{display:block;font-size:.92rem;color:var(--ink);line-height:1.6;opacity:.85}
.tap-response-saved{display:block;font-size:.62rem;letter-spacing:.12rem;text-transform:uppercase;color:var(--accent-2);opacity:.4;margin-top:.35rem}
.tap-loading{display:inline;font-style:italic;color:var(--accent);opacity:.3;font-size:inherit}

@media(max-width:700px){main{padding:0 7vw 6rem}.hero{padding-top:4rem}.hero-visual{order:-1}.demo{padding:1.8rem}.cta-block{padding:2rem}.footer{flex-direction:column;gap:1rem;align-items:flex-start}.guide-item::after{display:none}.growing-viewer{padding:1.8rem 1.4rem;margin-left:-1rem;margin-right:-1rem;width:calc(100% + 2rem)}.session-card{padding:1.8rem}.gi-arc-text{font-size:1.3rem}.gi-unsaid-text{font-size:1.25rem}.gi-becoming-text{font-size:1.15rem}.gi-icon{width:30px;height:30px;font-size:.9rem}.gi-reflection-question{font-size:1.1rem}.gi-reflection-input{font-size:1rem}.takeaway-card{border-radius:18px;max-width:100%}.tk-map-title-text{font-size:1.7rem}.tk-reading{padding:.8rem 1.4rem 1rem}.tk-reading-text{font-size:1.2rem}.tk-tensions,.tk-guide{padding-left:1.2rem;padding-right:1.2rem}.tk-guide-grid{grid-template-columns:1fr}.tk-gravity,.tk-arc,.tk-mirror,.tk-annot,.tk-noticing{padding-left:1.4rem;padding-right:1.4rem}.tk-contra{padding-left:1rem;padding-right:1rem}.tk-contra-row{flex-direction:column;gap:.3rem}.tk-contra-vs{writing-mode:horizontal-tb;text-align:center}.tk-contra-left,.tk-contra-right{text-align:left}.tk-unsaid-text{font-size:1.3rem}.tk-becoming-text{font-size:1.15rem}.tk-div{margin-left:1.4rem;margin-right:1.4rem}.tk-footer{padding-left:1.4rem;padding-right:1.4rem}}
/* === INSIGHT DRAWER === */
.conn-insight{position:absolute;transform:translate(-50%,8px);padding:0;border-radius:16px;background:rgba(10,13,17,.94);border:1px solid rgba(125,183,174,.2);backdrop-filter:blur(16px);z-index:6;width:260px;max-width:85vw;opacity:0;pointer-events:auto;overflow:hidden;animation:drawer-in .4s cubic-bezier(.25,.46,.45,.94) forwards;cursor:grab;touch-action:none}
.conn-insight.dragging{cursor:grabbing;transform:none;box-shadow:0 8px 32px rgba(0,0,0,.5)}
@keyframes drawer-in{from{opacity:0;transform:translate(-50%,2px);max-height:0}to{opacity:1;transform:translate(-50%,10px);max-height:320px}}
.conn-insight-inner{padding:1.1rem 1.2rem}
.conn-insight-text{font-size:.95rem;color:var(--ink);line-height:1.6;font-style:italic;margin-bottom:1rem}
.conn-insight-ask{font-size:.85rem;text-transform:uppercase;letter-spacing:.15rem;color:var(--ink-soft);margin-bottom:.65rem;font-weight:500}
.resonance-row{display:flex;gap:.45rem}
.resonance-btn{flex:1;padding:.55rem .4rem;border-radius:10px;border:1px solid rgba(244,241,234,.1);background:rgba(244,241,234,.03);color:var(--ink-soft);font-family:var(--mono);font-size:.85rem;cursor:pointer;transition:all .25s ease;text-align:center;line-height:1.3}
.resonance-btn:hover{border-color:rgba(214,178,109,.3);background:rgba(214,178,109,.06);color:var(--ink)}
.resonance-btn.selected{border-color:rgba(125,183,174,.5);background:rgba(125,183,174,.12);color:var(--accent-2)}
.resonance-btn .res-icon{font-size:.9rem;display:block;margin-bottom:.2rem}
.resonance-thanked{text-align:center;padding:.6rem;font-size:.85rem;color:var(--accent-2);font-style:italic;opacity:0;animation:thanked-in .5s ease forwards}
@keyframes thanked-in{from{opacity:0;transform:translateY(4px)}to{opacity:1;transform:translateY(0)}}

/* Correction capture input */
.resonance-correction{margin-top:.7rem;opacity:0;animation:thanked-in .4s ease forwards}
.resonance-correction-label{font-size:.85rem;color:var(--ink-soft);font-style:italic;margin-bottom:.45rem;line-height:1.4}
.resonance-correction-input{width:100%;background:rgba(14,17,21,.6);border:1px solid rgba(244,241,234,.12);border-radius:10px;color:var(--ink);padding:.6rem .8rem;font-family:var(--mono);font-size:.88rem;transition:border-color .2s ease;resize:none;line-height:1.5}
.resonance-correction-input:focus{outline:none;border-color:rgba(196,110,95,.4)}
.resonance-correction-input::placeholder{color:rgba(244,241,234,.2)}
.resonance-correction-hint{font-size:.85rem;color:var(--ink-soft);opacity:.4;margin-top:.35rem;letter-spacing:.04rem}
.conn-insight-close{position:absolute;top:.6rem;right:.7rem;width:22px;height:22px;border-radius:50%;border:none;background:rgba(244,241,234,.06);color:var(--ink-soft);font-size:.7rem;cursor:pointer;display:grid;place-items:center;transition:all .2s ease;line-height:1}
.conn-insight-close:hover{background:rgba(244,241,234,.12);color:var(--ink)}

/* === INTERACTIVE GUIDE ITEMS === */
.guide-item{cursor:pointer;position:relative}
.guide-item::after{content:"tap to respond";position:absolute;right:1rem;top:50%;transform:translateY(-50%);font-size:.6rem;text-transform:uppercase;letter-spacing:.12rem;color:rgba(244,241,234,.12);transition:all .3s ease;pointer-events:none}
.guide-item:hover::after{color:rgba(244,241,234,.25)}
.guide-item.has-response::after{content:"";display:none}
.guide-item.yours::after{display:none}
.guide-item.expanded{cursor:default}
.guide-item.expanded::after{display:none}

.guide-response-area{overflow:hidden;max-height:0;opacity:0;transition:all .4s cubic-bezier(.25,.46,.45,.94);margin-top:0}
.guide-item.expanded .guide-response-area{max-height:200px;opacity:1;margin-top:.85rem}

.guide-response-prompt{font-size:.92rem;color:var(--ink-soft);margin-bottom:.5rem}
.guide-response-input{width:100%;background:rgba(14,17,21,.6);border:1px solid rgba(244,241,234,.1);border-radius:12px;color:var(--ink);padding:.7rem .9rem;font-family:var(--mono);font-size:.88rem;transition:border-color .2s ease;resize:none;line-height:1.5}
.guide-response-input:focus{outline:none;border-color:rgba(214,178,109,.4)}
.guide-response-input::placeholder{color:rgba(244,241,234,.2)}
.guide-response-saved{padding:.6rem .9rem;border-radius:12px;background:rgba(214,178,109,.05);border:1px solid rgba(214,178,109,.15);font-size:.9rem;color:var(--accent);line-height:1.55;font-style:italic}
.guide-response-meta{font-size:.88rem;text-transform:uppercase;letter-spacing:.12rem;color:var(--accent-2);margin-top:.4rem}
.guide-echo{margin-top:.7rem;padding-top:.7rem;border-top:1px solid rgba(244,241,234,.06);opacity:0;transition:opacity .6s ease}
.guide-echo.visible{opacity:1}
.guide-echo-loading{color:rgba(244,241,234,.2);font-size:1.1rem;letter-spacing:.3em;animation:echoPulse 1.5s ease-in-out infinite}
.guide-echo-text{font-family:'Fraunces',var(--display),serif;font-size:.92rem;color:rgba(125,183,174,.7);line-height:1.6;font-style:italic}
.guide-echo-symbol{font-size:.68rem;letter-spacing:.08em;text-transform:uppercase;font-family:'Space Grotesk',sans-serif;font-weight:600;margin-bottom:.3rem;display:flex;align-items:center;gap:.3rem}
@keyframes echoPulse{0%,100%{opacity:.3}50%{opacity:.8}}
.synth-evolving{color:rgba(125,183,174,.4);animation:echoPulse 1.5s ease-in-out infinite}

/* Guide item types — subtle prompt colors */
.guide-item.type-deepen{border-color:rgba(159,178,216,.15)}
.guide-item.type-deepen:hover{border-color:rgba(159,178,216,.25)}
.guide-item.type-do{border-color:rgba(94,211,192,.15)}.guide-item.type-do:hover{border-color:rgba(94,211,192,.25)}
.guide-item.type-notice{border-color:rgba(154,208,255,.15)}.guide-item.type-notice:hover{border-color:rgba(154,208,255,.25)}
.guide-item.type-ask{border-color:rgba(244,196,109,.15)}.guide-item.type-ask:hover{border-color:rgba(244,196,109,.25)}
.guide-item.type-release{border-color:rgba(240,139,115,.15)}.guide-item.type-release:hover{border-color:rgba(240,139,115,.25)}

/* Growing tile responses (used in print card context) */
.growing-tile-response{font-family:var(--display);font-size:.85rem;color:var(--ink-soft);font-style:italic;padding-top:.55rem;border-top:1px solid rgba(244,241,234,.04);margin-top:.55rem;line-height:1.55}

/* === DRAG HINT === */
.map-drag-hint{position:absolute;bottom:14px;left:0;right:0;text-align:center;font-size:.7rem;color:var(--ink-soft);letter-spacing:.08rem;opacity:0;z-index:5;pointer-events:none;transition:opacity .6s ease}
.map-drag-hint.visible{animation:hint-pulse 4s ease forwards}
@keyframes hint-pulse{0%{opacity:0}15%{opacity:.55}85%{opacity:.55}100%{opacity:0}}

/* === MAP ZONE INDICATORS (subtle quadrant feel) === */
.map-zone-label{position:absolute;font-size:.55rem;text-transform:uppercase;letter-spacing:.18rem;color:rgba(244,241,234,.08);pointer-events:none;z-index:0;font-family:var(--mono);transition:opacity .8s ease}
.demo-field.has-zones .map-zone-label{opacity:1}

/* Becoming strip — anchored to bottom of map */
.map-becoming{position:absolute;bottom:0;left:0;right:0;padding:3.5rem 2.5rem 2rem;background:linear-gradient(180deg,transparent,rgba(11,13,15,.8) 40%,rgba(11,13,15,.95));z-index:4;pointer-events:none;text-align:center;opacity:0;animation:becoming-in .8s ease .3s forwards}
@keyframes becoming-in{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:translateY(0)}}
.map-becoming-label{font-family:'DM Sans',sans-serif;font-size:.85rem;font-weight:600;text-transform:uppercase;letter-spacing:.18rem;color:var(--accent);margin-bottom:.6rem}
.map-becoming-text{font-family:'Fraunces',var(--display),serif;font-size:1.1rem;color:rgba(244,241,234,.82);line-height:1.65;font-weight:300;max-width:520px;margin:0 auto}

/* ═══ CONNECTION VISUAL STATES ═══ */
.conn-label.unexplored{animation:label-in .5s .3s ease forwards,connGlow 3s ease-in-out 1.5s infinite}
@keyframes connGlow{0%,100%{box-shadow:0 0 0 rgba(125,183,174,0),0 0 0 rgba(125,183,174,0)}50%{box-shadow:0 0 14px rgba(125,183,174,.2),0 0 28px rgba(125,183,174,.06)}}
.conn-label.explored{animation:none;opacity:1}
.conn-label.confirmed{background:rgba(125,183,174,.2);border-color:rgba(125,183,174,.5);color:var(--accent-2);opacity:1;box-shadow:0 0 8px rgba(125,183,174,.1);transition:all .6s ease}
.conn-label.corrected{background:rgba(165,235,220,.1);border-color:rgba(165,235,220,.4);color:rgba(165,235,220,.9);font-style:italic;opacity:1;box-shadow:0 0 8px rgba(165,235,220,.08);text-transform:none;letter-spacing:.02em;font-family:'Fraunces',serif;font-size:.82rem;transition:all .6s ease}
.conn-label.rejected{opacity:.15;border-color:rgba(125,183,174,.06);background:rgba(125,183,174,.02);box-shadow:none;pointer-events:none;transition:all 1s ease}
.conn-line.c-confirmed{stroke:rgba(125,183,174,.6)!important;stroke-width:2.5!important;opacity:1!important;stroke-dasharray:none!important;transition:all .6s ease}
.conn-line.c-rejected{stroke:rgba(125,183,174,.08)!important;stroke-width:.4!important;opacity:.2!important;stroke-dasharray:8 8!important;transition:all 1s ease}
.conn-line.c-corrected{stroke:rgba(165,235,220,.45)!important;stroke-width:2!important;opacity:1!important;transition:all .6s ease}
.conn-line.c-pulse{animation:cPulse 1.1s ease}
@keyframes cPulse{0%{stroke-width:1.5;filter:none}30%{stroke-width:4;filter:drop-shadow(0 0 12px rgba(125,183,174,.6))}100%{stroke-width:2.5;filter:none}}
/* ── Structural shift — whole field breathes after each interaction ── */
.demo-field.sv-shift{animation:fieldShift .5s ease}
@keyframes fieldShift{0%{filter:brightness(1)}25%{filter:brightness(1.04) saturate(1.1)}100%{filter:brightness(1)}}
/* ── Field expansion — breathes outward when map grows ── */
.demo-field.sv-expand{animation:fieldExpand 1.2s cubic-bezier(.25,.46,.45,.94)}
@keyframes fieldExpand{0%{filter:brightness(1);box-shadow:inset 0 0 0 rgba(125,183,174,0)}30%{filter:brightness(1.03) saturate(1.08);box-shadow:inset 0 0 60px rgba(125,183,174,.06)}100%{filter:brightness(1);box-shadow:inset 0 0 0 rgba(125,183,174,0)}}
/* ── Node glow when involved in an interaction ── */
.map-node.sv-glow{animation:nodeGlow .8s ease}
@keyframes nodeGlow{0%{box-shadow:var(--node-shadow,none)}30%{box-shadow:0 0 20px rgba(125,183,174,.25)}100%{box-shadow:var(--node-shadow,none)}}
/* ── Map breathing — nodes drift subtly, map feels alive ── */
.map-node.ai-placed{animation:nodeBreathe 8s ease-in-out infinite}
.map-node.ai-placed:nth-child(2n){animation-delay:-2.5s;animation-duration:9s}
.map-node.ai-placed:nth-child(3n){animation-delay:-5s;animation-duration:7s}
.map-node.user-added{animation:user-node-in .5s cubic-bezier(.25,.46,.45,.94) forwards,nodeBreathe 10s ease-in-out 1s infinite}
@keyframes nodeBreathe{0%,100%{transform:translate(0,0)}25%{transform:translate(1.5px,-1px)}50%{transform:translate(-1px,1.5px)}75%{transform:translate(1px,0.5px)}}
.map-node.dragging{animation:none!important}
.conn-line{animation:lineBreathe 6s ease-in-out infinite}
.conn-line:nth-child(2n){animation-delay:-3s}
@keyframes lineBreathe{0%,100%{opacity:.7}50%{opacity:.85}}
/* ── Sidebar mid-session reflection ── */
.sv-mid-reflect{font-family:'Fraunces',serif;font-size:.88rem;color:rgba(214,178,109,.5);font-style:italic;padding-top:.5rem;border-top:1px solid rgba(244,241,234,.03);margin-top:.5rem;opacity:0;animation:svFadeUp .8s ease .3s forwards}
/* ── Discovery prompt ── */
.sv-discovery{font-family:var(--mono);font-size:.72rem;color:rgba(125,183,174,.3);letter-spacing:.04em;padding-top:.4rem;opacity:0;animation:svFadeUp 1.2s ease 1s forwards}
/* ═══ SIDEBAR VOICE — minimal guidance ═══ */
#sv-guide{padding:.3rem 0}
.sv-whisper{font-family:'Fraunces',serif;font-size:1.05rem;color:var(--ink-mid);line-height:1.6;font-weight:300;opacity:0;animation:svFadeUp .6s ease forwards}
@keyframes svFadeUp{from{opacity:0;transform:translateY(5px)}to{opacity:1;transform:translateY(0)}}
.sv-count{font-family:var(--mono);font-size:.72rem;letter-spacing:.1em;color:rgba(214,178,109,.35);margin-bottom:.3rem;opacity:0;animation:svFadeUp .4s ease forwards}
.sv-add-input{width:100%;background:rgba(0,0,0,.12);border:1px solid rgba(244,241,234,.08);border-radius:999px;color:var(--ink);font-family:'Fraunces',serif;font-size:.92rem;padding:.5rem 1rem;outline:none;transition:border-color .2s;margin-top:.5rem}
.sv-add-input:focus{border-color:rgba(125,183,174,.3)}
.sv-add-input::placeholder{color:rgba(244,241,234,.15)}
.sv-added{font-family:'Fraunces',serif;font-size:.92rem;color:rgba(165,235,220,.6);font-style:italic;padding:.2rem 0;opacity:0;animation:svFadeUp .5s ease forwards}
.sv-noticing{font-family:var(--mono);font-size:.78rem;color:var(--ink-soft);line-height:1.5;padding-top:.7rem;border-top:1px solid rgba(244,241,234,.04);margin-top:.8rem;opacity:0;animation:svFadeUp 1s ease .5s forwards}
.sv-done-btn{background:none;border:1px solid rgba(244,241,234,.1);border-radius:999px;color:var(--ink-soft);font-family:var(--mono);font-size:.78rem;padding:.5rem 1.1rem;cursor:pointer;transition:all .25s;letter-spacing:.02em;margin-top:.7rem;display:block;width:100%;text-align:center}
.sv-done-btn:hover{border-color:rgba(125,183,174,.3);color:var(--accent-2);background:rgba(125,183,174,.04)}
.sv-done-btn.sv-synth{border-color:rgba(214,178,109,.3);color:var(--accent);background:rgba(214,178,109,.06)}
.sv-done-btn.sv-synth:hover{border-color:rgba(214,178,109,.5);background:rgba(214,178,109,.12)}
.sv-done-btn.sv-run{border-color:rgba(125,183,174,.3);color:var(--accent-2)}
.sv-resynth{font-family:'Fraunces',serif;font-size:1rem;color:var(--ink-soft);text-align:center;padding:1.2rem 0;opacity:0;animation:svFadeUp .8s ease forwards}

/* ── Connection annotations — user's words near the connection ── */
.conn-annotation{position:absolute;padding:.25rem .7rem;border-radius:12px;font-family:'Fraunces',serif;font-size:.78rem;font-style:italic;color:rgba(196,110,95,.7);background:rgba(196,110,95,.06);border:1px solid rgba(196,110,95,.15);z-index:5;white-space:nowrap;max-width:200px;overflow:hidden;text-overflow:ellipsis;opacity:0;animation:annotIn .6s ease .2s forwards;pointer-events:none}
@keyframes annotIn{from{opacity:0;transform:translate(-50%,4px)}to{opacity:1;transform:translate(-50%,0)}}

/* ── Map depth — heavier nodes larger/brighter, lighter ones smaller/quieter ── */
.map-node.weight-1{opacity:.6;font-size:.8rem}
.map-node.weight-2{opacity:.75;font-size:.85rem}
.map-node.weight-3{opacity:.85;font-size:.88rem}
.map-node.weight-4{opacity:.95;font-size:.92rem;border-color:rgba(214,178,109,.4)}
.map-node.weight-5{opacity:1;font-size:.95rem;border-color:rgba(214,178,109,.6);box-shadow:0 0 24px rgba(214,178,109,.15)}

/* ── Synthesis morphing animation ── */
.demo-field.sv-morphing{animation:fieldMorph 2.5s ease-in-out}
@keyframes fieldMorph{0%{filter:brightness(1)}15%{filter:brightness(.95) saturate(1.15)}50%{filter:brightness(1.06) saturate(1.1)}85%{filter:brightness(1.02)}100%{filter:brightness(1)}}
.map-node.sv-reweighting{transition:all 1.2s cubic-bezier(.25,.46,.45,.94)!important}
.conn-line.sv-reweighting{transition:all 1.2s ease!important}

/* ===== WORKSPACE MODE (body.workspace) ===== */
.ws-nav{display:none;justify-content:space-between;align-items:center;padding:.8rem 1.8rem;border-bottom:1px solid rgba(244,241,234,.06);background:rgba(11,13,15,.95);backdrop-filter:blur(16px);z-index:10;position:fixed;top:0;left:0;right:0}
.ws-nav .logo{font-family:var(--display);font-size:1.2rem;letter-spacing:.2rem;cursor:pointer}
.ws-nav-right{display:flex;gap:.8rem;align-items:center}
.ws-nav-link{font-size:.85rem;color:var(--ink-soft);cursor:pointer;transition:color .2s}
.ws-nav-link:hover{color:var(--ink)}

body.workspace{overflow:hidden;height:100vh}
body.workspace .nav{display:none}
body.workspace .ws-nav{display:flex}
body.workspace .hero,
body.workspace .story,
body.workspace .system,
body.workspace .cta-block,
body.workspace .footer{display:none!important}
body.workspace .ambient .orb{opacity:.3}

body.workspace main{padding:0;display:grid;grid-template-columns:minmax(360px,480px) 1fr;height:calc(100vh - 49px);margin-top:49px;overflow:hidden}

body.workspace .demo{margin:0;border-radius:0;border:none;padding:0;box-shadow:none;display:flex!important;flex-direction:column;gap:0;background:transparent;overflow:hidden}
body.workspace .demo-copy{overflow-y:auto;padding:1.6rem 1.6rem 4rem;scrollbar-width:thin;scrollbar-color:rgba(244,241,234,.08) transparent;flex:1;min-height:0}
body.workspace .demo-copy::-webkit-scrollbar{width:5px}
body.workspace .demo-copy::-webkit-scrollbar-thumb{background:rgba(244,241,234,.08);border-radius:3px}
body.workspace .demo-copy h2{font-size:1.8rem;margin-bottom:.8rem}
body.workspace .demo-copy .eyebrow{display:none}
body.workspace .demo-copy>p:first-of-type{display:none}

body.workspace .demo-field{position:fixed!important;top:49px;right:0;bottom:0;left:480px;min-height:0!important;height:auto!important;border-radius:0!important;border:none!important;border-left:1px solid rgba(244,241,234,.04)!important}

@media(max-width:900px){
  body.workspace main{grid-template-columns:1fr;grid-template-rows:1fr 45vh;height:calc(100vh - 49px)}
  body.workspace .demo-field{position:relative!important;left:0!important;top:0!important;border-left:none!important;border-top:1px solid rgba(244,241,234,.04)!important;grid-row:2}
  body.workspace .demo{grid-row:1}
}
@media(max-width:600px){
  body.workspace main{grid-template-rows:1fr 40vh}
  body.workspace .demo-copy{padding:1.4rem 1.2rem 3rem}
}

@media(prefers-reduced-motion:reduce){.orb,.pulse,.field-glow{animation:none}}
    </style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    /* ═══ Auth UI ═══ */
    .auth-overlay{position:fixed;inset:0;z-index:99999;display:flex;align-items:center;justify-content:center;background:#060910;padding:1.5rem}
    .auth-card{width:100%;max-width:380px;text-align:center}
    .auth-logo{font-family:'Space Grotesk',sans-serif;font-size:2.4rem;letter-spacing:.5em;color:rgba(244,196,109,.8);text-transform:uppercase;font-weight:700;text-indent:.5em;margin-bottom:.5rem}
    .auth-sub{font-family:'Fraunces',serif;font-size:1rem;color:rgba(247,241,231,.35);margin-bottom:2.5rem;font-weight:300}
    .auth-input{display:block;width:100%;background:rgba(14,17,21,.8);border:1px solid rgba(244,241,234,.1);border-radius:12px;color:rgba(247,241,231,.9);padding:.8rem 1rem;font-family:'Space Grotesk',sans-serif;font-size:.95rem;margin-bottom:.8rem;outline:none;transition:border-color .2s;box-sizing:border-box}
    .auth-input:focus{border-color:rgba(214,178,109,.4)}
    .auth-input::placeholder{color:rgba(244,241,234,.2)}
    .auth-btn{width:100%;padding:.8rem;border-radius:12px;border:1px solid rgba(214,178,109,.4);background:rgba(214,178,109,.08);color:var(--accent,rgba(244,196,109,.9));font-family:'Space Grotesk',sans-serif;font-size:.95rem;font-weight:600;letter-spacing:.08em;cursor:pointer;transition:all .2s;margin-top:.4rem}
    .auth-btn:hover{background:rgba(214,178,109,.15);border-color:rgba(214,178,109,.6)}
    .auth-btn:disabled{opacity:.4;cursor:not-allowed}
    .auth-toggle{margin-top:1.5rem;font-size:.85rem;color:rgba(247,241,231,.3)}
    .auth-toggle a{color:rgba(214,178,109,.6);cursor:pointer;text-decoration:none}
    .auth-toggle a:hover{color:rgba(214,178,109,.9)}
    .auth-error{color:rgba(196,110,95,.8);font-size:.82rem;margin-top:.6rem;min-height:1.2em}
    .auth-divider{display:flex;align-items:center;gap:1rem;margin:1.2rem 0;color:rgba(247,241,231,.15);font-size:.75rem;letter-spacing:.1em;text-transform:uppercase}
    .auth-divider::before,.auth-divider::after{content:"";flex:1;height:1px;background:rgba(244,241,234,.06)}
    .auth-social{width:100%;padding:.7rem;border-radius:12px;border:1px solid rgba(244,241,234,.08);background:transparent;color:rgba(247,241,231,.5);font-family:'Space Grotesk',sans-serif;font-size:.88rem;cursor:pointer;transition:all .2s;display:flex;align-items:center;justify-content:center;gap:.5rem}
    .auth-social:hover{border-color:rgba(244,241,234,.2);color:rgba(247,241,231,.7)}
    .auth-forgot{display:block;text-align:right;font-size:.78rem;color:rgba(214,178,109,.35);cursor:pointer;margin-top:-.3rem;margin-bottom:.5rem}
    .auth-forgot:hover{color:rgba(214,178,109,.6)}
    .auth-hidden{display:none!important}
    .ws-user{font-size:.72rem;color:rgba(247,241,231,.25);cursor:pointer;letter-spacing:.04em}
    .ws-user:hover{color:rgba(247,241,231,.45)}
  </style>
  </head>
  <body>
    <!-- ═══ Auth Overlay ═══ -->
    <div class="auth-overlay" id="auth-overlay">
      <div class="auth-card">
        <div class="auth-logo">SAYCRD</div>
        <div class="auth-sub">clarity, not control</div>

        <!-- Login form -->
        <div id="auth-login">
          <input class="auth-input" type="text" id="auth-email" placeholder="Email" autocomplete="email" />
          <input class="auth-input" type="password" id="auth-password" placeholder="Password" autocomplete="current-password" />
          <span class="auth-forgot" id="auth-forgot" onclick="document.getElementById('auth-login').style.display='none';document.getElementById('auth-reset').style.display='block';">Forgot password?</span>
          <button class="auth-btn" id="auth-login-btn" onclick="
            (async function(){
              var btn=document.getElementById('auth-login-btn');btn.disabled=true;
              var err=document.getElementById('auth-error');err.textContent='';err.style.color='';
              var em=document.getElementById('auth-email').value.trim();
              var pw=document.getElementById('auth-password').value;
              if(!em||!pw){err.textContent='Enter email and password';btn.disabled=false;return;}
              if(em==='local'&&pw==='local'){window._localBypass();return;}
              try{
                var sb=window.sbClient;if(!sb||!sb.auth){err.textContent='Database connecting... try again or use Continue without account';btn.disabled=false;return;}
                var r=await sb.auth.signInWithPassword({email:em,password:pw});
                if(r.error){
                  var msg=r.error.message||'Login failed';
                  if(msg.toLowerCase().indexOf('email not confirmed')!==-1){
                    msg='Check your email for a confirmation link, then try again.';
                    err.style.color='rgba(244,196,109,.7)';
                  } else if(msg.toLowerCase().indexOf('invalid')!==-1){
                    msg='Wrong email or password. Try again or reset below.';
                  }
                  err.textContent=msg;btn.disabled=false;return;
                }
                currentUser=r.data.user;window.currentUser=currentUser;
                sb.auth.getSession().then(function(s){if(s.data.session)window._saycrdToken=s.data.session.access_token;});
                var o=document.getElementById('auth-overlay');o.style.opacity='0';o.style.transition='opacity .4s';setTimeout(function(){o.style.display='none';},400);
                var sn=document.getElementById('ws-signout');if(sn&&r.data.user.email)sn.textContent=r.data.user.email.split('@')[0]+' \u00B7 sign out';
              }catch(e){err.textContent=e.message||'Login failed';btn.disabled=false;}
            })();
          ">Enter</button>
          <div class="auth-error" id="auth-error"></div>
          <div class="auth-divider">or</div>
          <button class="auth-social" id="auth-google" onclick="
            var sb=window.sbClient;if(sb&&sb.auth)sb.auth.signInWithOAuth({provider:'google',options:{redirectTo:window.location.origin}});
          ">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z"/><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
            Continue with Google
          </button>
          <div class="auth-toggle">No account? <a id="auth-show-signup" onclick="document.getElementById('auth-login').style.display='none';document.getElementById('auth-signup').style.display='block';" style="cursor:pointer">Create one</a></div>
        </div>

        <!-- Signup form -->
        <div id="auth-signup" style="display:none">
          <input class="auth-input" type="email" id="auth-signup-email" placeholder="Email" autocomplete="email" />
          <input class="auth-input" type="password" id="auth-signup-password" placeholder="Password (min 6 chars)" autocomplete="new-password" />
          <button class="auth-btn" id="auth-signup-btn" onclick="
            (async function(){
              var btn=document.getElementById('auth-signup-btn');btn.disabled=true;
              var err=document.getElementById('auth-signup-error');err.textContent='';err.style.color='';
              var em=document.getElementById('auth-signup-email').value.trim();
              var pw=document.getElementById('auth-signup-password').value;
              if(!em||!pw){err.textContent='Enter email and password';btn.disabled=false;return;}
              if(pw.length<6){err.textContent='Password must be at least 6 characters';btn.disabled=false;return;}
              try{
                var sb=window.sbClient;if(!sb||!sb.auth){err.textContent='Database connecting... try Continue without account below';btn.disabled=false;return;}
                var r=await sb.auth.signUp({email:em,password:pw});
                if(r.error){
                  var msg=r.error.message||'Signup failed';
                  if(msg.toLowerCase().indexOf('already registered')!==-1){
                    msg='This email is already registered. Try signing in instead.';
                    err.style.color='rgba(244,196,109,.7)';
                  }
                  err.textContent=msg;btn.disabled=false;return;
                }
                /* Check if email confirmation is required */
                if(r.data.user&&!r.data.user.confirmed_at&&!r.data.session){
                  err.style.color='rgba(125,183,174,.7)';err.textContent='Check your email for a confirmation link, then come back and sign in.';btn.disabled=false;return;
                }
                /* Auto-confirm is on — user is logged in */
                currentUser=r.data.user;window.currentUser=currentUser;
                sb.auth.getSession().then(function(s){if(s.data.session)window._saycrdToken=s.data.session.access_token;});
                var o=document.getElementById('auth-overlay');o.style.opacity='0';o.style.transition='opacity .4s';setTimeout(function(){o.style.display='none';},400);
                var sn=document.getElementById('ws-signout');if(sn&&r.data.user.email)sn.textContent=r.data.user.email.split('@')[0]+' \u00B7 sign out';
              }catch(e){err.textContent=e.message||'Signup failed';btn.disabled=false;}
            })();
          ">Begin</button>
          <div class="auth-error" id="auth-signup-error"></div>
          <div class="auth-toggle">Already have an account? <a id="auth-show-login" onclick="document.getElementById('auth-signup').style.display='none';document.getElementById('auth-login').style.display='block';" style="cursor:pointer">Sign in</a></div>
        </div>

        <!-- Reset form -->
        <div id="auth-reset" style="display:none">
          <input class="auth-input" type="email" id="auth-reset-email" placeholder="Email" autocomplete="email" />
          <button class="auth-btn" id="auth-reset-btn" onclick="
            (async function(){
              var btn=document.getElementById('auth-reset-btn');btn.disabled=true;
              var err=document.getElementById('auth-reset-error');err.textContent='';
              var em=document.getElementById('auth-reset-email').value.trim();
              if(!em){err.textContent='Enter your email';btn.disabled=false;return;}
              try{
                var sb=window.sbClient;if(!sb||!sb.auth){err.textContent='Database offline';btn.disabled=false;return;}
                var r=await sb.auth.resetPasswordForEmail(em,{redirectTo:window.location.origin});
                if(r.error){err.textContent=r.error.message;btn.disabled=false;return;}
                err.style.color='rgba(125,183,174,.7)';err.textContent='Reset link sent \u2014 check your email.';btn.disabled=false;
              }catch(e){err.textContent=e.message||'Reset failed';btn.disabled=false;}
            })();
          ">Send reset link</button>
          <div class="auth-error" id="auth-reset-error"></div>
          <div class="auth-toggle"><a id="auth-show-login-2" onclick="document.getElementById('auth-reset').style.display='none';document.getElementById('auth-login').style.display='block';" style="cursor:pointer">Back to sign in</a></div>
        </div>

        <!-- BYPASS — always visible, inline handler, cannot fail -->
        <div style="margin-top:1.8rem;padding-top:1.2rem;border-top:1px solid rgba(244,241,234,.06)">
          <button id="auth-local-bypass" style="width:100%;padding:.7rem;border-radius:12px;border:1px solid rgba(244,241,234,.06);background:transparent;color:rgba(247,241,231,.3);font-family:'Space Grotesk',sans-serif;font-size:.82rem;cursor:pointer;transition:all .2s" onclick="window._localBypass();">Continue without account</button>
        </div>
      </div>
    </div>
    <div class="ambient">
      <div class="orb orb-a"></div>
      <div class="orb orb-b"></div>
      <div class="orb orb-c"></div>
      <div class="grain"></div>
    </div>

    <header class="ws-nav" id="ws-nav">
      <div class="logo" onclick="switchView('home')">SAYCRD</div>
      <div class="ws-nav-right">
        <span class="ws-nav-link" id="ws-nav-growing">What&rsquo;s Growing</span>
        <span class="ws-nav-link" id="ws-nav-history">Your Sessions</span>
        <button class="cta ghost" style="padding:.45rem 1rem;font-size:.85rem" type="button" id="ws-new-session">New Session</button>
        <span class="ws-nav-link" id="ws-clear-history" style="font-size:.7rem;opacity:.3;cursor:pointer" title="Clear all session history">Clear history</span>
        <span class="ws-user" id="ws-signout">Sign out</span>
      </div>
    </header>

    <header class="nav">
      <div class="logo">SAYCRD</div>
      <nav class="nav-links">
        <a href="#experience">Experience</a>
        <a href="#demo">Session</a>
        <a href="#system">System</a>
      </nav>
      <button class="cta ghost" onclick="switchView('workspace')">Start a session</button>
    </header>

    <main>
      <section class="hero">
        <div class="hero-copy">
          <p class="eyebrow">A place to go in the moment</p>
          <h1>The space between your inner world and the next true move.</h1>
          <p class="lead">SAYCRD listens like a human, shapes what you say into a living visual, and remembers your patterns without turning you into a project.</p>
          <div class="hero-actions">
            <button class="cta" onclick="switchView('workspace')">Start a session</button>
            <button class="cta ghost" onclick="document.getElementById('experience').scrollIntoView({behavior:'smooth'})">See the concept</button>
          </div>
          <div class="micro-proof">
            <div><span>Phase 1</span><small>Dump freely</small></div>
            <div><span>Phase 2</span><small>Synthesize meaning</small></div>
            <div><span>Phase 3</span><small>Guidance that fits</small></div>
          </div>
        </div>
        <div class="hero-visual" id="hero-visual">
          <div class="field">
            <div class="field-center"><div class="pulse"></div></div>
            <div class="presence p1">What matters</div>
            <div class="presence p2">The pull</div>
            <div class="presence p3">Quiet Hope</div>
            <div class="presence p4">Rest</div>
            <svg class="veins" viewBox="0 0 600 400" aria-hidden="true">
              <path d="M40,240 C120,200 140,160 220,170 C300,180 310,240 380,260 C450,280 510,210 560,160"/>
              <path d="M90,310 C160,280 210,330 280,300 C350,270 380,320 450,330"/>
            </svg>
          </div>
          <div class="caption">A living field that shows meaning, not raw words.</div>
        </div>
      </section>

      <section class="story" id="experience">
        <div class="story-grid">
          <div><h2>The gap in the world</h2><p>There is a moment when you are scattered and nothing feels clear. Journals are blank pages. To-do apps are laughable. Friends are tired. SAYCRD is the place you go in that moment.</p></div>
          <div><h2>The loop closes</h2><p>Internal becomes external, in real time. Seeing the map changes how you relate to it. That shift is the mechanism. It is not productivity. It is clarity.</p></div>
          <div><h2>The system remembers</h2><p>The map stays with you. It recognizes patterns across sessions without feeling like surveillance. You build a living map of your inner life.</p></div>
        </div>
      </section>

      <!-- ===== THE SESSION ===== -->
      <section class="demo" id="demo">
        <div class="demo-copy">
          <p class="eyebrow">First session</p>
          <h2>Three phases, one thread</h2>
          <p>Dump everything. The AI finds the meaning. Then it guides you.</p>
          <button type="button" id="btn-preview-growing" style="background:none;border:none;color:var(--accent-2);font-family:var(--mono);font-size:.85rem;cursor:pointer;padding:.4rem 0;opacity:.45;transition:opacity .2s;letter-spacing:.03rem">Preview What&rsquo;s Growing &rarr;</button>

          <div class="phase-tabs" role="tablist">
            <button class="phase-tab is-active" data-phase="1" type="button">1 &thinsp;Dump</button>
            <button class="phase-tab is-locked" data-phase="2" type="button">2 &thinsp;Synthesize</button>
            <button class="phase-tab is-locked" data-phase="3" type="button">3 &thinsp;Session</button>
            <button class="phase-tab is-locked" data-phase="4" type="button">✦ &thinsp;Growing</button>
          </div>

          <!-- Phase 1: Dump -->
          <div class="phase-panel is-active" data-panel="1">
            <div class="session-counter" id="session-counter" style="display:none;font-family:var(--mono);font-size:.78rem;color:rgba(214,178,109,.45);letter-spacing:.12em;text-transform:uppercase;margin-bottom:.6rem;text-align:center"></div>
            <div class="ai-reply" id="ai-reply">&ldquo;I&rsquo;m here. Say what&rsquo;s real.&rdquo;</div>
            <textarea id="session-input" placeholder="Just start writing. Whatever is on your mind. Don't filter, don't organize. The map is listening..." rows="8"></textarea>
            <div class="helper" id="dump-helper">Keep going. The map is listening.</div>
            <div class="demo-actions">
              <button class="cta" id="btn-synthesize" disabled>Synthesize</button>
              <button class="cta ghost" id="btn-reset">Reset</button>
            </div>
          </div>

          <!-- Phase 2: Synthesize — map + connection analysis -->
          <div class="phase-panel" data-panel="2">
            <div id="synthesis-content">
              <div class="loading-state" id="synthesis-loading">
                <div class="loading-text" style="font-family:'Fraunces',serif;font-size:1rem;opacity:.4"></div>
              </div>
            </div>
            <!-- Sidebar voice — one whisper at a time -->
            <div id="sv-guide" style="display:none"></div>
            <div id="connection-analysis" style="display:none"></div>
            <div class="demo-actions" id="synthesis-actions" style="display:none">
              <button class="cta" id="btn-enter-session">Run Session</button>
              <button class="cta ghost" id="btn-back-dump">Back to Dump</button>
            </div>
          </div>

          <!-- Phase 3: Session — full session card with guides -->
          <div class="phase-panel" data-panel="3">
            <div class="session-card" id="session-card">
              <div class="session-card-header">
                <div class="session-card-date" id="session-date"></div>
                <div class="session-card-title">Your Session</div>
              </div>

              <div class="session-section">
                <div class="session-section-label">What surfaced</div>
                <div class="session-themes" id="session-themes"></div>
              </div>

              <div class="session-section">
                <div class="session-section-label">What this session revealed</div>
                <div class="session-synthesis" id="session-synthesis"></div>
              </div>

              <div class="session-section" id="session-conn-section" style="display:none">
                <div class="session-section-label">What you saw in the map</div>
                <div id="session-conn-responses"></div>
              </div>

              <div class="session-section" id="session-guide-section">
                <div class="session-section-label">Your guide</div>
                <div class="session-guide" id="session-guide"></div>
              </div>

              <!-- Lines they kept from the reading -->
              <div class="session-section" id="session-kept-section" style="display:none">
                <div class="session-section-label" style="color:var(--accent)">&hearts; Lines you kept</div>
                <div id="session-kept-lines" style="display:grid;gap:.6rem"></div>
              </div>

              <div class="session-section session-clarity-section">
                <div class="session-section-label">One thing you&rsquo;re taking with you</div>
                <input type="text" class="clarity-input" id="clarity-input" placeholder="Name it plainly..." maxlength="140" />
                <div class="clarity-saved" id="clarity-saved"></div>
              </div>

              <!-- AI Noticing: appears after clarity is saved -->
              <div class="session-section noticing-section" id="noticing-section" style="display:none">
                <div class="noticing-card" id="noticing-card">
                  <div class="noticing-icon">&#10070;</div>
                  <div class="noticing-text" id="noticing-text"></div>
                </div>
              </div>
            </div>
            <div class="demo-actions" id="session-actions">
              <button class="cta" id="btn-to-growing" style="border-color:rgba(125,183,174,.3);color:var(--accent-2);background:rgba(125,183,174,.06)">Continue to What&rsquo;s Growing &rarr;</button>
            </div>
          </div>

          <!-- Phase 4: Growing -->
          <div class="phase-panel" data-panel="4">
            <div class="growing-viewer" id="growing-viewer" style="display:none">
              <div class="growing-head">
                <div class="growing-title">What&rsquo;s growing</div>
                <div style="display:flex;gap:.5rem;align-items:center">
                  <button class="cta ghost" id="btn-growing-takeaway" type="button" style="padding:.4rem .9rem;font-size:.78rem;border-color:rgba(214,178,109,.2);color:var(--accent)">Your reading</button>
                  <button class="cta ghost" id="growing-back" type="button" style="padding:.4rem .9rem;font-size:.78rem">Back to session</button>
                </div>
              </div>
              <div class="growing-empty" id="growing-empty">Complete a session to begin. The system notices what you can&rsquo;t.<br><br><button type="button" id="btn-seed-demo" style="background:none;border:1px solid rgba(214,178,109,.2);color:var(--accent);padding:.5rem 1.2rem;border-radius:999px;font-family:var(--mono);font-size:.85rem;cursor:pointer">Load demo sessions to preview</button></div>
              <div class="growing-list" id="growing-list"></div>
              <div class="reading-gallery" id="reading-gallery" style="display:none"></div>
            </div>
            <div class="demo-actions" id="phase4-actions">
              <button class="cta ghost" type="button" id="btn-new-session">New session</button>
              <button class="cta ghost" id="btn-view-takeaway" type="button" style="border-color:rgba(214,178,109,.2);color:var(--accent)">Your reading</button>
            </div>
          </div>
        </div>

        <!-- Living Map -->
        <div class="demo-field" id="demo-field">
          <div class="field-glow"></div>
          <div class="field-grid"></div>
          <svg class="connections-svg" id="connections-svg"></svg>
          <div class="field-center"><div class="pulse" id="center-pulse"></div></div>
        </div>
      </section>

      <section class="system" id="system">
        <h2>What the system has to do</h2>
        <div class="pillars">
          <article><h3>AI that listens</h3><p>It hears what is underneath, collapses related themes, and keeps the map clean even when the dump is long.</p></article>
          <article><h3>Visual that is alive</h3><p>A living field that can hold vagueness, weight, proximity, and change over time.</p></article>
          <article><h3>Memory with care</h3><p>Patterns are remembered, not tracked. The system knows what to surface and what to leave alone.</p></article>
          <article><h3>Practice, not features</h3><p>A breath, a pause, a reflection — only when needed. The experience stays whole.</p></article>
        </div>
      </section>

      <section class="cta-block">
        <div><h2>Ready to listen to yourself?</h2><p>No account needed. Your session stays private. Just start.</p></div>
        <div class="cta-actions">
          <button class="cta" onclick="switchView('workspace')">Start a session</button>
        </div>
      </section>
    </main>

    <footer class="footer">
      <div><span>SAYCRD</span> <small>Clarity, not control.</small></div>
      <div><small>Prototype UI — February 2026</small></div>
    </footer>

    <script>
/* Global error handler — shows what's breaking */
window.onerror = function(msg, url, line, col, err) {
  console.error("SAYCRD ERROR:", msg, "line:", line);
  var errBox = document.getElementById("auth-error");
  if (errBox) errBox.textContent = "JS Error: " + msg + " (line " + line + ")";
};

/* ====================================================================
   SAYCRD — Configuration
   Replace these with your Supabase project values
   ==================================================================== */
const SAYCRD_CONFIG = {
  SUPABASE_URL: "https://perataksccqmdocgshyl.supabase.co",
  SUPABASE_ANON_KEY: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBlcmF0YWtzY2NxbWRvY2dzaHlsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA3NjU3MTEsImV4cCI6MjA4NjM0MTcxMX0.D_y3MF3UyRsyAPRpUWYw5x7fn5i9dCN8xnD5_n_-Nnc",
  API_ENDPOINT: "/api/claude",
};

/* ====================================================================
   Supabase Client + Auth
   ==================================================================== */
var sbClient = null;
window.sbClient = null;
var supabaseAvailable = false;
try {
  sbClient = window.supabase.createClient(
    SAYCRD_CONFIG.SUPABASE_URL,
    SAYCRD_CONFIG.SUPABASE_ANON_KEY
  );
  window.sbClient = sbClient;
  supabaseAvailable = true;
  console.log("Supabase client initialized");
} catch(sbInitErr) {
  console.warn("Supabase unavailable:", sbInitErr.message || sbInitErr);
}

var currentUser = null;
window.currentUser = null;

/* ── Storage Adapter (drop-in replacement for window.storage) ── */
/* Saves to Supabase if authenticated + available, otherwise localStorage */
function _storageMode() {
  if (currentUser && supabaseAvailable && currentUser.id !== "local-user") return "supabase";
  return "local";
}
function _localGet(key) {
  var uid = (currentUser && currentUser.id) || "local-user";
  var v = localStorage.getItem("saycrd-" + uid + "-" + key);
  if (v === null) return null;
  return { key: key, value: v };
}
function _localSet(key, value) {
  var uid = (currentUser && currentUser.id) || "local-user";
  localStorage.setItem("saycrd-" + uid + "-" + key, value);
  return { key: key, value: value };
}
function _localDelete(key) {
  var uid = (currentUser && currentUser.id) || "local-user";
  localStorage.removeItem("saycrd-" + uid + "-" + key);
  return { key: key, deleted: true };
}
function _localList(prefix) {
  var uid = (currentUser && currentUser.id) || "local-user";
  var pfx = "saycrd-" + uid + "-";
  var keys = [];
  for (var i = 0; i < localStorage.length; i++) {
    var k = localStorage.key(i);
    if (k && k.indexOf(pfx) === 0) {
      var clean = k.slice(pfx.length);
      if (!prefix || clean.indexOf(prefix) === 0) keys.push(clean);
    }
  }
  return { keys: keys };
}

window.storage = {
  async get(key) {
    if (!currentUser) throw new Error("Not authenticated");
    if (_storageMode() === "local") return _localGet(key);
    try {
      const { data, error } = await sbClient
        .from("user_data")
        .select("key, value")
        .eq("user_id", currentUser.id)
        .eq("key", key)
        .limit(1);
      if (error) { console.warn("Supabase get error, falling back to local:", error.message); return _localGet(key); }
      var row = data && data.length > 0 ? data[0] : null;
      return row ? { key: row.key, value: JSON.stringify(row.value) } : null;
    } catch(e) { console.warn("Supabase get failed:", e); return _localGet(key); }
  },

  async set(key, value) {
    if (!currentUser) throw new Error("Not authenticated");
    /* Always write to localStorage as backup */
    _localSet(key, value);
    if (_storageMode() === "local") return { key: key, value: value };
    try {
      let parsed;
      try { parsed = JSON.parse(value); } catch(e) { parsed = value; }
      const { error } = await sbClient
        .from("user_data")
        .upsert({
          user_id: currentUser.id,
          key: key,
          value: parsed
        }, { onConflict: "user_id,key" });
      if (error) { console.warn("Supabase set error:", error.message); }
      return { key: key, value: value };
    } catch(e) { console.warn("Supabase set failed:", e); return { key: key, value: value }; }
  },

  async delete(key) {
    if (!currentUser) throw new Error("Not authenticated");
    _localDelete(key);
    if (_storageMode() === "local") return { key: key, deleted: true };
    try {
      const { error } = await sbClient
        .from("user_data")
        .delete()
        .eq("user_id", currentUser.id)
        .eq("key", key);
      if (error) console.warn("Supabase delete error:", error.message);
    } catch(e) { console.warn("Supabase delete failed:", e); }
    return { key: key, deleted: true };
  },

  async list(prefix) {
    if (!currentUser) throw new Error("Not authenticated");
    if (_storageMode() === "local") return _localList(prefix);
    try {
      let query = sbClient
        .from("user_data")
        .select("key")
        .eq("user_id", currentUser.id);
      if (prefix) query = query.like("key", prefix + "%");
      const { data, error } = await query;
      if (error) { console.warn("Supabase list error:", error.message); return _localList(prefix); }
      return { keys: (data || []).map(function(d) { return d.key; }) };
    } catch(e) { console.warn("Supabase list failed:", e); return _localList(prefix); }
  }
};

/* ====================================================================
   FAILSAFE BYPASS — works even if Supabase is completely broken
   ==================================================================== */
window._localBypass = function() {
  currentUser = { id: "local-user", email: "local@saycrd" };
  window.currentUser = currentUser;
  /* storage already handles local mode via _storageMode() check */
  var overlay = document.getElementById("auth-overlay");
  if (overlay) {
    overlay.style.opacity = "0";
    overlay.style.transition = "opacity .4s ease";
    setTimeout(function() { overlay.style.display = "none"; }, 400);
  }
  var signoutEl = document.getElementById("ws-signout");
  if (signoutEl) signoutEl.textContent = "local \u00B7 sign out";
  console.log("LOCAL BYPASS ACTIVE — using localStorage");
};

/* ── Auth: restore session + sign out (all form handlers are inline in HTML) ── */
(function() {
  try {
    if (sbClient && sbClient.auth) {
      sbClient.auth.getSession().then(function(result) {
        if (result.data.session) {
          currentUser = result.data.session.user;
          window.currentUser = currentUser;
          window._saycrdToken = result.data.session.access_token;
          var o = document.getElementById("auth-overlay");
          if (o) { o.style.opacity = "0"; o.style.transition = "opacity .4s"; setTimeout(function(){ o.style.display = "none"; }, 400); }
          var sn = document.getElementById("ws-signout");
          if (sn && currentUser.email) sn.textContent = currentUser.email.split("@")[0] + " \u00B7 sign out";
          console.log("Session restored for:", currentUser.email);
        }
      }).catch(function(e) { console.warn("Session restore failed:", e); });

      sbClient.auth.onAuthStateChange(function(event, session) {
        if (session && session.user) {
          currentUser = session.user;
          window.currentUser = currentUser;
          window._saycrdToken = session.access_token;
          var o = document.getElementById("auth-overlay");
          if (o) { o.style.opacity = "0"; o.style.transition = "opacity .4s"; setTimeout(function(){ o.style.display = "none"; }, 400); }
          var sn = document.getElementById("ws-signout");
          if (sn && session.user.email) sn.textContent = session.user.email.split("@")[0] + " \u00B7 sign out";
        }
      });
    }
  } catch(e) { console.warn("Auth init:", e); }

  /* Sign out */
  document.getElementById("ws-signout")?.addEventListener("click", async function() {
    try { if (sbClient && sbClient.auth) await sbClient.auth.signOut(); } catch(e) {}
    currentUser = null;
    window.currentUser = null;
    var o = document.getElementById("auth-overlay");
    if (o) { o.style.display = ""; o.style.opacity = "1"; }
  });
})();

/* ====================================================================
   SAYCRD — Three Phase Session with AI
   ==================================================================== */

/* ── DOM refs ── */
const $ = (id) => document.getElementById(id);
window.$ = $;
const input       = $("session-input");
const field       = $("demo-field");
const svgLayer    = $("connections-svg");
const aiReply     = $("ai-reply");
const dumpHelper  = $("dump-helper");
const centerPulse = $("center-pulse");

const btnSynth   = $("btn-synthesize");
const btnGuide   = $("btn-guide");
const btnReset   = $("btn-reset");
const btnBackDump= $("btn-back-dump");
const btnSave    = $("btn-enter-session");
const btnRestart = $("btn-restart");

const synthContent  = $("synthesis-content");
const synthLoading  = $("synthesis-loading");
const synthActions  = $("synthesis-actions");
const guideContent  = $("guide-content");
const guideLoading  = $("guide-loading");
const guideActions  = $("guide-actions");

const phaseTabs   = document.querySelectorAll(".phase-tab");
const phasePanels = document.querySelectorAll(".phase-panel");

/* ── State ── */
const state = {
  phase: 1,
  maxPhase: 1,
  nodes: new Map(),
  connections: [],
  wordCounts: new Map(),
  analysisTimer: null,
  synthesisData: null,
  guideData: null,
  userAddedItems: [],
  currentSession: null,
  resonance: {},
  guideResponses: {},
  interactions: [],      /* live interaction log */
  insightsPending: false /* debounce flag */
};

/* ════════════════════════════════════════════════════════════════
   INTERACTION ANALYSIS ENGINE — the map grows through use
   ════════════════════════════════════════════════════════════════ */

/* Log every meaningful user interaction */
function logInteraction(type, data) {
  state.interactions.push({
    type: type,            /* guide_response | correction | resonance_no | clarity | reflection | user_node | user_connection */
    data: data,            /* { question, answer, theme, correction, etc } */
    timestamp: Date.now()
  });
  console.log("Interaction logged:", type, data);

  /* After 2+ interactions, queue analysis */
  if (state.interactions.length >= 2 && !state.insightsPending) {
    state.insightsPending = true;
    /* Debounce — wait 8s after last interaction */
    clearTimeout(state._insightTimer);
    state._insightTimer = setTimeout(function() {
      analyzeInteractions();
    }, 8000);
  }
  /* Re-debounce if they keep interacting */
  if (state.insightsPending) {
    clearTimeout(state._insightTimer);
    state._insightTimer = setTimeout(function() {
      analyzeInteractions();
    }, 8000);
  }
}

/* Analyze accumulated interactions — find what the user is revealing */
async function analyzeInteractions() {
  if (!state.synthesisData || state.interactions.length < 2) {
    state.insightsPending = false;
    return;
  }

  var sd = state.synthesisData;
  var interactionSummary = state.interactions.map(function(i) {
    switch (i.type) {
      case "guide_response":
        return "RESPONDED to guide (\"" + i.data.question + "\"): \"" + i.data.answer + "\"";
      case "correction":
        return "DISAGREED with connection \"" + i.data.label + "\" — their correction: \"" + i.data.correction + "\"";
      case "resonance_no":
        return "Said \"not quite\" to connection: " + i.data.label;
      case "resonance_partly":
        return "Said \"partly\" to connection: " + i.data.label;
      case "clarity":
        return "CLARITY STATEMENT: \"" + i.data.text + "\"";
      case "reflection":
        return "REFLECTION ANSWER: \"" + i.data.answer + "\"";
      case "user_node":
        return "ADDED THEME the AI missed: \"" + i.data.label + "\"";
      case "user_connection":
        return "DREW CONNECTION between \"" + i.data.from + "\" and \"" + i.data.to + "\"";
      default:
        return i.type + ": " + JSON.stringify(i.data);
    }
  }).join("\n");

  var themes = (sd.themes || []).map(function(t) { return t.label + " (weight:" + t.weight + ")"; }).join(", ");
  var connections = (sd.connections || []).map(function(c) { return c.from + " → " + c.to + " (" + (c.label||"") + ")"; }).join(", ");

  var prompt = 'You are SAYCRD\'s real-time insight layer. The user completed their initial synthesis and has since been INTERACTING with the results. Their interactions reveal what\'s actually alive for them — disagreements, corrections, and emotional responses are the highest signal.\n\n' +
    'ORIGINAL MAP:\nThemes: ' + themes + '\nConnections: ' + connections + '\nMap title: ' + (sd.map_title || "") + '\n\n' +
    'USER INTERACTIONS SINCE SYNTHESIS:\n' + interactionSummary + '\n\n' +
    'Analyze what the user is revealing through their interactions. Focus on:\n' +
    '- TENSIONS: Where did they push back? Disagree? What does that reveal about a blindspot or unexamined belief?\n' +
    '- WEIGHT SHIFTS: Which themes got more important based on their responses? Which got less relevant?\n' +
    '- NEW CONNECTIONS: Did their words reveal a link between themes the AI missed?\n' +
    '- NEW GUIDE: Based on what they ACTUALLY revealed (not the original synthesis), what\'s the one move they need?\n\n' +
    'Respond with ONLY JSON:\n' +
    '{"weight_shifts":[{"label":"existing theme","delta":-2 to +2}],' +
    '"new_connections":[{"from":"theme","to":"theme","label":"1-2 words","insight":"what this reveals"}],' +
    '"surfaced_tension":{"observation":"1 sentence about what their interactions reveal that the original map missed","themes":["theme1","theme2"]},' +
    '"new_guide":{"type":"do|notice|ask|release","text":"max 15 words","source":"theme or theme1 + theme2"},' +
    '"map_evolution":"1 sentence — how the map should be read differently now"}';

  try {
    var raw = await callClaude(prompt, "Analyze these interactions.", 800);
    var insights = extractJSON(raw);
    if (insights) {
      console.log("Interaction insights:", insights);
      applyInsights(insights);
    }
  } catch(e) {
    console.warn("Interaction analysis failed:", e);
  }

  state.insightsPending = false;
  state.interactions = []; /* reset for next batch */
}

/* Apply insights back to the live session */
function applyInsights(insights) {
  var sd = state.synthesisData;
  if (!sd) return;

  /* 1. Weight shifts — update theme weights */
  if (insights.weight_shifts && insights.weight_shifts.length) {
    insights.weight_shifts.forEach(function(ws) {
      var theme = (sd.themes || []).find(function(t) { return t.label.toLowerCase() === ws.label.toLowerCase(); });
      if (theme) {
        theme.weight = Math.max(1, Math.min(5, (theme.weight || 1) + ws.delta));
      }
    });
  }

  /* 2. New connections — add to synthesis data */
  if (insights.new_connections && insights.new_connections.length) {
    if (!sd.connections) sd.connections = [];
    insights.new_connections.forEach(function(nc) {
      nc.fromInteraction = true; /* mark as interaction-derived */
      sd.connections.push(nc);
    });
  }

  /* 3. Surfaced tension — store for infographic */
  if (insights.surfaced_tension && insights.surfaced_tension.observation) {
    state.surfacedTension = insights.surfaced_tension;
    if (state.currentSession) {
      state.currentSession.surfacedTension = insights.surfaced_tension;
      saveHistory();
    }
  }

  /* 4. Map evolution note — store */
  if (insights.map_evolution) {
    state.mapEvolution = insights.map_evolution;
    if (state.currentSession) {
      state.currentSession.mapEvolution = insights.map_evolution;
      saveHistory();
    }
  }

  /* 5. New guide item — add to live guide */
  if (insights.new_guide && insights.new_guide.text) {
    insights.new_guide.fromInteraction = true;
    if (!sd.guide) sd.guide = [];
    sd.guide.push(insights.new_guide);
    /* Render it into the guide UI if visible */
    renderInsightGuide(insights.new_guide);
  }

  /* 6. Visual feedback — show the map evolved */
  showMapEvolution(insights);
}

/* Render a new guide item that emerged from interaction */
function renderInsightGuide(item) {
  var guideEl = document.querySelector(".guide");
  if (!guideEl) return;

  var typeLabelsLive = { do: "Do", notice: "Notice", ask: "Ask", release: "Release", act: "Do", sit: "Notice", deepen: "Ask", surrender: "Release" };
  var guideText = item.text || "";
  var div = document.createElement("div");
  div.className = "guide-item type-" + item.type + " from-interaction";
  div.style.cssText = "opacity:0;transform:translateY(8px);transition:all .6s ease;border-color:rgba(244,196,109,.25);background:rgba(244,196,109,.04)";

  var tag = document.createElement("span");
  tag.className = "tag " + item.type;
  tag.textContent = (typeLabelsLive[item.type] || item.type);

  var badge = document.createElement("div");
  badge.className = "guide-source-badge";
  var emerged = document.createElement("span");
  emerged.className = "guide-source-label";
  emerged.style.color = "rgba(244,196,109,.6)";
  emerged.textContent = "\u2728 emerged from your responses";
  badge.appendChild(emerged);

  if (item.source) {
    var badgeColorList = ['#f4c46d','#5ed3c0','#f08b73','#9ad0ff','#b4a0dc'];
    item.source.split(/\s*\+\s*/).forEach(function(s, si) {
      var dot = document.createElement("span");
      dot.className = "guide-source-dot";
      dot.style.background = badgeColorList[si % badgeColorList.length];
      badge.appendChild(dot);
      var lbl = document.createElement("span");
      lbl.className = "guide-source-label";
      lbl.textContent = s.trim();
      badge.appendChild(lbl);
    });
  }

  var p = document.createElement("p");
  p.textContent = guideText;
  div.append(tag, badge, p);
  guideEl.appendChild(div);

  /* Animate in */
  requestAnimationFrame(function() {
    requestAnimationFrame(function() {
      div.style.opacity = "1";
      div.style.transform = "translateY(0)";
    });
  });
}

/* Show visual feedback that the map evolved */
function showMapEvolution(insights) {
  /* Flash the constellation border */
  var constellation = document.querySelector(".map-constellation, .constellation");
  if (constellation) {
    constellation.style.transition = "box-shadow .8s ease";
    constellation.style.boxShadow = "0 0 30px rgba(244,196,109,.15)";
    setTimeout(function() { constellation.style.boxShadow = ""; }, 2000);
  }

  /* Show evolution toast */
  if (insights.map_evolution || (insights.surfaced_tension && insights.surfaced_tension.observation)) {
    var toast = document.createElement("div");
    toast.style.cssText = "position:fixed;bottom:100px;left:50%;transform:translateX(-50%) translateY(20px);opacity:0;z-index:9999;max-width:380px;padding:1rem 1.4rem;border-radius:16px;background:rgba(14,17,21,.95);border:1px solid rgba(244,196,109,.2);box-shadow:0 8px 32px rgba(0,0,0,.5);backdrop-filter:blur(12px);transition:all .6s ease;font-family:'Fraunces',serif";

    var text = insights.surfaced_tension ? insights.surfaced_tension.observation : insights.map_evolution;
    toast.innerHTML = '<div style="font-size:.65rem;letter-spacing:.2em;text-transform:uppercase;color:rgba(244,196,109,.5);margin-bottom:.5rem;font-family:\'Space Grotesk\',sans-serif">\u25C8 The map shifted</div>' +
      '<div style="font-size:.92rem;color:rgba(247,241,231,.7);line-height:1.55;font-style:italic">' + text + '</div>';

    document.body.appendChild(toast);
    requestAnimationFrame(function() {
      requestAnimationFrame(function() {
        toast.style.opacity = "1";
        toast.style.transform = "translateX(-50%) translateY(0)";
      });
    });
    setTimeout(function() {
      toast.style.opacity = "0";
      toast.style.transform = "translateX(-50%) translateY(20px)";
      setTimeout(function() { toast.remove(); }, 600);
    }, 6000);
  }
}

/* ── Stop words ── */
const stops = new Set("i me my we our you your it its the a an and or but in on at to for of is am are was were be been being have has had do does did will would could should may might shall can this that these those with from into about between through during before after just not no so if then than too very much more most also like really know thing things don doesn didn lot get got going go come came way even still well back up out off over down all some any every each what when where which who how why because since while once here there now already always never sometimes maybe everything something nothing anything much many few little right make made one two keep try trying let see say said tell told take took give gave put day time year long big new old good bad first last own other same different sure think thought around doing having getting though although however evening morning afternoon tonight today tomorrow yesterday week month pretty quite kinda sorta stuff happen happened happening happens whole kind sort anyway actually basically literally probably definitely certainly perhaps gonna wanna gotta okay yeah nope onto upon along across toward towards against until unless whether either neither both another such rather instead despite except itself myself yourself himself herself themselves ourselves else again only almost often soon later early late next part most least seem seems seemed become became remain turn turned show showed shown goes gone went done bring brought sent left found feel felt start started begin began point place world life people person hand head room area line side case number group company fact house night using used work worked works able best three four five high looking looked looks called half real open want wanted need needed".split(" "));

/* ── Helpers ── */
const extractWords = (text) =>
  text.toLowerCase().replace(/[^a-z'\s-]/g, "").split(/\s+/)
    .filter(w => w.length > 3 && !stops.has(w));

const capitalize = s => s.charAt(0).toUpperCase() + s.slice(1);

/* ── Phase management ── */
function setPhase(phase) {
  state.phase = phase;
  if (phase > state.maxPhase) state.maxPhase = phase;
  phaseTabs.forEach(t => {
    const p = +t.dataset.phase;
    t.classList.toggle("is-active", p === phase);
    t.classList.toggle("is-locked", p > state.maxPhase);
  });
  phasePanels.forEach(p => p.classList.toggle("is-active", +p.dataset.panel === phase));
  /* Auto-show Growing viewer when entering Phase 4 */
  if (phase === 4) {
    var gv = document.getElementById("growing-viewer");
    if (gv) gv.style.display = "";
  }
}

phaseTabs.forEach(tab => tab.addEventListener("click", () => {
  const p = +tab.dataset.phase;
  if (p <= state.maxPhase) setPhase(p);
}));

/* ── Realtime map during Phase 1 ── */
const nodeColors = [
  { bg:"rgba(214,178,109,.15)", border:"rgba(214,178,109,.45)" },
  { bg:"rgba(125,183,174,.15)", border:"rgba(125,183,174,.45)" },
  { bg:"rgba(196,110,95,.12)", border:"rgba(196,110,95,.4)" },
  { bg:"rgba(160,140,200,.12)", border:"rgba(160,140,200,.35)" },
  { bg:"rgba(244,241,234,.06)", border:"rgba(244,241,234,.2)" },
];

function fieldRect() { return field.getBoundingClientRect(); }

/* Collision-aware placement: checks against all existing nodes */
function findOpenPosition(fr, label) {
  /* Measure how wide this label will be (rough estimate) */
  var estW = Math.max(label.length * 8 + 32, 80);
  var estH = 36;
  var edgePad = 24; /* never touch field edges */
  var topPad = 52;  /* account for map title */
  var nodePad = 22; /* gap between nodes */
  var maxX = fr.width - estW - edgePad;
  var maxY = fr.height - estH - edgePad;
  var best = null, bestDist = -1;
  for (var attempt = 0; attempt < 80; attempt++) {
    var x = Math.random() * (maxX - edgePad) + edgePad;
    var y = Math.random() * (maxY - topPad) + topPad;
    var minDist = Infinity;
    var collides = false;
    state.nodes.forEach(function(nd) {
      var el = nd.element;
      var nx = parseFloat(el.style.left) || 0;
      var ny = parseFloat(el.style.top) || 0;
      var nw = el.offsetWidth || 80;
      var nh = el.offsetHeight || 36;
      /* Check rect overlap with generous margin */
      if (x < nx + nw + nodePad && x + estW + nodePad > nx && y < ny + nh + nodePad && y + estH + nodePad > ny) {
        collides = true;
      }
      var dist = Math.hypot(x - nx, y - ny);
      if (dist < minDist) minDist = dist;
    });
    if (!collides && minDist > bestDist) { best = { x: x, y: y }; bestDist = minDist; }
    if (!collides && minDist > 100) break; /* good enough */
  }
  return best || { x: Math.random() * (maxX - edgePad) + edgePad, y: Math.random() * (maxY - topPad) + topPad };
}

function placeMapNode(key, label, weight) {
  if (state.nodes.size >= 10) return;
  const fr = fieldRect();
  const pos = findOpenPosition(fr, label);
  const el = document.createElement("div");
  el.className = "map-node";
  el.textContent = label;
  el.dataset.key = key;
  const c = nodeColors[Math.floor(Math.random() * nodeColors.length)];
  el.style.background = c.bg; el.style.borderColor = c.border;
  el.style.left = `${pos.x}px`; el.style.top = `${pos.y}px`;
  el.style.opacity = "0";
  field.appendChild(el);
  requestAnimationFrame(() => requestAnimationFrame(() => { el.style.opacity = "1"; }));
  state.nodes.set(key, { element: el, label, weight: weight || 1, isAI: false });
  el.addEventListener("pointerdown", onDragStart);
}

function updateNodeWeight(key, newWeight) {
  const nd = state.nodes.get(key);
  if (!nd) return;
  nd.weight = newWeight;
  const s = 1 + Math.min(newWeight * 0.06, 0.35);
  nd.element.style.transform = `scale(${s})`;
  if (newWeight >= 3) nd.element.classList.add("heavy");
}

function fadeNode(key) {
  const nd = state.nodes.get(key);
  if (!nd) return;
  nd.element.classList.add("fading");
  setTimeout(() => { nd.element.remove(); state.nodes.delete(key); }, 1000);
}

/* Process input text */
function processInput() {
  const words = extractWords(input.value);
  const fresh = new Map();
  words.forEach(w => fresh.set(w, (fresh.get(w) || 0) + 1));

  /* Update counts */
  fresh.forEach((count, word) => {
    const prev = state.wordCounts.get(word) || 0;
    state.wordCounts.set(word, count);
    if (count >= 1 && !state.nodes.has(word)) {
      placeMapNode(word, capitalize(word), count);
    }
    if (count !== prev && state.nodes.has(word)) {
      updateNodeWeight(word, count);
    }
  });

  /* Fade words that disappeared */
  state.wordCounts.forEach((count, word) => {
    if (!fresh.has(word) && state.nodes.has(word)) {
      fadeNode(word);
      state.wordCounts.delete(word);
    }
  });

  /* Enable synthesize when there's enough material */
  const charCount = input.value.trim().length;
  btnSynth.disabled = charCount < 40;
  if (charCount < 20) {
    dumpHelper.textContent = "Keep going. The map is listening.";
  } else if (charCount < 80) {
    dumpHelper.textContent = "There\u2019s something here. Say more.";
  } else {
    dumpHelper.textContent = "Whenever you\u2019re ready, hit Synthesize.";
  }
}

let inputTimer;
input?.addEventListener("input", () => {
  clearTimeout(inputTimer);
  inputTimer = setTimeout(processInput, 400);
});

/* ── Drag system ── */
const SNAP_DIST = 140;

function getCenter(nd) {
  const el = nd.element;
  /* During CSS transitions, style.left is the target — use getBoundingClientRect for actual position */
  var fr = field.getBoundingClientRect();
  var er = el.getBoundingClientRect();
  return { x: er.left - fr.left + er.width / 2, y: er.top - fr.top + er.height / 2 };
}

function onDragStart(e) {
  e.preventDefault();
  const el = e.currentTarget;
  const key = el.dataset.key;
  const fr = fieldRect();
  const ox = e.clientX - fr.left - parseFloat(el.style.left);
  const oy = e.clientY - fr.top - parseFloat(el.style.top);
  el.classList.add("dragging");
  el.setPointerCapture(e.pointerId);
  state._drag = { key, el, ox, oy, snap: null };
  el.addEventListener("pointermove", onDragMove);
  el.addEventListener("pointerup", onDragEnd);
  el.addEventListener("pointercancel", onDragEnd);
}

function onDragMove(e) {
  const d = state._drag; if (!d) return;
  const fr = fieldRect();
  let x = Math.max(5, Math.min(e.clientX - fr.left - d.ox, fr.width - d.el.offsetWidth - 5));
  let y = Math.max(5, Math.min(e.clientY - fr.top - d.oy, fr.height - d.el.offsetHeight - 5));
  d.el.style.left = `${x}px`; d.el.style.top = `${y}px`;
  updateConnLines(d.key);
  const dc = { x: x + d.el.offsetWidth / 2, y: y + d.el.offsetHeight / 2 };
  let closest = null, closeDist = Infinity;
  state.nodes.forEach((nd, nk) => {
    if (nk === d.key) return;
    const c = getCenter(nd);
    const dist = Math.hypot(c.x - dc.x, c.y - dc.y);
    if (dist < SNAP_DIST && dist < closeDist) {
      const exists = state.connections.some(cn => (cn.a === d.key && cn.b === nk) || (cn.a === nk && cn.b === d.key));
      if (!exists) { closeDist = dist; closest = nk; }
    }
  });
  if (d.snap && d.snap !== closest) { const o = state.nodes.get(d.snap); if (o) o.element.classList.remove("snap-target"); }
  if (closest) { state.nodes.get(closest).element.classList.add("snap-target"); d.snap = closest; }
  else d.snap = null;
}

function onDragEnd(e) {
  const d = state._drag; if (!d) return;
  d.el.classList.remove("dragging");
  d.el.removeEventListener("pointermove", onDragMove);
  d.el.removeEventListener("pointerup", onDragEnd);
  d.el.removeEventListener("pointercancel", onDragEnd);
  console.log("onDragEnd: key=" + d.key, "snap=" + d.snap);
  if (d.snap) {
    const t = state.nodes.get(d.snap);
    if (t) {
      t.element.classList.remove("snap-target");
      /* Flash both nodes to confirm connection */
      d.el.style.boxShadow = "0 0 20px rgba(125,183,174,.6)";
      t.element.style.boxShadow = "0 0 20px rgba(125,183,174,.6)";
      setTimeout(function() { d.el.style.boxShadow = ""; t.element.style.boxShadow = ""; }, 800);
      /* Draw with temporary label, then ask AI for the real connection */
      drawConnection(d.key, d.snap, "\u2026", null);
      var snapKey = d.snap;
      var dragKey = d.key;
      
      /* Timeout fallback — if AI hasn't responded in 15s, show "linked" */
      var connTimeout = setTimeout(function() {
        var c = state.connections.find(function(cn) {
          return (cn.a === dragKey && cn.b === snapKey) || (cn.a === snapKey && cn.b === dragKey);
        });
        if (c && c.labelEl && c.labelEl.textContent === "\u2026") {
          c.labelEl.textContent = "linked";
          console.warn("Connection insight timed out for", dragKey, "↔", snapKey);
        }
      }, 15000);
      
      generateConnectionInsight(dragKey, snapKey).finally(function() {
        clearTimeout(connTimeout);
      });
      /* Persist into synthesisData */
      if (state.synthesisData) {
        if (!state.synthesisData.connections) state.synthesisData.connections = [];
        state.synthesisData.connections.push({ from: d.key, to: d.snap, label: "", insight: "", userAdded: true });
      }
      logInteraction("user_connection", { from: d.key, to: d.snap });
    }
  }
  state._drag = null;
}

/* ── Connection drawing ── */
/* ── Synthesize connection insight from accumulated guide responses ── */
function drawConnection(keyA, keyB, label, insight) {
  /* Fuzzy node lookup — handles case/whitespace mismatches from AI */
  function findNode(key) {
    var exact = state.nodes.get(key);
    if (exact) return exact;
    var lower = key.toLowerCase().trim();
    var found = null;
    state.nodes.forEach(function(nd, k) {
      if (k.toLowerCase().trim() === lower) found = nd;
    });
    return found;
  }
  const nA = findNode(keyA), nB = findNode(keyB);
  if (!nA || !nB) { console.warn("Connection skipped — node not found:", keyA, "→", keyB); return; }
  const cA = getCenter(nA), cB = getCenter(nB);

  /* Shorten line so it stops at node edges (not centers) */
  var dx = cB.x - cA.x, dy = cB.y - cA.y;
  var dist = Math.hypot(dx, dy) || 1;
  var ux = dx / dist, uy = dy / dist;
  var rA = Math.max(nA.element.offsetWidth, nA.element.offsetHeight) / 2 + 6;
  var rB = Math.max(nB.element.offsetWidth, nB.element.offsetHeight) / 2 + 6;
  var x1 = cA.x + ux * rA, y1 = cA.y + uy * rA;
  var x2 = cB.x - ux * rB, y2 = cB.y - uy * rB;

  const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
  line.classList.add("conn-line");
  line.setAttribute("x1", x1); line.setAttribute("y1", y1);
  line.setAttribute("x2", x2); line.setAttribute("y2", y2);
  line.setAttribute("data-from", keyA); line.setAttribute("data-to", keyB);
  svgLayer.appendChild(line);
  const lbl = document.createElement("div");
  lbl.className = "conn-label unexplored";
  lbl.textContent = label || "";
  lbl.setAttribute("data-from", keyA); lbl.setAttribute("data-to", keyB);
  var mx = (cA.x + cB.x) / 2, my = (cA.y + cB.y) / 2;

  /* Nudge label if it overlaps any node */
  var lblW = Math.max((label || "").length * 7 + 24, 60);
  var lblH = 32;
  state.nodes.forEach(function(nd) {
    var el = nd.element;
    var nx = parseFloat(el.style.left) || 0;
    var ny = parseFloat(el.style.top) || 0;
    var nw = el.offsetWidth || 80;
    var nh = el.offsetHeight || 36;
    var pad = 14;
    if (mx - lblW / 2 < nx + nw + pad && mx + lblW / 2 + pad > nx &&
        my - lblH / 2 < ny + nh + pad && my + lblH / 2 + pad > ny) {
      /* Offset perpendicular to connection line */
      my += (uy >= 0 ? -1 : 1) * 30;
      mx += (-uy) * 20;
    }
  });

  lbl.style.left = mx + "px"; lbl.style.top = my + "px";
  field.appendChild(lbl);

  /* Tap to reveal insight drawer */
  var connObj = { a: keyA, b: keyB, line, labelEl: lbl, synthesizedInsight: insight || "" };
  lbl.addEventListener("click", function(e) {
    e.stopPropagation();
    /* Use synthesized insight if available, otherwise original */
    var activeInsight = connObj.synthesizedInsight || insight;
    if (!activeInsight) return;
    field.querySelectorAll(".conn-insight").forEach(function(el) { el.remove(); });
    var wasActive = lbl.classList.contains("active");
    field.querySelectorAll(".conn-label.active").forEach(function(el) { el.classList.remove("active"); });
    if (wasActive) return;
    lbl.classList.add("active");
    openInsightDrawer(lbl, mx, my, keyA, keyB, lbl.textContent || label, activeInsight);
  });

  state.connections.push(connObj);
}

/* ── Reusable insight drawer with resonance + correction capture ── */
function openInsightDrawer(lbl, mx, my, keyA, keyB, label, insight) {
  var popup = document.createElement("div");
  popup.className = "conn-insight";
  popup.style.left = mx + "px"; popup.style.top = my + "px";

  var inner = document.createElement("div");
  inner.className = "conn-insight-inner";

  var closeBtn = document.createElement("button");
  closeBtn.className = "conn-insight-close";
  closeBtn.innerHTML = "&#x2715;";
  closeBtn.addEventListener("click", function(ev) {
    ev.stopPropagation(); popup.remove(); lbl.classList.remove("active");
  });

  var textEl = document.createElement("div");
  textEl.className = "conn-insight-text";
  textEl.textContent = insight;

  var askEl = document.createElement("div");
  askEl.className = "conn-insight-ask";
  askEl.textContent = "Does this land?";

  var resRow = document.createElement("div");
  resRow.className = "resonance-row";

  var options = [
    { icon: "\u2726", label: "Yes", value: "yes" },
    { icon: "\u25C7", label: "Partly", value: "partly" },
    { icon: "\u2014", label: "Not quite", value: "no" }
  ];

  var connKey = keyA + "::" + keyB;
  options.forEach(function(opt) {
    var btn = document.createElement("button");
    btn.className = "resonance-btn";
    btn.innerHTML = '<span class="res-icon">' + opt.icon + '</span>' + opt.label;
    btn.addEventListener("click", function(ev) {
      ev.stopPropagation();
      if (!state.resonance) state.resonance = {};
      state.resonance[connKey] = { value: opt.value, label: label, insight: insight, from: keyA, to: keyB };
      try { window.storage.set("saycrd-resonance", JSON.stringify(state.resonance)); } catch(ex) {}
      if (opt.value === "no" || opt.value === "partly") {
        logInteraction("resonance_" + opt.value, { label: label, insight: insight, from: keyA, to: keyB });
      }
      resRow.querySelectorAll(".resonance-btn").forEach(function(b) { b.classList.remove("selected"); });
      btn.classList.add("selected");

      if (opt.value === "no" || opt.value === "partly") {
        /* Show correction input */
        setTimeout(function() {
          askEl.remove(); resRow.remove();
          var corrWrap = document.createElement("div");
          corrWrap.className = "resonance-correction";
          corrWrap.innerHTML = '<div class="resonance-correction-label">' +
            (opt.value === "no" ? "What\u2019s more accurate?" : "What would make it closer?") + '</div>';
          var corrInput = document.createElement("textarea");
          corrInput.className = "resonance-correction-input";
          corrInput.placeholder = "In your words\u2026";
          corrInput.rows = 2;
          corrWrap.appendChild(corrInput);
          var corrHint = document.createElement("div");
          corrHint.className = "resonance-correction-hint";
          corrHint.textContent = "Enter to save \u00B7 This sharpens future readings";
          corrWrap.appendChild(corrHint);
          inner.appendChild(corrWrap);
          setTimeout(function() { corrInput.focus(); }, 60);

          corrInput.addEventListener("keydown", function(ke) {
            if (ke.key === "Enter" && !ke.shiftKey && corrInput.value.trim().length > 0) {
              ke.preventDefault();
              var correction = corrInput.value.trim();
              state.resonance[connKey].correction = correction;
              try { window.storage.set("saycrd-resonance", JSON.stringify(state.resonance)); } catch(ex) {}
              logInteraction("correction", { label: label, insight: insight, from: keyA, to: keyB, correction: correction });
              svNotify(keyA, keyB, opt.value === "no" ? "no" : "partly", label, insight, correction);
              corrWrap.innerHTML = '';
              var thanks = document.createElement("div");
              thanks.className = "resonance-thanked";
              thanks.textContent = "Heard. \u201C" + correction.slice(0, 60) + (correction.length > 60 ? "\u2026" : "") + "\u201D \u2014 saved.";
              corrWrap.appendChild(thanks);
              setTimeout(function() {
                popup.style.opacity = "0"; popup.style.transition = "opacity .4s ease";
                setTimeout(function() { popup.remove(); lbl.classList.remove("active"); }, 400);
              }, 2800);
            }
          });
        }, 300);
      } else {
        /* "Yes" — thank and close */
        svNotify(keyA, keyB, "yes", label, insight);
        setTimeout(function() {
          askEl.remove(); resRow.remove();
          var thanks = document.createElement("div");
          thanks.className = "resonance-thanked";
          thanks.textContent = "Noted. The system is learning you.";
          inner.appendChild(thanks);
          setTimeout(function() {
            popup.style.opacity = "0"; popup.style.transition = "opacity .4s ease";
            setTimeout(function() { popup.remove(); lbl.classList.remove("active"); }, 400);
          }, 2200);
        }, 350);
      }
    });
    resRow.appendChild(btn);
  });

  inner.append(textEl, askEl, resRow);
  popup.append(closeBtn, inner);
  field.appendChild(popup);

  /* ── Auto-reposition if popup overflows the field ── */
  requestAnimationFrame(function() {
    var fr = field.getBoundingClientRect();
    var pr = popup.getBoundingClientRect();
    var px = parseFloat(popup.style.left) || 0;
    var py = parseFloat(popup.style.top) || 0;
    /* If bottom is cut off, flip above the label */
    if (pr.bottom > fr.bottom - 8) {
      py = py - pr.height - 24;
      if (py < 10) py = 10;
      popup.style.top = py + "px";
      popup.style.animation = "none"; popup.style.opacity = "1";
      popup.style.transform = "translate(-50%,-8px)";
    }
    /* If right edge is cut off */
    if (pr.right > fr.right - 8) {
      px = px - (pr.right - fr.right) - 16;
      popup.style.left = px + "px";
    }
    /* If left edge is cut off */
    if (pr.left < fr.left + 8) {
      px = px + (fr.left - pr.left) + 16;
      popup.style.left = px + "px";
    }
  });

  /* ── Make popup draggable ── */
  var dragState = { dragging: false, startX: 0, startY: 0, origX: 0, origY: 0 };
  popup.addEventListener("pointerdown", function(de) {
    /* Don't drag if clicking a button, input, or close */
    if (de.target.closest("button, input, textarea")) return;
    de.preventDefault(); de.stopPropagation();
    dragState.dragging = true;
    dragState.startX = de.clientX; dragState.startY = de.clientY;
    var cr = popup.getBoundingClientRect();
    var fr2 = field.getBoundingClientRect();
    dragState.origX = cr.left - fr2.left + cr.width / 2;
    dragState.origY = cr.top - fr2.top;
    popup.classList.add("dragging");
    popup.style.animation = "none"; popup.style.opacity = "1";
    popup.style.transform = "none";
    popup.style.left = dragState.origX + "px";
    popup.style.top = dragState.origY + "px";
    popup.setPointerCapture(de.pointerId);
  });
  popup.addEventListener("pointermove", function(me) {
    if (!dragState.dragging) return;
    me.preventDefault();
    var dx = me.clientX - dragState.startX, dy = me.clientY - dragState.startY;
    popup.style.left = (dragState.origX + dx) + "px";
    popup.style.top = (dragState.origY + dy) + "px";
  });
  popup.addEventListener("pointerup", function(ue) {
    if (!dragState.dragging) return;
    dragState.dragging = false;
    popup.classList.remove("dragging");
  });

  setTimeout(function() {
    document.addEventListener("click", function closer(ev) {
      if (popup.contains(ev.target)) return;
      popup.remove(); lbl.classList.remove("active");
      document.removeEventListener("click", closer);
    });
  }, 50);
}

/* ── AI-generated insight for user-dragged connections ── */
async function generateConnectionInsight(keyA, keyB) {
  console.log("generateConnectionInsight:", keyA, "↔", keyB);
  var nA = state.nodes.get(keyA), nB = state.nodes.get(keyB);
  if (!nA || !nB) { console.warn("Node not found:", !nA ? keyA : keyB); return; }
  var labelA = nA.label, labelB = nB.label;
  var dumpText = input ? input.value.trim() : "";
  var context = dumpText ? "\n\nContext (their raw dump):\n" + dumpText.slice(0, 600) : "";

  try {
    var sysPrompt = 'The user connected two themes on their map by dragging one toward the other. They see a relationship.\n\n' +
      'Themes: "' + labelA + '" and "' + labelB + '".' + context + '\n\n' +
      'Generate:\n1. CONNECTION LABEL (2-4 words) naming what binds these.\n2. INSIGHT (1-2 sentences) revealing something about why these connect. Warm, direct, 2nd person.\n\n' +
      'Respond ONLY valid JSON: {"label":"...","insight":"..."}';

    var raw = await callClaude(sysPrompt, "Themes: " + labelA + " + " + labelB);
    console.log("Connection insight raw:", raw && raw.slice(0, 100));
    var data = extractJSON(raw);

    var conn = state.connections.find(function(c) {
      return (c.a === keyA && c.b === keyB) || (c.a === keyB && c.b === keyA);
    });
    if (conn && conn.labelEl) {
      var newLabelText = data.label || "linked";
      conn.labelEl.textContent = newLabelText;

      if (data.insight) {
        var oldLabel = conn.labelEl;
        var newLabel = oldLabel.cloneNode(true);
        oldLabel.parentNode.replaceChild(newLabel, oldLabel);
        conn.labelEl = newLabel;
        var lx = parseFloat(newLabel.style.left) || 0;
        var ly = parseFloat(newLabel.style.top) || 0;

        newLabel.addEventListener("click", function(e) {
          e.stopPropagation();
          field.querySelectorAll(".conn-insight").forEach(function(el) { el.remove(); });
          var wasActive = newLabel.classList.contains("active");
          field.querySelectorAll(".conn-label.active").forEach(function(el) { el.classList.remove("active"); });
          if (wasActive) return;
          newLabel.classList.add("active");
          openInsightDrawer(newLabel, lx, ly, keyA, keyB, newLabelText, data.insight);
        });
      }
      console.log("Connection insight complete:", newLabelText);
    }
  } catch(err) {
    console.error("Connection insight error:", err);
    var conn2 = state.connections.find(function(c) {
      return (c.a === keyA && c.b === keyB) || (c.a === keyB && c.b === keyA);
    });
    if (conn2 && conn2.labelEl) conn2.labelEl.textContent = "linked";
  }
}


function updateConnLines(movedKey) {
  state.connections.forEach(cn => {
    if (cn.a !== movedKey && cn.b !== movedKey) return;
    const nA = state.nodes.get(cn.a), nB = state.nodes.get(cn.b);
    if (!nA || !nB) return;
    const cA = getCenter(nA), cB = getCenter(nB);
    cn.line.setAttribute("x1", cA.x); cn.line.setAttribute("y1", cA.y);
    cn.line.setAttribute("x2", cB.x); cn.line.setAttribute("y2", cB.y);
    cn.labelEl.style.left = `${(cA.x + cB.x) / 2}px`; cn.labelEl.style.top = `${(cA.y + cB.y) / 2}px`;
  });
}

/* ── Interactive Map: Click-to-Add & Click-to-Connect ── */
(function() {
  var MAX_USER_ORBS = 4;
  var CHAR_LIMIT = 35;
  var userOrbCount = 0;
  var activeInput = null;
  var particlesSpawned = false;

  /* Spawn subtle particles in empty space — the breadcrumb */
  function spawnParticles() {
    if (field.querySelector(".map-particle")) { particlesSpawned = true; return; }
    if (particlesSpawned || !field) return;
    particlesSpawned = true;
    var fr = field.getBoundingClientRect();
    for (var i = 0; i < 6; i++) {
      var p = document.createElement("div");
      p.className = "map-particle";
      p.style.left = (20 + Math.random() * (fr.width - 40)) + "px";
      p.style.top = (60 + Math.random() * (fr.height - 120)) + "px";
      p.style.animationDelay = (Math.random() * 6) + "s";
      p.style.animationDuration = (6 + Math.random() * 5) + "s";
      field.appendChild(p);
    }
  }

  /* Lazy spawn: check on first field interaction after synthesis */
  function maybeSpawnParticles() {
    if (!particlesSpawned && state.synthesisData && state.synthesisData.themes && state.nodes.size > 0) {
      spawnParticles();
    }
  }

  /* Check if click is on empty space (not on a node, label, or input) */
  function isEmptySpace(e) {
    var t = e.target;
    if (t.classList.contains("map-node") || t.classList.contains("conn-label") ||
        t.classList.contains("conn-insight") || t.tagName === "INPUT" ||
        t.classList.contains("map-add-input") || t.closest(".conn-insight") ||
        t.classList.contains("map-becoming") || t.closest(".map-becoming")) return false;
    return t === field || t.classList.contains("field-glow") ||
           t.classList.contains("field-grid") || t.classList.contains("map-particle") ||
           t.classList.contains("field-center") || t.classList.contains("pulse") ||
           t.tagName === "svg" || t.closest(".demo-field") === field && !t.closest(".map-node") && !t.closest(".conn-label") && !t.closest(".conn-insight");
  }

  /* Fuzzy match against existing themes */
  function existingThemeMatch(label) {
    var lower = label.toLowerCase().trim();
    var match = null;
    state.nodes.forEach(function(nd) {
      if (nd.label.toLowerCase().trim() === lower) match = nd;
      /* Also check if one contains the other */
      if (!match && (nd.label.toLowerCase().includes(lower) || lower.includes(nd.label.toLowerCase()))) match = nd;
    });
    return match;
  }

  /* Pulse an existing node to show it's already there */
  function pulseExisting(nd) {
    var el = nd.element;
    el.style.transition = "all .3s ease";
    el.style.boxShadow = "0 0 30px rgba(214,178,109,.6)";
    el.style.borderColor = "rgba(214,178,109,.8)";
    setTimeout(function() {
      el.style.boxShadow = "";
      el.style.borderColor = "";
    }, 1200);
  }

  /* Create the inline input at click position */
  function showAddInput(x, y) {
    removeAddInput();
    if (userOrbCount >= MAX_USER_ORBS) return;
    if (!state.synthesisData || !state.synthesisData.themes) return;

    var inp = document.createElement("input");
    inp.type = "text";
    inp.className = "map-add-input";
    inp.placeholder = "\u2026";
    inp.maxLength = CHAR_LIMIT;
    inp.style.left = x + "px";
    inp.style.top = (y - 14) + "px";
    /* Auto-size: measure as they type */
    inp.style.width = "24px";
    field.appendChild(inp);
    activeInput = inp;

    requestAnimationFrame(function() { inp.focus(); });

    inp.addEventListener("input", function() {
      /* Grow width to fit text */
      var measure = document.createElement("span");
      measure.style.cssText = "position:absolute;visibility:hidden;font-family:Fraunces,serif;font-size:1.4rem;font-weight:300;letter-spacing:-.01em;white-space:pre";
      measure.textContent = inp.value || "\u2026";
      document.body.appendChild(measure);
      inp.style.width = Math.min(Math.max(measure.offsetWidth + 8, 24), 280) + "px";
      measure.remove();
    });

    inp.addEventListener("keydown", function(e) {
      if (e.key === "Enter") {
        e.preventDefault();
        var val = inp.value.trim();
        if (!val) { removeAddInput(); return; }

        var existing = existingThemeMatch(val);
        if (existing) {
          pulseExisting(existing);
          removeAddInput();
          return;
        }

        /* Morph: get input position, remove input, create orb at same spot */
        var ix = parseFloat(inp.style.left);
        var iy = parseFloat(inp.style.top);
        activeInput = null;
        inp.remove();
        addUserOrb(val, ix, iy);
      }
      if (e.key === "Escape") { removeAddInput(); }
    });

    inp.addEventListener("blur", function() {
      setTimeout(function() {
        if (activeInput !== inp) return;
        var val = inp.value.trim();
        if (val) {
          var existing = existingThemeMatch(val);
          if (existing) { pulseExisting(existing); removeAddInput(); return; }
          var ix = parseFloat(inp.style.left);
          var iy = parseFloat(inp.style.top);
          activeInput = null;
          inp.remove();
          addUserOrb(val, ix, iy);
        } else {
          removeAddInput();
        }
      }, 150);
    });
  }

  function removeAddInput() {
    if (activeInput) { activeInput.remove(); activeInput = null; }
  }

  /* Add user orb — morphs from bare text into node */
  function addUserOrb(label, x, y) {
    var fr = field.getBoundingClientRect();
    var edgePad = 20;
    var estW = Math.max(label.length * 8.5 + 34, 85);
    var estH = 36;

    /* Keep near where they typed */
    x = Math.max(edgePad, Math.min(x, fr.width - estW - edgePad));
    y = Math.max(60, Math.min(y, fr.height - estH - 40));

    /* Collision check */
    var nodePad = 24;
    state.nodes.forEach(function(nd) {
      var el = nd.element;
      var nx = parseFloat(el.style.left) || 0;
      var ny = parseFloat(el.style.top) || 0;
      var nw = el.offsetWidth || 80;
      var nh = el.offsetHeight || 36;
      if (x < nx + nw + nodePad && x + estW + nodePad > nx &&
          y < ny + nh + nodePad && y + estH + nodePad > ny) {
        var ddx = (x + estW / 2) - (nx + nw / 2);
        var ddy = (y + estH / 2) - (ny + nh / 2);
        var dist = Math.hypot(ddx, ddy) || 1;
        x += (ddx / dist) * 40;
        y += (ddy / dist) * 30;
        x = Math.max(edgePad, Math.min(x, fr.width - estW - edgePad));
        y = Math.max(60, Math.min(y, fr.height - estH - 40));
      }
    });

    var el = document.createElement("div");
    el.className = "map-node user-added morphing-in";
    el.textContent = label;
    el.dataset.key = label;
    el.style.left = x + "px";
    el.style.top = y + "px";
    field.appendChild(el);

    /* After morph completes, remove animation class so normal transitions take over */
    setTimeout(function() { el.classList.remove("morphing-in"); }, 500);

    state.nodes.set(label, { element: el, label: label, weight: 1, isAI: false, isUser: true });
    el.addEventListener("pointerdown", onDragStart);
    userOrbCount++;

    /* Persist into synthesisData */
    if (state.synthesisData && state.synthesisData.themes) {
      state.synthesisData.themes.push({ label: label, weight: 1, userAdded: true });
    }
    logInteraction("user_node", { label: label });
  }

  /* Distinguish click from drag — only fire on short, non-moving taps */
  var tapStart = null;
  var tapMoved = false;

  field.addEventListener("pointerdown", function(e) {
    maybeSpawnParticles();
    tapStart = { x: e.clientX, y: e.clientY, time: Date.now() };
    tapMoved = false;
  }, true);

  field.addEventListener("pointermove", function(e) {
    if (tapStart) {
      var dx = e.clientX - tapStart.x;
      var dy = e.clientY - tapStart.y;
      if (Math.hypot(dx, dy) > 8) tapMoved = true;
    }
  }, true);

  field.addEventListener("pointerup", function(e) {
    if (!tapStart || tapMoved || Date.now() - tapStart.time > 400) {
      tapStart = null;
      return;
    }
    tapStart = null;

    /* Only open input on empty space taps */
    if (isEmptySpace(e)) {
      var rect = field.getBoundingClientRect();
      var x = e.clientX - rect.left;
      var y = e.clientY - rect.top;
      showAddInput(x, y);
    }
  }, true);

  /* Close input on escape globally */
  document.addEventListener("keydown", function(e) {
    if (e.key === "Escape") {
      removeAddInput();
    }
  });
})();


function clearMap() {
  state.nodes.forEach(nd => nd.element.remove());
  state.nodes.clear();
  state.connections.forEach(cn => { cn.line.remove(); cn.labelEl.remove(); });
  state.connections = [];
  state.wordCounts.clear();
  field.querySelectorAll(".conn-label").forEach(el => el.remove());
  field.querySelectorAll(".conn-insight").forEach(el => el.remove());
  field.querySelectorAll(".map-title").forEach(el => el.remove());
  field.querySelectorAll(".map-drag-hint").forEach(el => el.remove());
  field.querySelectorAll(".map-zone-label").forEach(el => el.remove());
  field.querySelectorAll(".map-particle").forEach(el => el.remove());
  field.querySelectorAll(".map-add-input").forEach(el => el.remove());
  field.querySelectorAll(".map-connect-hint").forEach(el => el.remove());
  field.querySelectorAll(".map-symbol").forEach(el => el.remove());
  svgLayer.innerHTML = "";
  svgLayer.style.opacity = "";
  var mb = $("map-becoming");
  if (mb) mb.style.display = "none";
}

function showMapBecoming(text) {
  var mb = $("map-becoming");
  var mbt = $("map-becoming-text");
  if (mb && mbt && text) {
    mbt.textContent = text;
    mb.style.display = "";
    mb.style.animation = "none";
    mb.offsetHeight;
    mb.style.animation = "becoming-in .8s ease .3s forwards";
    try { window.storage.set("saycrd-becoming", text); } catch(e) {}
  }
}

/* Redraw just the map visuals (nodes + connections) without touching synthesis state */
function redrawMap(data) {
  return new Promise(function(resolveAll) {
    morphOutMap().then(function() {
      clearMap();
      var fr = fieldRect();
      var themes = data.themes || [];
      var conns = data.connections || [];
      var cx = fr.width / 2, cy = fr.height * 0.55;
      var baseRadius = Math.min(fr.width, fr.height) * 0.42;
      /* Elliptical: use more horizontal space on wide screens */
      var aspect = fr.width / fr.height;
      var radiusX = aspect > 1.3 ? baseRadius * Math.min(aspect * 0.75, 1.8) : baseRadius;
      var radiusY = baseRadius;

      var sorted = themes.slice().sort(function(a, b) { return (b.weight || 1) - (a.weight || 1); });
      var connGraph = {};
      conns.forEach(function(c) {
        if (!connGraph[c.from]) connGraph[c.from] = [];
        if (!connGraph[c.to]) connGraph[c.to] = [];
        connGraph[c.from].push(c.to);
        connGraph[c.to].push(c.from);
      });

      var ordered = [];
      var placed = {};
      function placeTheme(label) {
        if (placed[label]) return;
        var t = sorted.find(function(s) { return s.label === label; });
        if (!t) return;
        placed[label] = true;
        ordered.push(t);
        (connGraph[label] || []).forEach(function(neighbor) { placeTheme(neighbor); });
      }
      sorted.forEach(function(t) { placeTheme(t.label); });

      var edgePad = 26, topPad = 72, bottomPad = 42, nodePad = 24;
      var placedPositions = [];
      ordered.forEach(function(theme, i) {
        var w = theme.weight || 1;
        var normalizedWeight = Math.min(w / 5, 1);
        var rScale = (0.3 + (1 - normalizedWeight) * 0.7);
        var angle = (i / ordered.length) * Math.PI * 2 - Math.PI / 2;
        angle += (Math.random() - 0.5) * 0.18;
        var x = cx + Math.cos(angle) * radiusX * rScale;
        var y = cy + Math.sin(angle) * radiusY * rScale;
        var estW = Math.max(theme.label.length * 8.5 + 34, 85);
        var estH = 36;
        x = Math.max(edgePad, Math.min(x, fr.width - estW - edgePad));
        y = Math.max(topPad, Math.min(y, fr.height - estH - bottomPad));

        for (var pass = 0; pass < 20; pass++) {
          var hasCollision = false;
          for (var j = 0; j < placedPositions.length; j++) {
            var p = placedPositions[j];
            if ((x < p.x + p.w + nodePad) && (x + estW + nodePad > p.x) &&
                (y < p.y + p.h + nodePad) && (y + estH + nodePad > p.y)) {
              var dx = (x + estW / 2) - (p.x + p.w / 2);
              var dy = (y + estH / 2) - (p.y + p.h / 2);
              var dist = Math.hypot(dx, dy) || 1;
              x += (dx / dist) * 32;
              y += (dy / dist) * 24;
              x = Math.max(edgePad, Math.min(x, fr.width - estW - edgePad));
              y = Math.max(topPad, Math.min(y, fr.height - estH - bottomPad));
              hasCollision = true;
            }
          }
          if (!hasCollision) break;
        }
        placedPositions.push({ x: x, y: y, w: estW, h: estH });

        var el = document.createElement("div");
        el.className = "map-node ai-placed";
        if (w >= 4) el.classList.add("heavy");
        el.textContent = theme.label;
        el.dataset.key = theme.label;
        var s = 1 + Math.min(w * 0.08, 0.4);
        el.style.transform = "scale(" + s + ")";
        el.style.left = x + "px"; el.style.top = y + "px";
        el.style.opacity = "0";
        field.appendChild(el);
        state.nodes.set(theme.label, { element: el, label: theme.label, weight: w, isAI: true });
        el.addEventListener("pointerdown", onDragStart);
        setTimeout(function() { el.style.opacity = "1"; }, 80 + i * 80);
      });

      /* Faster connection drawing */
      conns.forEach(function(conn, i) {
        setTimeout(function() {
          requestAnimationFrame(function() {
            drawConnection(conn.from, conn.to, conn.label, conn.insight);
          });
        }, 200 + i * 180);
      });

      if (data.map_title) {
        var titleEl = document.createElement("div");
        titleEl.className = "map-title";
        titleEl.textContent = data.map_title;
        field.appendChild(titleEl);
      }

      /* Resolve after all animations settle */
      var settleTime = Math.max(
        80 + ordered.length * 80 + 400,
        200 + conns.length * 180 + 400
      );
      setTimeout(function() {
        field.classList.remove("morphing");
        resolveAll();
      }, settleTime);
    });
  });
}

/* ====================================================================
   AI ENGINE — Claude API
   ==================================================================== */

/* ── API call queue — prevents concurrent requests from overwhelming the proxy ── */
var _callQueue = Promise.resolve();
var _lastCallTime = 0;

async function callClaude(systemPrompt, userMessage, maxTokens) {
  /* Queue calls so they run sequentially */
  var result;
  _callQueue = _callQueue.then(async function() {
    result = await _callClaudeInner(systemPrompt, userMessage, maxTokens);
  }).catch(function(err) {
    result = { error: err };
  });
  await _callQueue;
  if (result && result.error) throw result.error;
  return result;
}

async function _callClaudeInner(systemPrompt, userMessage, maxTokens) {
  /* Enforce minimum gap between calls */
  var now = Date.now();
  var gap = now - _lastCallTime;
  if (gap < 800) {
    await new Promise(function(r) { setTimeout(r, 800 - gap); });
  }

  /* Truncate if payload too large */
  var maxInput = 18000;
  var combinedLen = systemPrompt.length + userMessage.length;
  if (combinedLen > maxInput) {
    console.warn("Truncating: " + combinedLen + " → " + maxInput);
    userMessage = userMessage.slice(0, maxInput - systemPrompt.length);
  }

  var body = JSON.stringify({
    model: "claude-sonnet-4-20250514",
    max_tokens: maxTokens || 1000,
    messages: [
      { role: "user", content: systemPrompt + "\n\n---\n\nUser text:\n\n" + userMessage }
    ],
  });

  console.log("API call: " + body.length + " chars, max_tokens=" + (maxTokens || 1000));

  var lastErr;
  for (var attempt = 0; attempt < 3; attempt++) {
    if (attempt > 0) {
      var delay = 3000 * attempt;
      console.log("Retry " + (attempt + 1) + " in " + delay + "ms");
      await new Promise(function(r) { setTimeout(r, delay); });
    }
    _lastCallTime = Date.now();
    try {
      var response = await fetch(SAYCRD_CONFIG.API_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json", "Authorization": currentUser ? "Bearer " + (window._saycrdToken || "") : "" },
        body: body,
      });

      console.log("API:", response.status);

      if (response.status === 429) {
        lastErr = new Error("Rate limited");
        continue;
      }

      if (!response.ok) {
        var errText = "";
        try { errText = await response.text(); } catch(e) { errText = "unreadable"; }
        console.error("API " + response.status + ":", errText.slice(0, 300));
        lastErr = new Error("API " + response.status + ": " + errText.slice(0, 200));
        continue;
      }

      var responseText = await response.text();

      if (!responseText || responseText.length === 0) {
        lastErr = new Error("Empty response (attempt " + (attempt + 1) + ")");
        continue;
      }

      var data;
      try { data = JSON.parse(responseText); } catch(parseErr) {
        console.error("Bad JSON:", responseText.slice(0, 200));
        lastErr = new Error("Invalid JSON");
        continue;
      }

      if (data && data.error) {
        console.error("API error:", data.error.message || JSON.stringify(data.error).slice(0, 200));
        lastErr = new Error("API: " + (data.error.message || "unknown"));
        continue;
      }

      if (data && data.content) {
        var fullText = "";
        for (var i = 0; i < data.content.length; i++) {
          if (data.content[i].type === "text") fullText += data.content[i].text;
        }
        if (fullText) return fullText;
      }
      lastErr = new Error("No text in response");
    } catch (err) {
      console.error("Fetch error:", err.message || err);
      lastErr = err;
    }
  }
  throw lastErr;
}

function extractJSON(raw) {
  if (!raw || typeof raw !== "string") {
    throw new Error("extractJSON received empty or non-string input");
  }

  /* Try direct parse */
  try { return JSON.parse(raw); } catch(e) {}

  /* Strip markdown fences */
  var cleaned = raw.replace(/```json\s*/gi, "").replace(/```\s*/g, "").trim();
  try { return JSON.parse(cleaned); } catch(e) {}

  /* Find first { ... } block */
  var start = raw.indexOf("{");
  var end = raw.lastIndexOf("}");
  if (start !== -1 && end !== -1 && end > start) {
    try { return JSON.parse(raw.slice(start, end + 1)); } catch(e) {}
  }

  throw new Error("Could not parse JSON. Response began with: " + raw.slice(0, 120));
}

/* ── Phase 2: Synthesize (single API call does everything) ── */
/* ── Morphing transition: raw words dissolve toward center ── */
function morphOutMap() {
  return new Promise(function(resolve) {
    var fr = fieldRect();
    var cx = fr.width / 2;
    var cy = fr.height * 0.55;
    var nodes = Array.from(state.nodes.values());
    if (!nodes.length) return resolve();
    field.classList.add("morphing");
    nodes.forEach(function(nd) {
      var el = nd.element;
      var rect = el.getBoundingClientRect();
      var fx = rect.left - fr.left + rect.width / 2;
      var fy = rect.top - fr.top + rect.height / 2;
      var dx = cx - fx + (Math.random() * 24 - 12);
      var dy = cy - fy + (Math.random() * 24 - 12);
      el.style.transition = "transform 1.1s ease, opacity 1.1s ease, filter 1.1s ease";
      el.style.transform = "translate(" + dx + "px, " + dy + "px) scale(0.6)";
      el.style.opacity = "0";
    });
    setTimeout(function() {
      field.classList.remove("morphing");
      resolve();
    }, 1200);
  });
}

/* ── Render synthesis data onto map and reading ── */
/* ── Tap to Interact — inline-first ── */
var activeInlineTap = null;

function makeClarifiable(element) {
  try {
  if (!element || !element.textContent.trim()) return;
  var text = element.textContent.trim();
  var sentences = text.match(/[^.!?]+[.!?]+[\u201D\u201C\u2019\u2018"']?\s*/g);
  if (!sentences || sentences.length < 1) return;
  if (sentences.length === 1 && text.length < 30) return;

  element.innerHTML = "";
  sentences.forEach(function(sentence) {
    var span = document.createElement("span");
    span.className = "clarify-sentence";
    span.textContent = sentence;
    span.addEventListener("click", function(e) {
      e.stopPropagation();
      if (span._responded) return;
      closeActiveInline();
      openInlineInput(span, sentence.trim(), element);
    });
    element.appendChild(span);
  });
  } catch(e) { console.warn("makeClarifiable:", e); }
}

function closeActiveInline() {
  if (activeInlineTap) {
    var old = activeInlineTap;
    if (old._input) old._input.remove();
    if (old._span) old._span.classList.remove("tapped");
    activeInlineTap = null;
  }
}

function openInlineInput(spanEl, sentence, parentEl) {
  spanEl.classList.add("tapped");

  var inp = document.createElement("input");
  inp.type = "text";
  inp.className = "tap-inline";
  inp.placeholder = "say what\u2019s true\u2026";
  inp.maxLength = 200;
  inp.addEventListener("click", function(e) { e.stopPropagation(); });

  inp.addEventListener("input", function() {
    inp.style.width = Math.max(60, Math.min(inp.value.length * 8 + 20, 300)) + "px";
  });

  spanEl.after(inp);
  spanEl._input = inp;
  activeInlineTap = { _input: inp, _span: spanEl };

  requestAnimationFrame(function() { inp.focus(); });

  inp.addEventListener("keydown", function(e) {
    if (e.key === "Enter") {
      e.preventDefault();
      var val = inp.value.trim();
      if (!val) return;
      inp.disabled = true;

      var loadSpan = document.createElement("span");
      loadSpan.className = "tap-loading";
      loadSpan.textContent = " \u2026";
      inp.replaceWith(loadSpan);
      spanEl._input = null;
      activeInlineTap = null;

      processInlineResponse(spanEl, loadSpan, sentence, val, parentEl);
    }
    if (e.key === "Escape") {
      closeActiveInline();
    }
  });

  inp.addEventListener("blur", function() {
    setTimeout(function() {
      if (activeInlineTap && activeInlineTap._input === inp) {
        var val = inp.value.trim();
        if (val) {
          /* Submit on blur if there's text */
          inp.disabled = true;
          var loadSpan = document.createElement("span");
          loadSpan.className = "tap-loading";
          loadSpan.textContent = " \u2026";
          inp.replaceWith(loadSpan);
          spanEl._input = null;
          activeInlineTap = null;
          processInlineResponse(spanEl, loadSpan, sentence, val, parentEl);
        } else {
          closeActiveInline();
        }
      }
    }, 300);
  });
}

async function processInlineResponse(spanEl, loadSpan, sentence, userWords, parentEl) {
  spanEl._responded = true;

  var historyContext = "";
  try {
    var sh = await window.storage.get("saycrd-sessions").catch(function() { return null; });
    if (sh && sh.value) {
      var sessions = JSON.parse(sh.value);
      var recent = sessions.slice(-6);
      historyContext = recent.map(function(s, i) {
        var parts = ["Session " + (sessions.length - recent.length + i + 1)];
        if (s.themes) parts.push("themes: " + s.themes.map(function(t) { return t.label; }).join(", "));
        if (s.synthesis) parts.push("reading: " + s.synthesis);
        if (s.clarity) parts.push("clarity: " + s.clarity);
        return parts.join(" | ");
      }).join("\n");
    }
  } catch(e) {}

  var currentContext = "";
  if (state.synthesisData) {
    var sd = state.synthesisData;
    if (sd.themes) currentContext += "Current themes: " + sd.themes.map(function(t) { return t.label + " (" + t.weight + ")"; }).join(", ") + "\n";
    if (sd.synthesis) currentContext += "Current reading: " + sd.synthesis + "\n";
    if (sd.noticing) currentContext += "Noticing: " + sd.noticing + "\n";
  }

  var systemPrompt = 'You are the AI behind SAYCRD. The user tapped a specific line in their reading and wrote something in response.\n\n' +
    'Their session history:\n' + historyContext + '\n\n' +
    'Current session:\n' + currentContext + '\n\n' +
    'The line they tapped: "' + sentence + '"\n' +
    'What they said: "' + userWords + '"\n\n' +
    'Read what they said. It might be:\n' +
    '- Confusion ("I don\'t understand") \u2192 Explain what you meant. Be specific.\n' +
    '- Resonance ("this hit me") \u2192 Go deeper gently. Name what might be underneath.\n' +
    '- Correction ("this is wrong") \u2192 Accept it. Don\'t defend. Show you heard them.\n' +
    '- Discovery ("I think I know why...") \u2192 Hold what they said. Name it.\n' +
    '- Treasure ("I love this" / "I want to keep this" / "this is mine") \u2192 Honor it. Tell them why this line came from their patterns — it\'s not generic, it emerged from THEIR words. Affirm that it\'s theirs to carry.\n\n' +
    'Respond in 1-3 sentences. Warm. Direct. No hedging.\n\n' +
    'Respond with ONLY valid JSON: {"response":"...","type":"clarify|resonance|correction|discovery|treasure"}';

  try {
    var raw = await callClaude(systemPrompt, 'Line: "' + sentence + '"\nTheir words: "' + userWords + '"');
    var data = extractJSON(raw);

    loadSpan.remove();
    spanEl.classList.remove("tapped");

    var resp = document.createElement("span");
    resp.className = "tap-response";
    var savedLabel = data.type === "correction" ? "correction noted" : data.type === "treasure" ? "\u2661 kept" : "held";
    resp.innerHTML = '<span class="tap-response-yours">\u201C' + userWords + '\u201D</span>' +
      '<span class="tap-response-text">' + (data.response || "I hear you.") + '</span>' +
      '<span class="tap-response-saved">' + savedLabel + '</span>';
    spanEl.after(resp);

    /* If they treasured a line, save it as a kept line */
    if (data.type === "treasure" || data.type === "resonance") {
      var lower = userWords.toLowerCase();
      var isTreasure = data.type === "treasure" ||
        lower.indexOf("love") !== -1 || lower.indexOf("keep") !== -1 || lower.indexOf("remember") !== -1 ||
        lower.indexOf("beautiful") !== -1 || lower.indexOf("mine") !== -1 || lower.indexOf("take with") !== -1 ||
        lower.indexOf("needed") !== -1 || lower.indexOf("exactly") !== -1;
      if (isTreasure) {
        try {
          var kept = [];
          var keptR = await window.storage.get("saycrd-kept-lines").catch(function() { return null; });
          if (keptR && keptR.value) kept = JSON.parse(keptR.value);
          kept.push({
            date: new Date().toISOString(),
            line: sentence,
            their_words: userWords,
            session: sessionHistory.length
          });
          await window.storage.set("saycrd-kept-lines", JSON.stringify(kept));
          console.log("Kept line saved:", sentence.slice(0, 50));
        } catch(e) {}
      }
    }

    try {
      var interactions = [];
      var stored = await window.storage.get("saycrd-tap-interactions").catch(function() { return null; });
      if (stored && stored.value) interactions = JSON.parse(stored.value);
      interactions.push({
        date: new Date().toISOString(),
        line: sentence,
        user_said: userWords,
        system_said: data.response,
        type: data.type || "unknown"
      });
      await window.storage.set("saycrd-tap-interactions", JSON.stringify(interactions));
    } catch(e) {}
    logInteraction(data.type === "correction" ? "correction" : "reflection", { question: sentence, answer: userWords, type: data.type || "inline" });

    try {
      var reflections = [];
      try { var rfl = await window.storage.get("saycrd-reflections"); if (rfl && rfl.value) reflections = JSON.parse(rfl.value); } catch(e) {}
      reflections.push({
        date: new Date().toISOString(),
        question: sentence,
        response: userWords,
        type: data.type === "correction" ? "correction" : "inline"
      });
      await window.storage.set("saycrd-reflections", JSON.stringify(reflections));
    } catch(e) {}

  } catch(e) {
    loadSpan.textContent = "";
    spanEl.classList.remove("tapped");
    spanEl._responded = false;
  }
}

function renderSynthesis(data) {
  state.synthesisData = data;

  /* ── SUCK IN drifting nodes → they found their structure ── */
  var driftingNodes = field.querySelectorAll(".map-node");
  if (driftingNodes.length > 0) {
    var fr = field.getBoundingClientRect();
    var cx = fr.width / 2, cy = fr.height * 0.45;
    driftingNodes.forEach(function(el, i) {
      el.style.animation = "none";
      el.style.transition = "all 1s cubic-bezier(.55,.06,.68,.19) " + (i * 60) + "ms";
      el.style.left = (cx - 30) + "px";
      el.style.top = (cy - 12) + "px";
      el.style.opacity = "0";
      el.style.transform = "scale(.3)";
      el.style.filter = "blur(3px)";
    });
    /* Pulse center orb on absorption */
    var pulse = document.getElementById("center-pulse");
    if (pulse) {
      pulse.style.transition = "transform .5s ease, box-shadow .5s ease";
      pulse.style.transform = "scale(1.4)";
      pulse.style.boxShadow = "0 0 60px rgba(214,178,109,.6)";
      setTimeout(function() { pulse.style.transform = ""; pulse.style.boxShadow = ""; }, 600);
    }
  }

  return new Promise(function(resolve) {
    setTimeout(resolve, driftingNodes.length > 0 ? 900 : 0);
  }).then(function() {
    return morphOutMap();
  }).then(function() {
    clearMap();
    var fr = fieldRect();
    var themes = data.themes || [];
    var conns = data.connections || [];
    var cx = fr.width / 2, cy = fr.height * 0.48;
    var baseRadius = Math.min(fr.width, fr.height) * 0.38;
    /* Elliptical: spread wider on landscape/monitor screens */
    var aspect = fr.width / fr.height;
    var radiusX = aspect > 1.3 ? baseRadius * Math.min(aspect * 0.85, 2.0) : baseRadius * 1.1;
    var radiusY = baseRadius;

    /* ── Semantic positioning ──
       Heaviest themes sit closer to center (they're the gravitational core).
       Connected themes are placed adjacent in the angular sweep.
       This makes the spatial layout carry meaning. */

    /* Sort: heaviest first for center proximity */
    var sorted = themes.slice().sort(function(a, b) { return (b.weight || 1) - (a.weight || 1); });

    /* Build adjacency from connections so linked themes sit near each other */
    var connGraph = {};
    conns.forEach(function(c) {
      if (!connGraph[c.from]) connGraph[c.from] = [];
      if (!connGraph[c.to]) connGraph[c.to] = [];
      connGraph[c.from].push(c.to);
      connGraph[c.to].push(c.from);
    });

    /* Reorder for angular adjacency: walk connections to cluster linked themes */
    var ordered = [];
    var placed = {};
    function placeTheme(label) {
      if (placed[label]) return;
      var t = sorted.find(function(s) { return s.label === label; });
      if (!t) return;
      placed[label] = true;
      ordered.push(t);
      /* Place connected themes next */
      (connGraph[label] || []).forEach(function(neighbor) { placeTheme(neighbor); });
    }
    sorted.forEach(function(t) { placeTheme(t.label); });

    /* Position each theme */
    var edgePad = 32;    /* never touch field edges */
    var topPad = 72;     /* clear the map title */
    var bottomPad = 48;  /* clear the drag hint */
    var nodePad = 34;    /* gap between every node */
    var placedPositions = [];
    ordered.forEach(function(theme, i) {
      var w = theme.weight || 1;
      var normalizedWeight = Math.min(w / 5, 1);
      var rScale = (0.3 + (1 - normalizedWeight) * 0.7);
      var angle = (i / ordered.length) * Math.PI * 2 - Math.PI / 2;
      var jitter = (Math.random() - 0.5) * 0.18;
      angle += jitter;
      var x = cx + Math.cos(angle) * radiusX * rScale;
      var y = cy + Math.sin(angle) * radiusY * rScale;

      /* Estimate node dimensions */
      var estW = Math.max(theme.label.length * 8.5 + 34, 85);
      var estH = 36;

      /* Clamp to field bounds with generous padding */
      x = Math.max(edgePad, Math.min(x, fr.width - estW - edgePad));
      y = Math.max(topPad, Math.min(y, fr.height - estH - bottomPad));

      /* Resolve collisions — nudge away iteratively */
      for (var pass = 0; pass < 20; pass++) {
        var hasCollision = false;
        for (var j = 0; j < placedPositions.length; j++) {
          var p = placedPositions[j];
          var overlapX = (x < p.x + p.w + nodePad) && (x + estW + nodePad > p.x);
          var overlapY = (y < p.y + p.h + nodePad) && (y + estH + nodePad > p.y);
          if (overlapX && overlapY) {
            var dx = (x + estW / 2) - (p.x + p.w / 2);
            var dy = (y + estH / 2) - (p.y + p.h / 2);
            var dist = Math.hypot(dx, dy) || 1;
            x += (dx / dist) * 40;
            y += (dy / dist) * 32;
            x = Math.max(edgePad, Math.min(x, fr.width - estW - edgePad));
            y = Math.max(topPad, Math.min(y, fr.height - estH - bottomPad));
            hasCollision = true;
          }
        }
        if (!hasCollision) break;
      }
      placedPositions.push({ x: x, y: y, w: estW, h: estH });

      var el = document.createElement("div");
      el.className = "map-node ai-placed";
      if (w >= 4) el.classList.add("heavy");
      el.classList.add("weight-" + Math.min(Math.max(w, 1), 5));
      el.textContent = theme.label;
      el.dataset.key = theme.label;
      el.dataset.weight = w;
      var s = 1 + Math.min(w * 0.08, 0.4);
      el.style.transform = "scale(" + s + ")";
      el.style.left = x + "px"; el.style.top = y + "px";
      el.style.opacity = "0";
      field.appendChild(el);
      state.nodes.set(theme.label, { element: el, label: theme.label, weight: w, isAI: true });
      el.addEventListener("pointerdown", onDragStart);
      setTimeout(function() { el.style.opacity = "1"; }, 150 + i * 120);
    });

    var conns = data.connections || [];
    conns.forEach(function(conn, i) {
      setTimeout(function() {
        /* Ensure browser has done layout before reading node dimensions */
        requestAnimationFrame(function() {
          drawConnection(conn.from, conn.to, conn.label, conn.insight);
        });
      }, 600 + i * 320);
    });

    /* Map title */
    if (data.map_title) {
      var titleEl = document.createElement("div");
      titleEl.className = "map-title";
      titleEl.textContent = data.map_title;
      field.appendChild(titleEl);
    }

    /* Drag hint — appears briefly after map settles */
    var existingHint = field.querySelector(".map-drag-hint");
    if (existingHint) existingHint.remove();
    var hintEl = document.createElement("div");
    hintEl.className = "map-drag-hint";
    hintEl.textContent = "Drag themes near each other to link them";
    field.appendChild(hintEl);
    setTimeout(function() { hintEl.classList.add("visible"); }, 800 + conns.length * 320);

    /* Spawn interactive map particles after map settles */
    setTimeout(function() {
      if (field.querySelector(".map-particle")) return;
      var fr = field.getBoundingClientRect();
      for (var pi = 0; pi < 6; pi++) {
        var p = document.createElement("div");
        p.className = "map-particle";
        p.style.left = (20 + Math.random() * (fr.width - 40)) + "px";
        p.style.top = (60 + Math.random() * (fr.height - 120)) + "px";
        p.style.animationDelay = (Math.random() * 6) + "s";
        p.style.animationDuration = (6 + Math.random() * 5) + "s";
        field.appendChild(p);
      }
    }, 1500 + conns.length * 320);

    /* Click connection labels to explore insights */

    setTimeout(function() {
      synthLoading.style.display = "none";

      /* Store guide data for session phase */
      if (data.guide && data.guide.length > 0) {
        state.guideData = { items: data.guide };
        state.userAddedItems = [];
        if (!state.guideResponses) state.guideResponses = {};
      }

      /* ═══ START SIDEBAR VOICE ═══ */
      svGuideStart(data);

    }, 400 + conns.length * 320);
  });
}

/* ═══════════════════════════════════════════════════════════
   SIDEBAR VOICE — Guidance layer.
   The popup on the map does the work.
   The sidebar whispers what to do and tracks progress.
   Connection nodes are the session.
   ═══════════════════════════════════════════════════════════ */
var svS = { active: false, round: 0, explored: 0, total: 0, choices: {}, added: [], _discoveryShown: false, _synthesized: false };

/* ── Show content in sidebar guide (replaces previous content) ── */
function svSet(html) {
  var g = document.getElementById("sv-guide");
  if (!g) return;
  g.style.display = "block";
  g.innerHTML = html;
}

/* ── Unified sidebar render — clean surface, no analysis ── */
function svRender(whisper, extras) {
  extras = extras || {};
  var countText = svS.total > 0 ? ('<div class="sv-count">' + svS.explored + ' of ' + svS.total + ' explored</div>') : '';

  /* If extras has a reflection from digest, show it */
  var reflectHtml = extras.reflection ? '<div class="sv-added">' + extras.reflection + '</div>' : '';

  /* Button logic:
     - After synthesis done → Run Session
     - All explored + user added thoughts → Synthesize first
     - All explored + nothing added → Run Session (nothing to synthesize) */
  var actionBtn = '';
  if (svS._synthesized) {
    actionBtn = '<button class="sv-done-btn sv-run" id="sv-run-session">Run Session</button>';
  } else if (svS.explored >= svS.total && svS.added.length > 0) {
    actionBtn = '<button class="sv-done-btn sv-synth" id="sv-synthesize">Synthesize the field</button>';
  } else if (svS.explored >= svS.total && svS.added.length === 0) {
    actionBtn = '<button class="sv-done-btn sv-run" id="sv-run-session" style="opacity:.5">Run Session</button>';
  }

  svSet(
    countText +
    '<div class="sv-whisper">' + whisper + '</div>' +
    '<input type="text" id="sv-more-input" class="sv-add-input" placeholder="What else is here\u2026" maxlength="200" autocomplete="off" />' +
    '<div id="sv-added-list">' + reflectHtml + '</div>' +
    actionBtn
  );
  svBindSidebar();
}

/* ── Bind input + Synthesize + Run Session ── */
function svBindSidebar() {
  setTimeout(function() {
    var inp = document.getElementById("sv-more-input");
    if (inp) {
      inp.addEventListener("keydown", function(e) {
        if (e.key === "Enter" && inp.value.trim()) {
          e.preventDefault();
          var text = inp.value.trim();
          inp.value = "";
          inp.disabled = true;
          inp.placeholder = "Listening\u2026";
          svDigestAndGrow(text, inp);
        }
      });
    }
    var synthBtn = document.getElementById("sv-synthesize");
    if (synthBtn) {
      synthBtn.addEventListener("click", function() {
        svSynthesizeMap();
      });
    }
    var runBtn = document.getElementById("sv-run-session");
    if (runBtn) {
      runBtn.addEventListener("click", function() {
        svS.active = false;
        svSet('<div class="sv-whisper">Running your session\u2026</div>');
        setTimeout(function() {
          var enterBtn = document.getElementById("btn-enter-session");
          if (enterBtn) enterBtn.click();
        }, 600);
      });
    }
  }, 100);
}

/* ══ START — after synthesis renders the map ══ */
function svGuideStart(data) {
  svS.active = true;
  svS.round++;
  svS.added = [];
  svS.explored = 0;
  svS.total = state.connections.length;
  svS._synthesized = false;

  if (!state.connResponses) state.connResponses = {};
  synthActions.style.display = "none";

  var n = svS.total;
  var msg;
  if (svS.round === 1) {
    /* First round — use the noticing as the opening whisper if available */
    if (data && data.noticing) {
      msg = data.noticing;
    } else {
      msg = n + " connection" + (n === 1 ? "" : "s") + " appeared. Tap one to see what\u2019s between.";
    }
  } else {
    msg = "The field grew. " + n + " connection" + (n === 1 ? "" : "s") + " to explore.";
  }

  svRender(msg);
}

/* ══ NOTIFY — called FROM the popup when user responds ══
   This is the only bridge between popup and sidebar.
   Popup handles interaction. This handles consequences. */
function svNotify(keyA, keyB, value, label, insight, correction) {
  if (!svS.active) return;

  var connKey = keyA + "::" + keyB;
  svS.choices[connKey] = { from: keyA, to: keyB, label: label, insight: insight, choice: value, correction: correction || null };
  svS.explored++;

  /* Store in state for session report */
  if (!state.connResponses) state.connResponses = {};
  state.connResponses[connKey] = svS.choices[connKey];

  /* ── STRUCTURAL SHIFT — the whole field breathes ── */
  field.classList.remove("sv-shift");
  void field.offsetWidth; /* force reflow */
  field.classList.add("sv-shift");
  setTimeout(function() { field.classList.remove("sv-shift"); }, 600);

  /* ── NODE GLOW — involved nodes light up briefly ── */
  var ndA = state.nodes.get(keyA), ndB = state.nodes.get(keyB);
  if (ndA && ndA.element) { ndA.element.classList.add("sv-glow"); setTimeout(function() { ndA.element.classList.remove("sv-glow"); }, 900); }
  if (ndB && ndB.element) { ndB.element.classList.add("sv-glow"); setTimeout(function() { ndB.element.classList.remove("sv-glow"); }, 900); }

  /* ── VISUAL: Connection label state change ── */
  var connLbl = field.querySelector('.conn-label[data-from="' + keyA + '"][data-to="' + keyB + '"], .conn-label[data-from="' + keyB + '"][data-to="' + keyA + '"]');
  var connLine = field.querySelector('line.conn-line[data-from="' + keyA + '"][data-to="' + keyB + '"], line.conn-line[data-from="' + keyB + '"][data-to="' + keyA + '"]');

  if (connLbl) {
    connLbl.classList.remove("unexplored");
    connLbl.classList.add("explored");
  }

  if (value === "yes") {
    if (connLbl) connLbl.classList.add("confirmed");
    if (connLine) { connLine.classList.add("c-confirmed","c-pulse"); setTimeout(function() { connLine.classList.remove("c-pulse"); }, 1200); }
    svNudge(keyA, keyB, -0.07);
  } else if (correction) {
    /* User corrected — keep the original, add their words as annotation near the connection */
    if (connLbl) connLbl.classList.add("corrected");
    if (connLine) { connLine.classList.add("c-corrected","c-pulse"); setTimeout(function() { connLine.classList.remove("c-pulse"); }, 1200); }

    /* Create annotation element near the connection label */
    if (connLbl) {
      var annot = document.createElement("div");
      annot.className = "conn-annotation";
      annot.textContent = "\u201C" + (correction.length > 50 ? correction.slice(0,48) + "\u2026" : correction) + "\u201D";
      var lx = parseFloat(connLbl.style.left) || 0;
      var ly = parseFloat(connLbl.style.top) || 0;
      annot.style.left = lx + "px";
      annot.style.top = (ly + 28) + "px";
      annot.style.transform = "translate(-50%, 0)";
      field.appendChild(annot);
    }

    /* Store correction but DON'T overwrite connection insight — both live */
    var connObj = state.connections.find(function(c) {
      return (c.a === keyA && c.b === keyB) || (c.a === keyB && c.b === keyA);
    });
    if (connObj) {
      connObj.userCorrection = correction; /* stored alongside, not replacing */
    }
    svNudge(keyA, keyB, 0.04);
  } else {
    /* Rejected without correction */
    if (connLbl) connLbl.classList.add("rejected");
    if (connLine) connLine.classList.add("c-rejected");
    svNudge(keyA, keyB, 0.1);
  }

  /* ── UPDATE SIDEBAR — clean, no analysis ── */
  var remaining = svS.total - svS.explored;

  if (remaining > 0) {
    /* Simple prompts — rotate through */
    var prompts = [
      "Tap another connection.",
      "What\u2019s next?",
      "Keep going."
    ];
    var whisper = prompts[svS.explored % prompts.length];
    /* After half explored, suggest connecting nodes */
    if (svS.explored >= Math.ceil(svS.total / 2) && !svS._discoveryShown) {
      svS._discoveryShown = true;
      whisper = "Try highlighting two themes and see what\u2019s between them \u2014 even if they seem unrelated.";
    }
    svRender(whisper);
  } else {
    svRender("Anything else coming up?");
  }
}

/* ── Find which theme appears most in confirmed/corrected connections ── */
function svFindCentral() {
  var counts = {};
  Object.keys(svS.choices).forEach(function(k) {
    var c = svS.choices[k];
    if (c.choice === "yes" || c.correction) {
      counts[c.from] = (counts[c.from] || 0) + 1;
      counts[c.to] = (counts[c.to] || 0) + 1;
    }
  });
  var best = null, max = 0;
  Object.keys(counts).forEach(function(k) {
    if (counts[k] > max) { max = counts[k]; best = k; }
  });
  return max >= 2 ? best : null;
}

/* ── Subtly shift nodes closer or apart, with smooth line tracking ── */
function svNudge(keyA, keyB, factor) {
  var ndA = state.nodes.get(keyA), ndB = state.nodes.get(keyB);
  if (!ndA || !ndB) return;
  var ax = parseFloat(ndA.element.style.left)||0, ay = parseFloat(ndA.element.style.top)||0;
  var bx = parseFloat(ndB.element.style.left)||0, by = parseFloat(ndB.element.style.top)||0;
  var dx = bx-ax, dy = by-ay, dist = Math.hypot(dx,dy)||1, sh = dist*factor;
  ndA.element.style.transition = "left .8s ease, top .8s ease";
  ndB.element.style.transition = "left .8s ease, top .8s ease";
  ndA.element.style.left = (ax-(dx/dist)*sh/2)+"px"; ndA.element.style.top = (ay-(dy/dist)*sh/2)+"px";
  ndB.element.style.left = (bx+(dx/dist)*sh/2)+"px"; ndB.element.style.top = (by+(dy/dist)*sh/2)+"px";
  /* Track lines smoothly during the transition */
  var start = performance.now();
  function trackLines(now) {
    try { updateConnLines(keyA); updateConnLines(keyB); } catch(e) {}
    if (now - start < 850) requestAnimationFrame(trackLines);
  }
  requestAnimationFrame(trackLines);
  setTimeout(function() {
    ndA.element.style.transition = ""; ndB.element.style.transition = "";
    try { updateConnLines(keyA); updateConnLines(keyB); } catch(e) {}
  }, 900);
}

/* ══ SYNTHESIZE MAP — visible morph. Nothing destroyed. Everything refined. ══ */
async function svSynthesizeMap() {
  svSet('<div class="sv-resynth">The field is synthesizing\u2026</div>');
  field.classList.add("sv-morphing");

  /* Build full map state for AI */
  var themes = [];
  state.nodes.forEach(function(nd) {
    themes.push({ label: nd.label, weight: nd.weight || 1, userAdded: !!nd.isUser });
  });
  var connections = [];
  (state.connections || []).forEach(function(c) {
    var key = c.a + "::" + c.b;
    var choice = svS.choices[key] || svS.choices[c.b + "::" + c.a];
    connections.push({
      from: c.a, to: c.b,
      label: c.labelEl ? c.labelEl.textContent : '',
      insight: c.synthesizedInsight || '',
      userCorrection: c.userCorrection || null,
      response: choice ? choice.choice : 'unexplored'
    });
  });
  var userAdded = svS.added.join('; ');
  var rawDump = "";
  try { rawDump = (input && input.value) ? input.value.trim().slice(0, 600) : ""; } catch(e) {}

  var prompt = 'You are analyzing a constellation map that a user has been WORKING — confirming, correcting, and growing.\n\n' +
    'CURRENT THEMES: ' + themes.map(function(t) { return t.label + ' (w:' + t.weight + (t.userAdded ? ', user-added' : '') + ')'; }).join(', ') + '\n\n' +
    'CONNECTIONS AND RESPONSES:\n' + connections.map(function(c) {
      var line = c.from + ' \u2194 ' + c.to + ' (' + c.label + '): ' + c.response;
      if (c.userCorrection) line += ' \u2014 user said: "' + c.userCorrection + '"';
      return line;
    }).join('\n') + '\n\n' +
    (userAdded ? 'USER ADDED THOUGHTS: ' + userAdded + '\n\n' : '') +
    'DUMP EXCERPT: "' + rawDump + '"\n\n' +
    'Your job: SYNTHESIZE what the map now reveals. Do NOT create new themes or connections. Instead:\n\n' +
    '1. WEIGHT ADJUSTMENTS: For each existing theme, suggest new weight (1-5) based on what the user confirmed, corrected, and added. Confirmed connections make their themes heavier. Rejected connections reduce weight. User corrections and additions are highest signal.\n\n' +
    '2. REFINED INSIGHTS: For each connection that was confirmed or corrected, write a sharper 1-sentence insight that integrates the user\'s response. If they corrected something, their words ARE the new insight.\n\n' +
    '3. PATTERN: One sentence about what the overall shape of their responses reveals. What did they lean into? What did they push away? This is about the PATTERN of their map work, not the content.\n\n' +
    'Respond ONLY valid JSON:\n{"weights":{"theme label":3},"insights":{"from::to":"refined insight"},"pattern":"one sentence"}';

  try {
    var raw = await callClaude(prompt, '', 800);
    var d = extractJSON(raw);

    if (d && d.weights) {
      /* ── VISIBLE MORPH: reweight nodes ── */
      state.nodes.forEach(function(nd) {
        var newW = d.weights[nd.label];
        if (newW && newW !== nd.weight) {
          nd.weight = newW;
          var el = nd.element;
          el.classList.add("sv-reweighting");
          /* Update weight class */
          for (var w = 1; w <= 5; w++) el.classList.remove("weight-" + w);
          el.classList.add("weight-" + Math.min(Math.max(newW, 1), 5));
          el.dataset.weight = newW;
          /* Scale shift */
          var s = 1 + Math.min(newW * 0.08, 0.4);
          el.style.transform = "scale(" + s + ")";
          if (newW >= 4) el.classList.add("heavy");
          else el.classList.remove("heavy");
          setTimeout(function() { el.classList.remove("sv-reweighting"); }, 1400);
        }
      });

      /* ── VISIBLE MORPH: refine connection insights ── */
      if (d.insights) {
        Object.keys(d.insights).forEach(function(key) {
          var parts = key.split("::");
          if (parts.length < 2) return;
          var connObj = state.connections.find(function(c) {
            return (c.a === parts[0] && c.b === parts[1]) || (c.a === parts[1] && c.b === parts[0]);
          });
          if (connObj) {
            connObj.synthesizedInsight = d.insights[key];
          }
        });
      }

      /* ── VISIBLE MORPH: confirmed connections get thicker, rejected fade more ── */
      state.connections.forEach(function(c) {
        var key = c.a + "::" + c.b;
        var choice = svS.choices[key] || svS.choices[c.b + "::" + c.a];
        if (!choice) return;
        var line = field.querySelector('line.conn-line[data-from="' + c.a + '"][data-to="' + c.b + '"], line.conn-line[data-from="' + c.b + '"][data-to="' + c.a + '"]');
        if (line) {
          line.classList.add("sv-reweighting");
          if (choice.choice === "yes") {
            line.setAttribute("stroke-width", "3");
            line.setAttribute("stroke-opacity", "0.9");
          } else if (choice.correction) {
            line.setAttribute("stroke-width", "2.5");
          } else {
            line.setAttribute("stroke-width", "1");
            line.setAttribute("stroke-opacity", "0.25");
          }
          setTimeout(function() { line.classList.remove("sv-reweighting"); }, 1400);
        }
      });

      /* ── Gravitational pull: heavier nodes drift toward center ── */
      var fr = field.getBoundingClientRect();
      var centerX = fr.width / 2, centerY = fr.height * 0.48;
      state.nodes.forEach(function(nd) {
        var w = nd.weight || 1;
        if (w >= 3) {
          var el = nd.element;
          var nx = parseFloat(el.style.left) || 0;
          var ny = parseFloat(el.style.top) || 0;
          var dx = centerX - nx - (el.offsetWidth || 80) / 2;
          var dy = centerY - ny - (el.offsetHeight || 36) / 2;
          var pull = (w - 2) * 0.06; /* stronger pull for heavier */
          el.style.transition = "left 1.5s cubic-bezier(.25,.46,.45,.94), top 1.5s cubic-bezier(.25,.46,.45,.94)";
          el.style.left = (nx + dx * pull) + "px";
          el.style.top = (ny + dy * pull) + "px";
          setTimeout(function() { el.style.transition = ""; }, 1600);
        }
      });
      /* Track lines during morph */
      var mStart = performance.now();
      function trackMorph(now) {
        state.nodes.forEach(function(nd) { try { updateConnLines(nd.label); } catch(e) {} });
        if (now - mStart < 1600) requestAnimationFrame(trackMorph);
      }
      requestAnimationFrame(trackMorph);
    }

    /* ── After morph completes, show pattern + Run Session ── */
    setTimeout(function() {
      field.classList.remove("sv-morphing");
      svS._synthesized = true;
      var patternMsg = (d && d.pattern) ? d.pattern : "The field has settled.";
      svRender(patternMsg);
    }, 2000);

  } catch(e) {
    console.error("Synthesis error:", e);
    field.classList.remove("sv-morphing");
    svS._synthesized = true;
    svRender("The field has settled.");
  }
}

/* ══ DIGEST AND GROW — AI reads user's words, suggests a theme + connections, adds to map ══
   The map NEVER clears. It only grows. Confirmed nodes stay exactly where they are. */
async function svDigestAndGrow(userText, inputEl) {
  svS.added.push(userText);

  /* Build context: what's on the map now */
  var existingThemes = [];
  state.nodes.forEach(function(nd) { existingThemes.push(nd.label); });
  var existingConns = [];
  Object.keys(svS.choices).forEach(function(k) {
    var c = svS.choices[k];
    existingConns.push(c.from + " \u2194 " + c.to + " (" + c.choice + (c.correction ? ': "' + c.correction + '"' : '') + ')');
  });

  var rawDump = "";
  try { rawDump = (input && input.value) ? input.value.trim().slice(0, 400) : ""; } catch(e) {}

  var prompt = 'The user is working a constellation map of their inner landscape.\n\n' +
    'EXISTING THEMES on the map: ' + existingThemes.join(', ') + '\n' +
    'CONNECTION RESPONSES: ' + existingConns.join('; ') + '\n' +
    'ORIGINAL DUMP (excerpt): "' + rawDump + '"\n\n' +
    'The user just said something new: "' + userText + '"\n\n' +
    'Your job:\n' +
    '1. DIGEST what they said into a theme name (2-4 words, evocative, short). Do NOT just repeat their words back. Find the underlying theme. If they said "I keep putting other people first," the theme might be "Self-abandonment" or "Invisible needs."\n' +
    '2. Find 1-2 CONNECTIONS between this new theme and EXISTING themes on the map. "from" MUST be the new theme label. "to" MUST EXACTLY match an existing theme label. Each connection has a label (1-2 words naming the tension) and an insight (one sentence naming what\u2019s between them).\n' +
    '3. Write a brief REFLECTION \u2014 one sentence, max 15 words \u2014 that mirrors back what they said in sharper language. Not warm. Precise.\n\n' +
    'Respond ONLY valid JSON:\n{"theme":"2-4 word label","weight":2,"connections":[{"from":"new theme","to":"existing theme","label":"tension name","insight":"one sentence"}],"reflection":"one sentence"}';

  try {
    var raw = await callClaude(prompt, '', 500);
    var d = extractJSON(raw);

    if (!d || !d.theme) {
      svAddNodeRaw(userText.split(' ').slice(0,3).join(' '));
      svRender("Added. Tap connections to explore, or keep going.");
      return;
    }

    /* Add the theme node to the map */
    svAddNodeRaw(d.theme, d.weight || 2);

    /* Field expansion pulse */
    field.classList.remove("sv-expand");
    void field.offsetWidth;
    field.classList.add("sv-expand");
    setTimeout(function() { field.classList.remove("sv-expand"); }, 1300);

    /* Draw connections with unexplored glow */
    if (d.connections && d.connections.length > 0) {
      d.connections.forEach(function(conn, ci) {
        setTimeout(function() {
          requestAnimationFrame(function() {
            drawConnection(conn.from, conn.to, conn.label, conn.insight);
            svS.total++;
          });
        }, 400 + ci * 350);
      });

      /* Update synthesis data */
      if (state.synthesisData) {
        if (!state.synthesisData.themes) state.synthesisData.themes = [];
        state.synthesisData.themes.push({ label: d.theme, weight: d.weight || 2, userAdded: true });
        if (!state.synthesisData.connections) state.synthesisData.connections = [];
        d.connections.forEach(function(c) { state.synthesisData.connections.push(c); });
      }

      /* After connections appear, re-render with reflection + updated count */
      var newCount = d.connections.length;
      setTimeout(function() {
        var msg = newCount + " new connection" + (newCount > 1 ? "s" : "") + " to explore.";
        svRender(msg, { reflection: d.reflection || null });
      }, 500 + newCount * 350);
    } else {
      /* No connections — just re-render */
      svRender("Tap a connection or keep going.", { reflection: d.reflection || null });
    }

  } catch(e) {
    console.error("Digest error:", e);
    svAddNodeRaw(userText.split(' ').slice(0,3).join(' '));
    svRender("Added. Keep exploring.");
  }
}

/* ── Add a raw node to the map — existing nodes spread outward to make room ── */
function svAddNodeRaw(label, weight) {
  var exists = false;
  state.nodes.forEach(function(nd) { if (nd.label.toLowerCase().trim() === label.toLowerCase().trim()) exists = true; });
  if (exists) {
    state.nodes.forEach(function(nd) {
      if (nd.label.toLowerCase().trim() === label.toLowerCase().trim()) {
        nd.element.style.boxShadow = "0 0 18px rgba(165,235,220,.3)";
        setTimeout(function() { nd.element.style.boxShadow = ""; }, 1500);
      }
    });
    return;
  }
  var fr = field.getBoundingClientRect();

  /* Find a connected node to place near, or use center + outward bias */
  var cx = fr.width * (0.15 + Math.random() * 0.7), cy = fr.height * (0.12 + Math.random() * 0.6);
  var estW = Math.max(label.length * 8.5 + 34, 85), pad = 24;
  cx = Math.max(pad, Math.min(cx, fr.width - estW - pad));
  cy = Math.max(70, Math.min(cy, fr.height - 50));

  /* Push away from existing nodes */
  for (var i = 0; i < 6; i++) {
    var pushed = false;
    state.nodes.forEach(function(nd) {
      var el = nd.element, nx = parseFloat(el.style.left)||0, ny = parseFloat(el.style.top)||0;
      if (cx < nx+(el.offsetWidth||80)+28 && cx+estW+28 > nx && cy < ny+(el.offsetHeight||36)+28 && cy+36+28 > ny) {
        var dx = (cx+estW/2)-(nx+(el.offsetWidth||80)/2), dy = (cy+18)-(ny+(el.offsetHeight||36)/2);
        var dist = Math.hypot(dx,dy)||1;
        cx += (dx/dist)*45; cy += (dy/dist)*35; pushed = true;
      }
    });
    cx = Math.max(pad, Math.min(cx, fr.width - estW - pad));
    cy = Math.max(70, Math.min(cy, fr.height - 50));
    if (!pushed) break;
  }

  /* ── EXPANSION: push nearby existing nodes outward so the map grows ── */
  var newCx = cx + estW / 2, newCy = cy + 18;
  state.nodes.forEach(function(nd) {
    var el = nd.element;
    var nx = parseFloat(el.style.left)||0, ny = parseFloat(el.style.top)||0;
    var nCx = nx + (el.offsetWidth || 80) / 2, nCy = ny + (el.offsetHeight || 36) / 2;
    var dx = nCx - newCx, dy = nCy - newCy;
    var dist = Math.hypot(dx, dy);
    if (dist < 180 && dist > 5) {
      /* Push outward proportional to proximity */
      var push = (180 - dist) * 0.15;
      var newX = nx + (dx / dist) * push;
      var newY = ny + (dy / dist) * push;
      newX = Math.max(pad, Math.min(newX, fr.width - (el.offsetWidth || 80) - pad));
      newY = Math.max(70, Math.min(newY, fr.height - 50));
      el.style.transition = "left 1s cubic-bezier(.25,.46,.45,.94), top 1s cubic-bezier(.25,.46,.45,.94)";
      el.style.left = newX + "px"; el.style.top = newY + "px";
      setTimeout(function() { el.style.transition = ""; }, 1100);
    }
  });
  /* Update connection lines during expansion */
  var eStart = performance.now();
  function trackExpansion(now) {
    state.nodes.forEach(function(nd) { try { updateConnLines(nd.label); } catch(e) {} });
    if (now - eStart < 1100) requestAnimationFrame(trackExpansion);
  }
  requestAnimationFrame(trackExpansion);

  var el = document.createElement("div");
  el.className = "map-node user-added";
  el.textContent = label; el.dataset.key = label;
  el.style.left = cx + "px"; el.style.top = cy + "px";
  el.style.opacity = "0"; el.style.transform = "scale(0.5)";
  el.style.transition = "opacity .6s ease, transform .6s cubic-bezier(.25,.46,.45,.94)";
  field.appendChild(el);
  setTimeout(function() { el.style.opacity = "1"; el.style.transform = ""; }, 50);
  state.nodes.set(label, { element: el, label: label, weight: weight || 1, isAI: false, isUser: true });
  el.addEventListener("pointerdown", onDragStart);
  if (state.synthesisData && state.synthesisData.themes) {
    state.synthesisData.themes.push({ label: label, weight: weight || 1, userAdded: true });
  }
  logInteraction("user_node", { label: label, source: "sv-digest" });
  var badge = field.querySelector(".map-node-count");
  if (badge) badge.textContent = state.nodes.size + " themes";
}

/* ── Pattern detection — whispered after all explored ── */
async function svPattern() {
  var list = [];
  Object.keys(svS.choices).forEach(function(k) {
    var c = svS.choices[k];
    list.push(c.from + " \u2194 " + c.to + ": " + c.choice + (c.correction ? ' \u2014 "' + c.correction + '"' : ''));
  });
  if (list.length < 2) return;
  var rawDump = ""; try { rawDump = (input && input.value) ? input.value.trim().slice(0,300) : ""; } catch(e) {}
  try {
    var raw = await callClaude(
      'Connections:\n' + list.join('\n') + '\n\nOriginal: "' + rawDump + '"\n\n' +
      'One pattern underneath. One sentence. Precise field note.\nRespond ONLY JSON: {"pattern":"..."}', '', 300
    );
    var d = extractJSON(raw);
    if (d && d.pattern) {
      var g = document.getElementById("sv-guide");
      if (g) {
        var n = document.createElement("div");
        n.className = "sv-noticing";
        n.textContent = d.pattern;
        g.appendChild(n);
      }
    }
  } catch(e) {}
}

/* ── Reset ── */
function svReset() {
  svS.active = false; svS.round = 0; svS.explored = 0; svS.total = 0;
  svS.choices = {}; svS.added = []; svS._discoveryShown = false; svS._synthesized = false;
  var g = document.getElementById("sv-guide");
  if (g) { g.style.display = "none"; g.innerHTML = ""; }
  field.querySelectorAll(".conn-label.unexplored,.conn-label.explored,.conn-label.confirmed,.conn-label.corrected,.conn-label.rejected").forEach(function(el) {
    el.classList.remove("unexplored","explored","confirmed","corrected","rejected");
  });
  field.querySelectorAll(".conn-line.c-confirmed,.conn-line.c-rejected,.conn-line.c-corrected,.conn-line.c-pulse").forEach(function(el) {
    el.classList.remove("c-confirmed","c-rejected","c-corrected","c-pulse");
  });
  field.querySelectorAll(".conn-annotation").forEach(function(el) { el.remove(); });
}

async function runSynthesis() {
  const rawText = input.value.trim();
  if (rawText.length < 40) return;
  /* Guard against double-click */
  if (state._synthesizing) return;
  /* Guard against locked session — just show the phase */
  if (state.sessionLocked) { setPhase(2); return; }
  /* Guard against re-running if already synthesized — just show the phase */
  if (state.synthesisData && svS && svS.active) {
    setPhase(2);
    return;
  }
  state._synthesizing = true;

  setPhase(2);
  synthLoading.style.display = "";
  synthActions.style.display = "none";
  field.classList.add("synthesizing");

  /* Nodes stay visible while AI thinks — just fade connections and disable interaction */
  (function() {
    var svg = document.getElementById("connections-svg");
    if (svg) { svg.style.transition = "opacity .6s ease"; svg.style.opacity = "0"; }
    state.nodes.forEach(function(nd) {
      var el = nd.element;
      if (!el) return;
      el.style.pointerEvents = "none";
      el.style.cursor = "default";
      el.style.transition = "opacity .8s ease";
      el.style.opacity = "0.45";
    });
  })();

  /* Load previous session context — fully defensive */
  var prevContext = "";
  var corrections = "";
  try {
    var sh = await window.storage.get("saycrd-sessions").catch(function() { return null; });
    if (sh && sh.value) {
      var sessions = JSON.parse(sh.value);
      if (sessions.length > 0) {
        var prev = sessions[sessions.length - 1];
        var parts = [];
        if (prev.synthesis) parts.push("Last reading: " + prev.synthesis);
        if (prev.guide && prev.guide.length) {
          parts.push("Last guide: " + prev.guide.map(function(g) { return g.type + ": " + (g.text || g.prompt || g.action || ""); }).join("; "));
        }
        if (prev.guideResponses && Object.keys(prev.guideResponses).length > 0) {
          var grParts = [];
          Object.keys(prev.guideResponses).forEach(function(k) {
            var gr = prev.guideResponses[k];
            if (gr && gr.answer) {
              var grMsg = "To \"" + (gr.question || gr.type) + "\" they said: \"" + gr.answer + "\"";
              if (gr.echo) grMsg += " (The system echoed: \"" + gr.echo + "\")";
              grParts.push(grMsg);
            }
          });
          if (grParts.length) parts.push("Their guide responses: " + grParts.join(". "));
        }
        if (prev.clarity) parts.push("Their clarity statement: \"" + prev.clarity + "\"");
        if (prev.noticing) parts.push("Last noticing: " + prev.noticing);
        if (prev.resonance && Object.keys(prev.resonance).length > 0) {
          var resParts = [];
          Object.keys(prev.resonance).forEach(function(key) {
            var r = prev.resonance[key];
            var detail = r.label ? ("\"" + r.label + "\"") : key;
            if (r.value === "no" || r.value === "partly") {
              var msg = "They said " + (r.value === "no" ? "\"not quite\"" : "\"partly\"") + " to connection " + detail;
              if (r.correction) msg += " — their correction: \"" + r.correction + "\"";
              resParts.push(msg);
            }
          });
          if (resParts.length) parts.push("Connection feedback: " + resParts.join(". "));
        }
        /* Previous raw words — shows their actual language last time */
        if (prev.rawDump) parts.push("Their actual words last session (excerpt): \"" + prev.rawDump.slice(0, 300) + "\"");
        /* What they added to the map — what AI missed */
        if (prev.mapBehavior && prev.mapBehavior.userNodes && prev.mapBehavior.userNodes.length > 0) {
          parts.push("Themes THEY added to the map (AI missed these): " + prev.mapBehavior.userNodes.join(", "));
        }
        /* Map work — how they shaped the constellation */
        if (prev.mapWork && prev.mapWork.choices) {
          var mwParts = [];
          Object.keys(prev.mapWork.choices).forEach(function(k) {
            var c = prev.mapWork.choices[k];
            if (c.choice === "yes") mwParts.push("Confirmed: " + c.from + " \u2194 " + c.to);
            else if (c.correction) mwParts.push('Corrected ' + c.from + " \u2194 " + c.to + ' to: "' + c.correction + '"');
          });
          if (mwParts.length) parts.push("Map work last session: " + mwParts.join(". "));
          if (prev.mapWork.added && prev.mapWork.added.length) {
            parts.push("Thoughts they added during map work: " + prev.mapWork.added.join(", "));
          }
        }
        /* What guide items they skipped */
        if (prev.guide) {
          var skipped = prev.guide.filter(function(g) { return g.skipped && g.type !== "yours"; });
          if (skipped.length > 0) {
            parts.push("Guide items they skipped (didn't engage with): " + skipped.map(function(g) { return g.type + ": " + g.text; }).join("; "));
          }
        }
        if (parts.length) prevContext = parts.join("\n");
      }
    }
  } catch(e) { console.log("Context load skipped:", e); }

  try {
    var rfl = await window.storage.get("saycrd-reflections").catch(function() { return null; });
    if (rfl && rfl.value) {
      var refs = JSON.parse(rfl.value).filter(function(r) { return r.type === "correction"; });
      if (refs.length > 0) {
        corrections = refs.map(function(r) { return r.response; }).slice(-3).join("; ");
      }
    }
  } catch(e) {}

  var contextBlock = "";

  /* ══ BEHAVIORAL INTELLIGENCE — learned weighting from past sessions ══ */
  var landscape = "";
  try {
    /* Co-occurrence: which theme pairs keep appearing together */
    var coData = {};
    try { var coR = await window.storage.get("saycrd-cooccurrence"); if (coR && coR.value) coData = JSON.parse(coR.value); } catch(e) {}
    var strongPairs = Object.entries(coData).filter(function(e) { return e[1] >= 2; })
      .sort(function(a, b) { return b[1] - a[1]; }).slice(0, 6);

    /* Recurring themes from DB if available */
    var recurringThemes = [];
    if (currentUser && currentUser.id !== "local-user" && supabaseAvailable) {
      try {
        var recurResult = await sbClient.rpc("get_recurring_themes", { uid: currentUser.id });
        if (recurResult.data) recurringThemes = recurResult.data;
      } catch(e) {}
    }

    /* Held/kept lines — what landed deepest */
    var keptSignals = [];
    try { var kpt = await window.storage.get("saycrd-kept-lines"); if (kpt && kpt.value) keptSignals = JSON.parse(kpt.value); } catch(e) {}

    /* High-engagement themes — what they actually interacted with */
    var engagedThemes = {};
    sessionHistory.forEach(function(s) {
      if (s.nodeEngagement) {
        Object.keys(s.nodeEngagement).forEach(function(k) {
          engagedThemes[k] = (engagedThemes[k] || 0) + s.nodeEngagement[k];
        });
      }
    });
    var topEngaged = null; /* computed after map work data is added */

    /* User-added themes — what AI missed that they corrected */
    var userAdded = [];
    sessionHistory.forEach(function(s) {
      if (s.mapBehavior && s.mapBehavior.userNodes) {
        s.mapBehavior.userNodes.forEach(function(n) {
          if (userAdded.indexOf(n) === -1) userAdded.push(n);
        });
      }
      /* Also capture thoughts added during map work */
      if (s.mapWork && s.mapWork.added) {
        s.mapWork.added.forEach(function(n) {
          if (userAdded.indexOf(n) === -1) userAdded.push(n);
        });
      }
      /* Map work confirmations/corrections boost theme engagement */
      if (s.mapWork && s.mapWork.choices) {
        Object.keys(s.mapWork.choices).forEach(function(k) {
          var c = s.mapWork.choices[k];
          if (c.choice === "yes" || c.correction) {
            engagedThemes[c.from] = (engagedThemes[c.from] || 0) + 2;
            engagedThemes[c.to] = (engagedThemes[c.to] || 0) + 2;
          }
        });
      }
    });
    topEngaged = Object.entries(engagedThemes).sort(function(a, b) { return b[1] - a[1]; }).slice(0, 5);

    /* Personal ontology — core forces and tensions */
    var ontology = null;
    try {
      var ontR = await window.storage.get("saycrd-ontology");
      if (ontR && ontR.value) ontology = JSON.parse(ontR.value);
    } catch(e) {}

    /* Build the landscape block */
    var parts = [];

    if (ontology && ontology.core_forces && ontology.core_forces.length > 0) {
      parts.push("CORE FORCES (this person's stable inner architecture — refined over " + (ontology.session_count || "multiple") + " sessions):\n" +
        ontology.core_forces.map(function(f) {
          return "  • " + f.name + " (weight:" + f.weight + ", last session: " + (f.active ? "active" : "dormant") + ")";
        }).join("\n"));
      if (ontology.tensions && ontology.tensions.length > 0) {
        parts.push("CORE TENSIONS (recurring friction between forces):\n" +
          ontology.tensions.map(function(t) {
            return "  • " + t.a + " ↔ " + t.b + ": " + t.nature;
          }).join("\n"));
      }
    }

    if (recurringThemes.length > 0) {
      parts.push("RECURRING FORCES (themes across " + recurringThemes.length + "+ sessions): " +
        recurringThemes.slice(0, 6).map(function(t) {
          return t.label + " (" + t.frequency + " sessions, avg weight " + (parseFloat(t.avg_weight) || 0).toFixed(1) + ")";
        }).join(", "));
    }
    if (strongPairs.length > 0) {
      parts.push("STRUCTURAL TENSIONS (theme pairs that keep co-occurring): " +
        strongPairs.map(function(p) { return p[0] + " (" + p[1] + "x)"; }).join(", "));
    }
    if (topEngaged.length > 0) {
      parts.push("HIGH-ENGAGEMENT THEMES (what they actually spent time with): " +
        topEngaged.map(function(e) { return e[0] + " (" + e[1] + "x engaged)"; }).join(", "));
    }
    if (userAdded.length > 0) {
      parts.push("THEMES THEY ADDED (AI missed these — they matter): " + userAdded.join(", "));
    }
    if (keptSignals.length > 0) {
      parts.push("LINES THEY KEPT (deepest resonance): " +
        keptSignals.slice(-3).map(function(k) { return '"' + k.line.slice(0, 80) + '"'; }).join("; "));
    }

    /* Held sections — what they paused on (long-press) */
    var heldSignals = [];
    try { var hld = await window.storage.get("saycrd-holds"); if (hld && hld.value) heldSignals = JSON.parse(hld.value); } catch(e) {}
    if (heldSignals.length > 0) {
      parts.push("HELD SECTIONS (they paused on these — high signal): " +
        heldSignals.slice(-4).map(function(h) { return '"' + (h.preview || h.section || "").slice(0, 60) + '"'; }).join("; "));
    }

    if (parts.length > 0) {
      landscape = '\nPERSONAL LANDSCAPE — behavioral truth from ' + sessionHistory.length + ' previous sessions:\n' +
        parts.join("\n") +
        '\n\nHOW TO USE THIS: If a recurring force appears in their dump, weight it higher — it\'s structurally important to them, not just a passing mention. If a structural tension pair shows up, the connection between those themes is deep and worth naming. If they\'ve added a theme before that AI missed, watch for it. If a recurring force is ABSENT from this dump, that absence might be significant — but don\'t force it in. The dump is still primary. This data shapes your interpretation, not your invention.\n\n';
    }
  } catch(e) { console.warn("Landscape load skipped:", e); }

  /* Load user model for returning users */
  var synthUserModel = "";
  try { var sumR = await window.storage.get("saycrd-user-model"); if (sumR && sumR.value) synthUserModel = sumR.value; } catch(e) {}
  if (synthUserModel) {
    contextBlock += '\n\nSYSTEM MEMORY — what the system has learned about this person from previous sessions:\n' + synthUserModel + '\n\nUse this to inform your reading. Don\'t reference it directly — just let it shape how you interpret their words. If they\'re working on something the model mentions, recognize it. If they\'re contradicting it, note the shift.\n\n';
  }

  if (landscape) {
    contextBlock += landscape;
    state._landscape = landscape; /* Save for re-synthesis */
  }

  if (prevContext) {
    contextBlock += 'PREVIOUS SESSION CONTEXT:\n' + prevContext + '\n\nRead their words in the context of their journey, not in isolation. The previous session matters — if they are acting on previous guidance, recognize it.\n\nCRITICAL: Distinguish between INTENTION and ACTION. If someone said "I will do X" or "I want to do X," that is a stated intention — NOT a completed action. Do not say "you did X" unless they explicitly confirm they did it. Saying "I need to talk to her" is not the same as having talked to her. Honor this difference. Intentions are meaningful in themselves — name them as intentions, not accomplishments.\n\n';
  }
  if (corrections) {
    contextBlock += 'The user has previously corrected the system on these points: ' + corrections + '. Do not repeat these mistakes.\n\n';
  }

  /* ── ANTI-REPETITION: feed previous readings so we don't say the same thing ── */
  var prevReadings = [];
  sessionHistory.slice(-3).forEach(function(s) {
    if (s.synthesis) prevReadings.push(s.synthesis.slice(0, 150));
  });
  if (prevReadings.length > 0) {
    contextBlock += 'PREVIOUS READINGS (DO NOT REPEAT — find what is NEW):\n' +
      prevReadings.map(function(r, i) { return '  Session ' + (sessionHistory.length - prevReadings.length + i + 1) + ': "' + r + '"'; }).join('\n') +
      '\n\nYou have already said these things. Your reading MUST say something these did not. Different structure. Different observation. Different sentence openings. If you catch yourself writing "You\'re navigating..." or "There\'s a tension between..." or "Something in you..." — stop and find a harder, more specific truth.\n\n';
  }

  var systemPrompt = 'You are the AI engine behind SAYCRD, a reflective clarity tool. The user has written a stream-of-consciousness dump. Do ALL of the following in one response:\n\n' +
    '1. THEMES: Extract 4-7 core themes from their words. CRITICAL: themes should capture WHAT THEY ARE ACTUALLY DOING AND FEELING, not just abstract concepts. If they mention specific activities (exercise, cooking, self-care, work tasks, creative projects), those ARE themes — name them. "Morning runs" is a valid theme. "Feeding myself well" is a valid theme. "Holding space for others" is a valid theme. Each is a short evocative label (2-5 words max) with a weight from 1-5. Weight is based on: (a) emotional energy in the dump — what they spent the most words on, (b) repetition, AND (c) if a PERSONAL LANDSCAPE is provided, structural importance from past sessions. If they listed several activities, group them into meaningful clusters but DON\'T collapse everything into one vague label like "self-care" — be specific about WHAT KIND. The dump is primary — never invent themes not present in their words.\n' +
    '2. CONNECTIONS: Identify 2-4 connections between themes. CRITICAL: "from" and "to" must use the EXACT theme label text from your themes array — same capitalization, same words. Each has a short label (1-2 words like "avoidance", "grief", "performing") and a one-sentence insight that names the deeper pattern between them. Focus on real TENSION — where two themes pull against each other, not just coexist. Name the friction. If the PERSONAL LANDSCAPE shows structural tensions (theme pairs that recur), and both themes are present in this dump, that connection is deeply significant — name what it means NOW, not just that it exists.\n' +
    '3. SYNTHESIS: Write a 3-sentence reading of what is HERE, right now. (1) Name what is present — use their actual language. (2) Name the connection underneath that they may not see. (3) One sentence that reflects the truth back without solving it. VOICE: You are an observer describing a landscape, not a therapist. No "you\'re navigating" or "something in you knows" or "there\'s a tension between." Just say what you see. Plain language. Specific to their words — if this reading could apply to anyone, it\'s too generic. Anchor every sentence to something they actually wrote.\n' +
    '   CONFIDENCE RULES: Scale your certainty to what they actually gave you. Short dump (under 100 words) = be CURIOUS, not declarative. Say "something about X" not "you are X." Never use "obviously" or "clearly." Never say someone is "avoiding" or "performing" unless they literally said so. Do NOT invent emotional states — if they mentioned something casually, treat it as casual. Do not dramatize. If they wrote one sentence, your reading should be tentative and wondering, not a full psychological profile.\n' +
    '4. GUIDE: Generate 3-4 guidance items that are DIRECTLY DERIVED from specific themes or connections on the map. Each item MUST reference the theme or tension it comes from. Each must be SHORT (max 15 words), direct, and psychologically activating — not tactical tasks. Each must be one of these EXACT types:\n' +
    '   - "do" — One specific move in the next 24 hours. Start with a verb. Tied to a theme.\n' +
    '   - "notice" — One signal to watch for. Body-based or pattern-based. Tied to a theme.\n' +
    '   - "ask" — One question to ask yourself — the one you are avoiding. Tied to a tension/connection.\n' +
    '   - "release" — Name what to let go of. Specific. Tied to a tension/connection.\n' +
    '   Each guide item MUST include "source" — the exact theme label OR two theme labels (for tensions) that this guidance derives from. The guidance should mirror the pattern, not just give advice.\n' +
    '5. MAP_TITLE: Give this map a poetic name — 3-8 words that capture the shape of what is present. Not a summary. A reading of the terrain.\n' +
    '6. NOTICING: One short observation about something underneath. VOICE: Spare. Almost clinical. Like a field note. Not warm — just precise. "The word \'fine\' appeared three times. Each time it replaced something harder." or "Career is loud today. The body is silent." Maximum 2 sentences. This should sound NOTHING like the synthesis reading — different register entirely. If a PERSONAL LANDSCAPE is provided, notice when a recurring force shows up differently, or when something usually dominant goes quiet. NEVER fabricate significance — if they mentioned something briefly, notice that it was brief, don\'t invent weight it didn\'t carry.\n\n' +
    contextBlock +
    'Respond with ONLY valid JSON, no other text, no markdown:\n' +
    '{"themes":[{"label":"...","weight":1}],"connections":[{"from":"label","to":"label","label":"...","insight":"..."}],"synthesis":"...","guide":[{"type":"do","text":"...","source":"theme label or theme1 + theme2"}],"map_title":"...","noticing":"..."}';

  try {
    const raw = await callClaude(systemPrompt, rawText, 2000);
    const data = extractJSON(raw);
    await renderSynthesis(data);
  } catch (err) {
    synthLoading.style.display = "none";
    var errMsg = (err && err.message) ? err.message : String(err);
    console.error("Synthesis error:", errMsg);
    const errWrap = document.createElement("div");
    errWrap.className = "error-msg";
    errWrap.innerHTML = "The AI connection hiccupped. This happens sometimes — try again." +
      '<div style="font-size:.78rem;opacity:.3;margin-top:.6rem;word-break:break-word">' + errMsg.slice(0, 150) + '</div>';
    var retryBtn = document.createElement("button");
    retryBtn.className = "cta";
    retryBtn.style.cssText = "margin-top:.8rem;font-size:.82rem;padding:.6rem 1.4rem";
    retryBtn.textContent = "Try again";
    retryBtn.addEventListener("click", function() {
      synthContent.innerHTML = "";
      synthContent.appendChild(synthLoading);
      synthLoading.style.display = "";
      synthActions.style.display = "none";
      setPhase(1);
      setTimeout(runSynthesis, 300);
    });
    errWrap.appendChild(retryBtn);
    synthContent.appendChild(errWrap);
    synthActions.style.display = "";
    console.error("Synthesis error:", err);
  }

  field.classList.remove("synthesizing");
  state._synthesizing = false;
}

/* Guide is now rendered inline within synthesis — no separate phase */
function runGuide() { return; }

/* ── Session locking — browse but don't re-run ── */
function lockSession() {
  /* Make textarea read-only */
  if (input) { input.readOnly = true; input.style.opacity = ".6"; }
  /* Hide helper text */
  if (dumpHelper) dumpHelper.style.display = "none";
  /* Hide action buttons in phases 1-2 only — keep Session and Growing nav visible */
  document.querySelectorAll(".demo-actions").forEach(function(el) {
    if (el.id !== "phase4-actions" && el.id !== "session-actions") el.style.display = "none";
  });
  /* Show a subtle "session complete" indicator on dump phase */
  var existing = document.getElementById("session-locked-msg");
  if (!existing) {
    var msg = document.createElement("div");
    msg.id = "session-locked-msg";
    msg.style.cssText = "text-align:center;padding:.8rem;font-family:var(--mono);font-size:.78rem;color:rgba(214,178,109,.4);letter-spacing:.1em;text-transform:uppercase";
    msg.textContent = "\u2713 Session saved";
    var panel1 = document.querySelector('[data-panel="1"]');
    if (panel1) panel1.appendChild(msg);
  }
}

function unlockSession() {
  state.sessionLocked = false;
  if (input) { input.readOnly = false; input.style.opacity = ""; }
  if (dumpHelper) dumpHelper.style.display = "";
  document.querySelectorAll(".demo-actions").forEach(function(el) {
    el.style.display = "";
  });
  var lockMsg = document.getElementById("session-locked-msg");
  if (lockMsg) lockMsg.remove();
  /* Re-hide actions that should start hidden */
  if (synthActions) synthActions.style.display = "none";
  if (guideActions) guideActions.style.display = "none";
}

function resetAll() {
  console.log("resetAll called, current phase:", state.phase);

  /* Unlock session first */
  unlockSession();

  /* Clear map */
  try { clearMap(); } catch(e) { console.warn("clearMap error:", e); }
  /* Clear sidebar voice */
  try { svReset(); } catch(e) {}

  /* Clear input */
  if (input) { input.value = ""; input.style.height = ""; }
  if (aiReply) aiReply.innerHTML = "&ldquo;I&rsquo;m here. Say what&rsquo;s real.&rdquo;";
  if (dumpHelper) dumpHelper.textContent = "Keep going. The map is listening.";
  if (btnSynth) btnSynth.disabled = true;

  /* Clear synthesis panel */
  if (synthContent) { synthContent.innerHTML = ""; if (synthLoading) synthContent.appendChild(synthLoading); }
  if (synthLoading) synthLoading.style.display = "";
  if (synthActions) synthActions.style.display = "none";

  /* Clear guide panel */
  if (guideContent) { guideContent.innerHTML = ""; if (guideLoading) guideContent.appendChild(guideLoading); }
  if (guideLoading) guideLoading.style.display = "";
  if (guideActions) guideActions.style.display = "none";

  /* Clear all state */
  state.synthesisData = null;
  state.guideData = null;
  state.userAddedItems = [];
  state.currentSession = null;
  state.maxPhase = 1;
  state.resonance = {};
  state.guideResponses = {};
  state.nodeEngagement = {};
  state._synthesizing = false;
  state._guideBuilt = false;
  state._landscape = null;
  state.growthData = null;
  state._drag = null;

  /* Reset all view containers */
  if (noticingSection) noticingSection.style.display = "none";
  if (growingViewer) growingViewer.style.display = "none";
  if (sessionCardEl) {
    sessionCardEl.style.cssText = "";
  }
  if (phase4Actions) phase4Actions.style.display = "";

  /* Clear session-card content */
  var st = document.getElementById("session-themes");
  var ss = document.getElementById("session-synthesis");
  var sg = document.getElementById("session-guide");
  if (st) st.innerHTML = "";
  if (ss) ss.innerHTML = "";
  if (sg) sg.innerHTML = "";

  /* Remove any lingering overlays */
  document.querySelectorAll(".takeaway-overlay, .conn-insight").forEach(function(el) { el.remove(); });

  /* Set phase and scroll to top */
  setPhase(1);
  window.scrollTo(0, 0);
  var demoCopy = document.querySelector(".demo-copy");
  if (demoCopy) demoCopy.scrollTop = 0;

  /* Focus input after brief delay */
  setTimeout(function() {
    if (input) input.focus();
  }, 100);

  /* Update session counter */
  var counter = $("session-counter");
  if (counter) {
    counter.textContent = "Session " + (sessionHistory.length + 1);
    counter.style.display = "";
  }

  console.log("resetAll complete — phase:", state.phase, "maxPhase:", state.maxPhase);
}

/* ── Button wiring ── */
btnSynth?.addEventListener("click", runSynthesis);
btnGuide?.addEventListener("click", runGuide);
btnBackDump?.addEventListener("click", () => setPhase(1));
btnReset?.addEventListener("click", resetAll);
btnRestart?.addEventListener("click", resetAll);

const btnNewSession = $("btn-new-session");
btnNewSession?.addEventListener("click", resetAll);

/* ── View switching (home ↔ workspace) ── */
function switchView(view) {
  if (view === "workspace") {
    document.body.classList.add("workspace");
    window.scrollTo(0, 0);
    var main = document.querySelector("main");
    var demoField = $("demo-field");
    if (demoField && demoField.parentElement.classList.contains("demo")) {
      main.appendChild(demoField);
    }
    /* Show session count */
    (async function() {
      try {
        await loadHistory();
        var counter = $("session-counter");
        var n = sessionHistory.length;
        if (counter) {
          counter.textContent = n === 0 ? "Session 1" : "Session " + (n + 1);
          counter.style.display = "";
        }

        /* ══ RE-ENTRY — clean door, system remembers inside ══ */
        if (n > 0 && aiReply) {
          var prev = sessionHistory[n - 1];

          /* The greeting is always the same clean invitation */
          aiReply.innerHTML = '\u201CI\u2019m here. Say what\u2019s real.\u201D';

          /* ── GUIDE ACCOUNTABILITY — track silently for synthesis/growing ── */
          try {
            var tracker = {};
            try { var tr = await window.storage.get("saycrd-guide-tracker"); if (tr && tr.value) tracker = JSON.parse(tr.value); } catch(e) {}

            /* Save last session's guide items if not tracked yet */
            var lastKey = "s" + n;
            if (!tracker[lastKey] && prev.guide) {
              tracker[lastKey] = prev.guide.map(function(g, gi) {
                var responded = prev.guideResponses && prev.guideResponses[gi] && prev.guideResponses[gi].answer;
                return {
                  type: g.type,
                  text: g.text || g.prompt || g.action || "",
                  status: responded ? "responded" : "given",
                  session: n,
                  date: prev.date
                };
              });
              await window.storage.set("saycrd-guide-tracker", JSON.stringify(tracker));
            }
          } catch(e) { console.warn("Guide tracker:", e); }
        }
      } catch(e) { console.warn("Re-entry hook:", e); }
    })();
    input?.focus();
  } else {
    document.body.classList.remove("workspace");
    var demo = document.querySelector(".demo");
    var demoField = $("demo-field");
    if (demoField && demo && !demo.contains(demoField)) {
      demo.appendChild(demoField);
    }
  }
}
window.switchView = switchView;

/* Workspace nav */
$("ws-nav-growing")?.addEventListener("click", function() {
  try { loadHistory(); } catch(e) {}
  if (sessionHistory.length < 2) { seedDemoSessions(); }
  else { renderGrowing(); }
  setPhase(4);
  growingViewer.style.display = "";
  phase4Actions.style.display = "";
});

$("ws-new-session")?.addEventListener("click", function() {
  console.log("ws-new-session clicked, phase:", state.phase);
  try { resetAll(); } catch(e) { console.error("resetAll error:", e); }
});

/* Long-press removed — using visible Clear history link */
$("ws-clear-history")?.addEventListener("click", function() {
  if (!confirm("Clear all session history and start completely fresh?")) return;
  var keys = ["saycrd-sessions","saycrd-holds","saycrd-highlights","saycrd-resonance","saycrd-reflections","saycrd-tap-interactions","saycrd-readings","saycrd-cooccurrence","saycrd-user-model","saycrd-kept-lines","saycrd-ontology"];
  Promise.all(keys.map(function(k) { return window.storage.delete(k).catch(function(){}); })).then(function() {
    location.reload();
  });
});

/* Check hash on load */
if (window.location.hash === "#workspace") switchView("workspace");

/* ── Session History Viewer ── */
$("ws-nav-history")?.addEventListener("click", function() {
  try { loadHistory(); } catch(e) {}
  openHistoryViewer();
});

function openHistoryViewer() {
  var existing = document.querySelector(".history-overlay");
  if (existing) existing.remove();

  var overlay = document.createElement("div");
  overlay.className = "history-overlay";

  /* Header */
  var header = document.createElement("div");
  header.className = "history-header";
  var title = document.createElement("div");
  title.className = "history-title";
  title.textContent = "Your Sessions";
  var closeBtn = document.createElement("button");
  closeBtn.className = "history-close";
  closeBtn.textContent = "\u00D7 Close";
  closeBtn.addEventListener("click", function() { overlay.remove(); });
  header.append(title, closeBtn);
  overlay.appendChild(header);

  /* List */
  var list = document.createElement("div");
  list.className = "history-list";

  if (sessionHistory.length === 0) {
    list.innerHTML = '<div style="text-align:center;padding:3rem 1rem;color:var(--ink-soft);font-family:var(--mono);font-size:.9rem;opacity:.5">No sessions yet. Complete your first session to see it here.</div>';
  } else {
    var reversed = sessionHistory.slice().reverse();
    reversed.forEach(function(session, reverseIdx) {
      var sessionNum = sessionHistory.length - reverseIdx;
      var card = document.createElement("div");
      card.className = "history-card";
      card.style.cursor = "pointer";

      /* Date + time */
      var d = new Date(session.date);
      var dateStr = d.toLocaleDateString("en-US", { weekday: "short", month: "short", day: "numeric", year: "numeric" });
      var timeStr = d.toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit" });

      var head = document.createElement("div");
      head.style.cssText = "padding:1.1rem 1.3rem .5rem";

      var topRow = document.createElement("div");
      topRow.style.cssText = "display:flex;align-items:center;justify-content:space-between;margin-bottom:.4rem";
      var sessionLabel = document.createElement("div");
      sessionLabel.style.cssText = "font-family:var(--mono);font-size:.75rem;letter-spacing:.1em;color:var(--accent);opacity:.6;text-transform:uppercase";
      sessionLabel.textContent = "Session " + sessionNum;
      var dateTimeEl = document.createElement("div");
      dateTimeEl.style.cssText = "font-family:var(--mono);font-size:.75rem;color:var(--ink-soft);opacity:.45;letter-spacing:.03em";
      dateTimeEl.textContent = dateStr + " \u00B7 " + timeStr;
      topRow.append(sessionLabel, dateTimeEl);

      /* Map title */
      var titleEl = document.createElement("div");
      titleEl.style.cssText = "font-family:'Fraunces',serif;font-size:1.15rem;color:var(--ink);font-weight:300;line-height:1.45;margin-bottom:.35rem";
      titleEl.textContent = session.map_title || "Untitled session";

      /* Takeaway — clarity statement or first line of reading */
      var takeaway = session.clarity || (session.synthesis ? session.synthesis.split(".")[0] + "." : "");
      var takeawayEl = document.createElement("div");
      takeawayEl.style.cssText = "font-family:'Fraunces',serif;font-size:.92rem;color:var(--ink-soft);opacity:.5;line-height:1.5;font-style:italic;padding-bottom:1rem";
      if (session.clarity) {
        takeawayEl.textContent = "\u201C" + takeaway + "\u201D";
      } else {
        takeawayEl.textContent = takeaway;
      }

      head.append(topRow, titleEl, takeawayEl);
      card.appendChild(head);

      /* Click opens the full infographic */
      card.addEventListener("click", function() {
        /* Build a synthesisData-compatible object from session */
        var fakeSD = {
          themes: session.themes || [],
          connections: session.connections || [],
          synthesis: session.synthesis || session.original_synthesis || "",
          guide: session.guide || [],
          map_title: session.map_title || "",
          noticing: session.noticing || ""
        };
        var fakeSR = {
          synthesisData: fakeSD,
          growthData: null,
          portraitData: null,
          date: session.date,
          sessionCount: sessionNum
        };
        overlay.remove();
        generateTakeawayCard(fakeSR);
      });

      list.appendChild(card);
    });
  }

  overlay.appendChild(list);
  document.body.appendChild(overlay);

  function onEsc(e) { if (e.key === "Escape") { overlay.remove(); document.removeEventListener("keydown", onEsc); } }
  document.addEventListener("keydown", onEsc);
}

/* ── Press-and-hold resonance gesture ── */
(function() {
  var holdTimer = null;
  var holdTarget = null;
  var HOLD_MS = 600;

  function findSection(el) {
    while (el && el !== document.body) {
      if (el.classList && (el.classList.contains("gi-section") || el.classList.contains("session-section"))) return el;
      el = el.parentElement;
    }
    return null;
  }

  function onHoldStart(e) {
    var section = findSection(e.target);
    if (!section || section.classList.contains("gi-held")) return;
    holdTarget = section;
    holdTimer = setTimeout(function() {
      if (!holdTarget) return;
      holdTarget.style.position = "relative";
      holdTarget.classList.add("gi-held");

      /* Add the small dot */
      var dot = document.createElement("div");
      dot.className = "gi-held-dot";
      holdTarget.appendChild(dot);

      /* Record the hold */
      var label = "";
      var labelEl = holdTarget.querySelector(".gi-label");
      if (labelEl) label = labelEl.textContent;
      var textEl = holdTarget.querySelector(".gi-arc-text,.gi-unsaid-text,.gi-becoming-text,.gi-gravity-insight,.gi-shift-text,.gi-mirror-quote,.gi-contradiction-text,.gi-reflection-question,.noticing-text,.session-synthesis");
      var textPreview = textEl ? textEl.textContent.slice(0, 80) : "";

      var holdRecord = {
        date: new Date().toISOString(),
        section: label,
        preview: textPreview
      };

      try {
        window.storage.get("saycrd-holds").then(function(r) {
          var holds = [];
          try { if (r && r.value) holds = JSON.parse(r.value); } catch(e) {}
          holds.push(holdRecord);
          window.storage.set("saycrd-holds", JSON.stringify(holds));
        }).catch(function() {});
      } catch(ex) {}

      holdTarget = null;
    }, HOLD_MS);
  }

  function onHoldEnd() {
    clearTimeout(holdTimer);
    holdTimer = null;
    holdTarget = null;
  }

  document.addEventListener("pointerdown", onHoldStart);
  document.addEventListener("pointerup", onHoldEnd);
  document.addEventListener("pointercancel", onHoldEnd);
  document.addEventListener("pointermove", function(e) {
    /* Cancel if finger moves significantly */
    if (holdTarget && e.movementX * e.movementX + e.movementY * e.movementY > 100) {
      onHoldEnd();
    }
  });
})();

/* ── Save session ── */
const sessionCard     = $("session-card");
const sessionDate     = $("session-date");
const sessionThemes   = $("session-themes");
const sessionSynthesis= $("session-synthesis");
const sessionGuide    = $("session-guide");
const clarityInput    = $("clarity-input");
const claritySaved    = $("clarity-saved");

const typeLabelsMap = { act: "Do", sit: "Notice", deepen: "Ask", release: "Release", surrender: "Release", do: "Do", notice: "Notice", ask: "Ask" };
const typeColorMap  = { act: "var(--accent)", sit: "var(--accent-2)", deepen: "#9fb2d8", release: "var(--accent-3)", surrender: "#b8b0a4", do: "var(--accent)", notice: "var(--accent-2)", ask: "#9fb2d8" };

btnSave?.addEventListener("click", async function() {
  /* Prevent double-click */
  if (btnSave._saving) return;
  btnSave._saving = true;

  /* Immediate visual feedback */
  btnSave.textContent = "Reading your session\u2026";
  btnSave.style.opacity = ".5";
  btnSave.style.pointerEvents = "none";

  /* Cancel any pending interaction analysis — save will do its own re-synthesis */
  clearTimeout(state._insightTimer);
  state.insightsPending = false;

  /* Build date */
  var now = new Date();
  var opts = { weekday: "long", year: "numeric", month: "long", day: "numeric" };
  sessionDate.textContent = now.toLocaleDateString("en-US", opts);

  /* Build themes */
  sessionThemes.innerHTML = "";
  if (state.synthesisData && state.synthesisData.themes) {
    state.synthesisData.themes.forEach(function(t) {
      var pill = document.createElement("span");
      pill.className = "session-theme-pill";
      if (t.weight >= 4) pill.classList.add("heavy");
      pill.textContent = t.label;
      sessionThemes.appendChild(pill);
    });
  }

  /* Build synthesis — RE-SYNTHESIZE if user engaged at ALL */
  var hasGuideResponses = state.guideResponses && Object.keys(state.guideResponses).length > 0;
  var hasInlineInteractions = state.interactions && state.interactions.length > 0;
  var hasConnResponses = state.connResponses && Object.keys(state.connResponses).length > 0;
  var hasMapWork = svS && svS.choices && Object.keys(svS.choices).length > 0;
  var hasEngagement = hasGuideResponses || hasInlineInteractions || hasConnResponses || hasMapWork;
  var originalSynth = (state.synthesisData && state.synthesisData.synthesis) ? state.synthesisData.synthesis : "";

  if (hasEngagement && originalSynth) {
    /* Show loading state — map is about to evolve */
    sessionSynthesis.innerHTML = '<span class="synth-evolving">Re-reading your session\u2026</span>';
    field.classList.add("morphing");

    /* Build context from EVERYTHING the user shared */
    var allEngagement = [];

    /* 0a. Sidebar voice map work — confirmed/corrected/rejected connections */
    if (svS && svS.choices) {
      Object.keys(svS.choices).forEach(function(k) {
        var c = svS.choices[k];
        if (c.choice === "yes") {
          allEngagement.push('MAP: CONFIRMED connection "' + c.from + ' \u2194 ' + c.to + '" (' + c.label + ')');
        } else if (c.correction) {
          allEngagement.push('MAP: CORRECTED connection "' + c.from + ' \u2194 ' + c.to + '" (' + c.label + ') \u2014 user said: "' + c.correction + '"');
        } else {
          allEngagement.push('MAP: REJECTED connection "' + c.from + ' \u2194 ' + c.to + '" (' + c.label + ')');
        }
      });
    }
    /* 0b. User-added thoughts */
    if (svS && svS.added && svS.added.length > 0) {
      allEngagement.push('USER ADDED these thoughts: ' + svS.added.join('; '));
    }

    /* 0c. Legacy connection responses (old format) */
    Object.keys(state.connResponses || {}).forEach(function(k) {
      var cr = state.connResponses[k];
      if (cr && cr.answer) {
        var line = 'MAP RESPONSE — About "' + cr.from + ' \u2194 ' + cr.to + '" they said: "' + cr.answer + '"';
        if (cr.echo) line += ' (system echoed: "' + cr.echo + '")';
        allEngagement.push(line);
      }
    });

    /* 1. Guide responses */
    Object.keys(state.guideResponses || {}).forEach(function(k) {
      var gr = state.guideResponses[k];
      if (gr && gr.answer) {
        var line = 'GUIDE RESPONSE — To "' + (gr.question || gr.type) + '" they said: "' + gr.answer + '"';
        if (gr.echo) line += ' (system echoed: "' + gr.echo + '")';
        /* Detect pushback */
        var lower = (gr.answer || "").toLowerCase();
        if (lower.indexOf("not") !== -1 || lower.indexOf("don't") !== -1 || lower.indexOf("disagree") !== -1 ||
            lower.indexOf("that's not") !== -1 || lower.indexOf("wasn't") !== -1 || lower.indexOf("isn't") !== -1 ||
            lower.indexOf("wouldn't say") !== -1 || lower.indexOf("actually") !== -1) {
          line += ' *** PUSHBACK — user challenged this framing. Honor THEIR language, not the original. ***';
        }
        allEngagement.push(line);
      }
    });

    /* 2. Inline interactions (tapped reading text, corrections, reflections) */
    (state.interactions || []).forEach(function(inter) {
      if (inter.type === "reflection" && inter.data) {
        allEngagement.push('INLINE RESPONSE — When reading "' + (inter.data.question || "").slice(0, 100) + '" they wrote: "' + (inter.data.answer || "") + '"');
      } else if (inter.type === "correction" && inter.data) {
        allEngagement.push('CORRECTION — They disagreed with "' + (inter.data.label || inter.data.question || "") + '" and said: "' + (inter.data.correction || inter.data.answer || "") + '"');
      } else if (inter.type === "clarity" && inter.data) {
        allEngagement.push('CLARITY STATEMENT: "' + (inter.data.text || "") + '"');
      } else if (inter.type === "resonance_no" && inter.data) {
        allEngagement.push('REJECTED connection: "' + (inter.data.label || "") + '"');
      }
    });

    var clarityVal = clarityInput ? clarityInput.value.trim() : "";
    if (clarityVal) allEngagement.push('CLARITY STATEMENT: "' + clarityVal + '"');

    var rawDumpText = "";
    try { rawDumpText = (input && input.value) ? input.value.trim().slice(0, 2000) : ""; } catch(e) {}

    /* Full re-synthesis prompt — reads FROM the map, doesn't rebuild it */
    var resynthPrompt = 'You are the AI engine behind SAYCRD. A user completed a session: they wrote a stream-of-consciousness dump, received a constellation map, then WORKED THE MAP — confirming connections that landed, correcting ones that didn\'t (in their own words), rejecting what was wrong, and adding new thoughts that grew the map organically.\n\n' +
      'The map is their work. It stays exactly as they shaped it. Your job: write the SESSION READING — what the map reveals now that they\'ve worked it.\n\n' +
      'CRITICAL — MAP RESPONSES ARE GROUND TRUTH:\n' +
      '- Confirmed connections = load-bearing truths. Name them.\n' +
      '- User corrections = the REAL insight. Their words replace yours. Quote their corrections back.\n' +
      '- Rejected connections = the system was wrong. Don\'t reference them.\n' +
      '- User-added nodes = what the AI missed. These are high signal.\n\n' +
      'Write:\n' +
      '1. SYNTHESIS: 3-4 sentences. The session\'s final word. What emerged from the MAP WORK — not from the dump alone. Name what they confirmed. Use their correction language. Note what they added. If they corrected a characterization, use THEIR framing. VOICE: Observer. Precise. Warm but direct. No coaching. Anchor every sentence to something they actually did on the map.\n' +
      '2. MAP_TITLE: Poetic name for this map as it stands now — 3-8 words.\n' +
      '3. NOTICING: One observation about the pattern underneath all their map responses. Spare. Clinical. Field note. Max 2 sentences. What does the shape of their confirms + corrections + additions reveal?\n\n' +
      'Respond with ONLY valid JSON:\n' +
      '{"synthesis":"...","map_title":"...","noticing":"..."}';

    /* Build map state from svS.choices — what the user actually did */
    var mapState = [];
    if (svS && svS.choices) {
      Object.keys(svS.choices).forEach(function(k) {
        var c = svS.choices[k];
        if (c.choice === "yes") {
          mapState.push('CONFIRMED: ' + c.from + ' \u2194 ' + c.to + ' ("' + c.label + '") — insight: "' + (c.insight || '') + '"');
        } else if (c.correction) {
          mapState.push('CORRECTED: ' + c.from + ' \u2194 ' + c.to + ' ("' + c.label + '") — user said: "' + c.correction + '" (original insight was: "' + (c.insight || '') + '")');
        } else {
          mapState.push('REJECTED: ' + c.from + ' \u2194 ' + c.to + ' ("' + c.label + '")');
        }
      });
    }
    var userAdded = [];
    state.nodes.forEach(function(nd) { if (nd.isUser) userAdded.push(nd.label); });

    /* Build the current theme list from what's actually on the map */
    var currentThemes = [];
    state.nodes.forEach(function(nd) { currentThemes.push(nd.label + ' (w:' + (nd.weight||1) + (nd.isUser ? ', user-added' : '') + ')'); });

    var resynthContext = 'ORIGINAL DUMP:\n"' + rawDumpText + '"\n\n' +
      'ORIGINAL READING:\n"' + originalSynth + '"\n\n' +
      'THEMES ON THE MAP: ' + currentThemes.join(', ') + '\n\n' +
      'MAP WORK (what the user did):\n' + (mapState.length > 0 ? mapState.join('\n') : '(no connection responses)') + '\n\n' +
      (userAdded.length > 0 ? 'USER-ADDED THEMES (what AI missed): ' + userAdded.join(', ') + '\n\n' : '') +
      'EVERYTHING ELSE THE USER SHARED:\n' + allEngagement.join('\n') +
      (state.synthesisData.noticing ? '\n\nORIGINAL NOTICING: "' + state.synthesisData.noticing + '"' : '') +
      (state._landscape ? '\n\n' + state._landscape : '');

    /* AWAIT re-synthesis — don't proceed until it's done */
    try {
      var raw = await callClaude(resynthPrompt, resynthContext, 2000);
      var newData = extractJSON(raw);

      if (newData && newData.synthesis) {
        /* ── MAP STAYS UNTOUCHED — only update the reading ── */
        field.classList.remove("morphing");

        /* Store originals for reference */
        var origSynthesis = state.synthesisData.synthesis;
        var origTitle = state.synthesisData.map_title;

        /* Update synthesisData with evolved reading (themes/connections stay from map) */
        state.synthesisData.synthesis = newData.synthesis;
        state.synthesisData.original_synthesis = origSynthesis;
        if (newData.map_title) state.synthesisData.map_title = newData.map_title;
        state.synthesisData.original_map_title = origTitle;
        if (newData.noticing) state.synthesisData.noticing = newData.noticing;
        state.synthesisData.evolved = true;

        /* Build current themes from the actual map for saving */
        var evolvedThemes = [];
        state.nodes.forEach(function(nd) {
          evolvedThemes.push({ label: nd.label, weight: nd.weight || 1, userAdded: !!nd.isUser });
        });
        state.synthesisData.themes = evolvedThemes;

        /* Build current connections from the actual map for saving */
        var evolvedConns = [];
        (state.connections || []).forEach(function(c) {
          evolvedConns.push({ from: c.a, to: c.b, label: c.labelEl ? c.labelEl.textContent : '', insight: c.synthesizedInsight || '' });
        });
        state.synthesisData.connections = evolvedConns;

        /* Update saved session */
        if (state.currentSession) {
          state.currentSession.themes = evolvedThemes;
          state.currentSession.synthesis = newData.synthesis;
          state.currentSession.original_synthesis = origSynthesis;
          saveHistory();

          if (state.currentSession._dbId && currentUser && currentUser.id !== "local-user" && supabaseAvailable) {
            var dbId = state.currentSession._dbId;
            sbClient.from("sessions").update({
              synthesis: newData.synthesis,
              original_synthesis: origSynthesis
            }).eq("id", dbId).then(function() {
              console.log("DB: Session updated with evolved synthesis");
            }).catch(function() {});
          }
        }

        /* Update session card with evolved reading */
        sessionSynthesis.textContent = newData.synthesis;
        try { makeClarifiable(sessionSynthesis); } catch(e) {}

        /* Rebuild theme pills from actual map nodes */
        sessionThemes.innerHTML = "";
        evolvedThemes.forEach(function(t) {
          var pill = document.createElement("span");
          pill.className = "session-theme-pill";
          if (t.weight >= 4) pill.classList.add("heavy");
          if (t.userAdded) pill.style.borderColor = "rgba(165,235,220,.4)";
          pill.textContent = t.label;
          sessionThemes.appendChild(pill);
        });
      } else {
        field.classList.remove("morphing");
        sessionSynthesis.textContent = originalSynth;
        try { makeClarifiable(sessionSynthesis); } catch(e) {}
      }
    } catch(e) {
      console.warn("Re-synthesis failed:", e);
      field.classList.remove("morphing");
      sessionSynthesis.textContent = originalSynth;
      try { makeClarifiable(sessionSynthesis); } catch(e2) {}
    }
  } else if (originalSynth) {
    /* No engagement — but still generate a DEEPER session reading */
    sessionSynthesis.innerHTML = '<span class="synth-evolving">Deepening your reading\u2026</span>';
    try {
      var deepenPrompt = 'A user wrote a stream-of-consciousness dump. An initial reading was generated. Now write what the initial reading was too polite to say.\n\n' +
        'VOICE: Direct. Almost blunt. Like a close friend who cares enough to not sugarcoat. Not warm — honest. Say the hard thing in plain language. But ONLY say what the evidence supports — never use "obviously" or "clearly" or claim someone is "avoiding" or "performing" unless their own words prove it. If they wrote little, the hard truth might simply be: they didn\'t say much.\n\n' +
        'Rules:\n- 2-3 sentences. Short ones.\n- Name the thing the initial reading softened or circled around.\n- Use their actual words as evidence. Quote them back to themselves.\n- No "you\'re navigating" or "something in you." Just: "You said X. That means Y. And you know it."\n- This must sound NOTHING like the initial reading. Different structure, different tone, different insight.\n\n' +
        'Respond with ONLY JSON: {"synthesis":"..."}';
      var deepenContext = 'THEIR WORDS:\n"' + ((input && input.value) ? input.value.trim().slice(0, 2000) : "") + '"\n\n' +
        'INITIAL READING:\n"' + originalSynth + '"\n\n' +
        'THEMES: ' + (state.synthesisData.themes || []).map(function(t) { return t.label + ' (w:' + (t.weight||1) + ')'; }).join(', ') + '\n' +
        'CONNECTIONS: ' + (state.synthesisData.connections || []).map(function(c) { return c.from + ' \u2194 ' + c.to + ': ' + (c.insight || c.label || ''); }).join('; ') +
        (state._landscape ? '\n\n' + state._landscape : '');
      var deepRaw = await callClaude(deepenPrompt, deepenContext, 600);
      var deepData = extractJSON(deepRaw);
      if (deepData && deepData.synthesis) {
        sessionSynthesis.textContent = deepData.synthesis;
        state.synthesisData.session_synthesis = deepData.synthesis;
      } else {
        sessionSynthesis.textContent = originalSynth;
      }
    } catch(e) {
      sessionSynthesis.textContent = originalSynth;
    }
    try { makeClarifiable(sessionSynthesis); } catch(e) {}
  } else {
    sessionSynthesis.textContent = "No synthesis available.";
  }

  /* Build connection responses — what they said about the map */
  var connSection = document.getElementById("session-conn-section");
  var connContainer = document.getElementById("session-conn-responses");
  if (connSection && connContainer && state.connResponses && Object.keys(state.connResponses).length > 0) {
    connContainer.innerHTML = "";
    Object.keys(state.connResponses).forEach(function(k) {
      var cr = state.connResponses[k];
      if (!cr || !cr.answer) return;
      var row = document.createElement("div");
      row.style.cssText = "margin-bottom:1rem;padding-bottom:1rem;border-bottom:1px solid rgba(244,241,234,.04)";
      var label = document.createElement("div");
      label.style.cssText = "font-family:var(--mono);font-size:.78rem;letter-spacing:.08em;text-transform:uppercase;color:var(--ink-soft);opacity:.5;margin-bottom:.4rem";
      label.textContent = (cr.from || "") + " \u27F7 " + (cr.to || "");
      var answer = document.createElement("div");
      answer.style.cssText = "font-family:'Fraunces',serif;font-size:1.08rem;color:rgba(165,235,220,.85);line-height:1.6;font-style:italic";
      answer.textContent = "\u201C" + cr.answer + "\u201D";
      row.append(label, answer);
      if (cr.echo) {
        var echo = document.createElement("div");
        echo.style.cssText = "font-family:'Fraunces',serif;font-size:.98rem;color:rgba(165,235,220,.45);line-height:1.55;margin-top:.4rem;padding-left:.8rem;border-left:2px solid rgba(165,235,220,.15)";
        echo.textContent = cr.echo;
        row.appendChild(echo);
      }
      connContainer.appendChild(row);
    });
    connSection.style.display = "";
  }

  /* Build guide — interactive items with tap-to-respond */
  if (sessionGuide) {
    sessionGuide.innerHTML = "";
    var guideItems = (state.guideData && state.guideData.items) ? state.guideData.items : [];
    if (!state.guideResponses) state.guideResponses = {};

    var responsePrompts = {
      ask: "Answer honestly\u2026", deepen: "Answer honestly\u2026",
      do: "What will you do first?", act: "What will you do first?",
      notice: "What do you notice when you sit with it?", sit: "What do you notice when you sit with it?",
      release: "What shifts when you name it?", surrender: "What\u2019s true right now?"
    };

    guideItems.forEach(function(item, idx) {
      var guideText = item.text || item.prompt || item.action || item.label || item.message || "";
      var existingResp = state.guideResponses[idx];

      var div = document.createElement("div");
      div.className = "guide-item type-" + (item.type === "act" ? "do" : item.type === "sit" ? "notice" : item.type === "deepen" ? "ask" : item.type === "surrender" ? "release" : item.type);
      if (existingResp) div.classList.add("has-response");

      var tag = document.createElement("span");
      tag.className = "tag " + item.type;
      tag.textContent = typeLabelsMap[item.type] || item.type;
      tag.style.color = typeColorMap[item.type] || "var(--ink-soft)";

      var p = document.createElement("p");
      p.textContent = guideText;

      var respArea = document.createElement("div");
      respArea.className = "guide-response-area";

      if (existingResp && existingResp.answer) {
        /* Already responded — show saved response */
        var saved = document.createElement("div");
        saved.className = "guide-response-saved";
        saved.textContent = existingResp.answer;
        var meta = document.createElement("div");
        meta.className = "guide-response-meta";
        meta.textContent = "your words";
        respArea.append(saved, meta);
        respArea.style.maxHeight = "400px";
        respArea.style.opacity = "1";
        respArea.style.marginTop = ".85rem";
        if (existingResp.echo) {
          var echoShow = document.createElement("div");
          echoShow.className = "guide-echo visible";
          var echoText = document.createElement("div");
          echoText.className = "guide-echo-text";
          echoText.textContent = existingResp.echo;
          echoShow.appendChild(echoText);
          respArea.appendChild(echoShow);
        }
      } else {
        /* Not yet responded — show input */
        var respPrompt = document.createElement("div");
        respPrompt.className = "guide-response-prompt";
        respPrompt.textContent = responsePrompts[item.type] || "What comes up?";
        var respInput = document.createElement("textarea");
        respInput.className = "guide-response-input";
        respInput.rows = 2;
        respInput.placeholder = "Write what\u2019s true\u2026";
        respInput.addEventListener("click", function(e) { e.stopPropagation(); });

        function saveGuideResponse() {
          var val = respInput.value.trim();
          if (!val) return;
          if (div.classList.contains("has-response")) return;
          state.guideResponses[idx] = { type: item.type, question: guideText, answer: val };
          logInteraction("guide_response", { question: guideText, answer: val, type: item.type, source: item.source || "" });
          respArea.innerHTML = "";
          var sv = document.createElement("div");
          sv.className = "guide-response-saved";
          sv.textContent = val;
          var mt = document.createElement("div");
          mt.className = "guide-response-meta";
          mt.textContent = "your words";
          respArea.append(sv, mt);
          div.classList.add("has-response");
          div.classList.remove("expanded");
          respArea.style.maxHeight = "400px";
          respArea.style.opacity = "1";
          respArea.style.marginTop = ".85rem";

          /* AI Echo */
          var echoEl = document.createElement("div");
          echoEl.className = "guide-echo";
          echoEl.innerHTML = '<span class="guide-echo-loading">\u00B7\u00B7\u00B7</span>';
          respArea.appendChild(echoEl);
          (async function() {
            try {
              var echoPrompt = 'You are the reflective voice of SAYCRD. The user was given a guide prompt and wrote an honest response. ECHO what they said \u2014 not validate, not coach.\n\nIf they PUSH BACK on a characterization \u2014 BELIEVE THEM.\n\nReturn ONE:\n- MIRROR: Reflect the emotional core differently.\n- TENSION: Surface a friction they didn\'t name.\n- QUESTION: One deeper follow-up.\n\nRules: Max 30 words. No praise. If pushback, type="correction".\nJSON only: {"echo":"...","type":"mirror|tension|question|correction"}';
              var echoCtx = 'Guide: "' + guideText + '"\nResponse: "' + val + '"';
              var echoRaw = await callClaude(echoPrompt, echoCtx, 200);
              var echoData = extractJSON(echoRaw);
              if (echoData && echoData.echo) {
                echoEl.innerHTML = '';
                var et = document.createElement("div");
                et.className = "guide-echo-text";
                et.textContent = echoData.echo;
                echoEl.appendChild(et);
                echoEl.classList.add("visible");
                state.guideResponses[idx].echo = echoData.echo;
                state.guideResponses[idx].echoType = echoData.type;

                /* ── FOLLOW-UP — let user respond to the echo ── */
                var gFollowHint = document.createElement("div");
                gFollowHint.style.cssText = "font-size:.78rem;color:rgba(125,183,174,.45);margin-top:.5rem;cursor:pointer;font-family:var(--mono);letter-spacing:.04em;transition:opacity .2s";
                gFollowHint.textContent = "say more \u2192";
                var gFollowArea = document.createElement("div");
                gFollowArea.style.cssText = "max-height:0;overflow:hidden;opacity:0;transition:max-height .3s ease,opacity .25s ease;margin-top:0";
                var gFollowInput = document.createElement("textarea");
                gFollowInput.style.cssText = "width:100%;background:rgba(0,0,0,.2);border:1px solid rgba(125,183,174,.15);border-radius:10px;color:var(--ink);font-family:'Fraunces',serif;font-size:1rem;padding:.65rem .85rem;resize:none;outline:none;line-height:1.5;margin-top:.4rem";
                gFollowInput.rows = 2;
                gFollowInput.placeholder = "What do you actually mean?";
                gFollowInput.addEventListener("click", function(e) { e.stopPropagation(); });

                var gFollowEcho = document.createElement("div");
                gFollowEcho.style.cssText = "display:none";

                function saveGuideFollowUp() {
                  var fv = gFollowInput.value.trim();
                  if (!fv || gFollowArea.classList.contains("done")) return;
                  gFollowArea.classList.add("done");
                  state.guideResponses[idx].followup = fv;
                  logInteraction("guide_followup", { guide: guideText, followup: fv });

                  gFollowInput.style.display = "none";
                  var gfSaved = document.createElement("div");
                  gfSaved.style.cssText = "font-family:'Fraunces',serif;font-size:1.02rem;color:rgba(165,235,220,.8);line-height:1.5;font-style:italic;margin-top:.3rem";
                  gfSaved.textContent = "\u201C" + fv + "\u201D";
                  gFollowArea.appendChild(gfSaved);
                  gFollowHint.style.display = "none";

                  gFollowEcho.style.display = "";
                  gFollowEcho.innerHTML = '<div style="margin-top:.5rem"><span class="guide-echo-loading">\u00B7\u00B7\u00B7</span></div>';

                  (async function() {
                    try {
                      var f2p = 'The user is in a dialogue about a guide item.\n\n' +
                        'Guide: "' + guideText + '"\nTheir response: "' + val + '"\nSystem echo: "' + echoData.echo + '"\nTheir follow-up: "' + fv + '"\n\n' +
                        'They are CLARIFYING or CORRECTING. This is their final word.\n\n' +
                        'Max 20 words. If correcting, ACCEPT IT — say "Got it" or "That\'s clearer" and reflect THEIR framing. Do NOT reinterpret or add analysis.\n\n' +
                        'JSON only: {"echo":"..."}';
                      var f2r = await callClaude(f2p, '', 200);
                      var f2d = extractJSON(f2r);
                      if (f2d && f2d.echo) {
                        gFollowEcho.innerHTML = '';
                        var f2el = document.createElement("div");
                        f2el.className = "guide-echo-text";
                        f2el.style.cssText = "font-size:.92rem;color:rgba(125,183,174,.5)";
                        f2el.textContent = f2d.echo;
                        gFollowEcho.appendChild(f2el);
                        state.guideResponses[idx].followupEcho = f2d.echo;
                      } else { gFollowEcho.style.display = "none"; }
                    } catch(e) { gFollowEcho.style.display = "none"; }
                  })();
                }

                gFollowInput.addEventListener("blur", saveGuideFollowUp);
                gFollowInput.addEventListener("keydown", function(e) {
                  if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); saveGuideFollowUp(); }
                });
                gFollowArea.appendChild(gFollowInput);

                gFollowHint.addEventListener("click", function(e) {
                  e.stopPropagation();
                  if (gFollowArea.classList.contains("done")) return;
                  gFollowArea.style.maxHeight = "200px";
                  gFollowArea.style.opacity = "1";
                  gFollowArea.style.marginTop = ".4rem";
                  gFollowHint.style.opacity = "0";
                  setTimeout(function() { gFollowInput.focus(); }, 250);
                });

                echoEl.append(gFollowHint, gFollowArea, gFollowEcho);
              } else { echoEl.remove(); }
            } catch(e) { echoEl.remove(); }
          })();
        }
        respInput.addEventListener("blur", saveGuideResponse);
        respInput.addEventListener("keydown", function(e) {
          if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); saveGuideResponse(); }
        });
        respArea.append(respPrompt, respInput);
      }

      div.append(tag, p, respArea);

      /* Tap to expand (only if not yet responded) */
      div.addEventListener("click", function() {
        if (div.classList.contains("has-response")) return;
        var wasExpanded = div.classList.contains("expanded");
        sessionGuide.querySelectorAll(".guide-item.expanded").forEach(function(el) { el.classList.remove("expanded"); });
        if (!wasExpanded) {
          div.classList.add("expanded");
          var inp = div.querySelector(".guide-response-input");
          if (inp) setTimeout(function() { inp.focus(); }, 350);
        }
      });

      sessionGuide.appendChild(div);
    });

    /* Add your own */
    if (state.userAddedItems && state.userAddedItems.length > 0) {
      state.userAddedItems.forEach(function(item) {
        var row = document.createElement("div");
        row.className = "guide-item type-do has-response";
        var tag = document.createElement("span");
        tag.className = "tag yours";
        tag.style.color = "var(--accent-2)";
        tag.textContent = "Yours";
        var txt = document.createElement("p");
        txt.textContent = item.text;
        row.append(tag, txt);
        sessionGuide.appendChild(row);
      });
    }
  }

  /* Populate kept lines from this session */
  var keptSection = document.getElementById("session-kept-section");
  var keptContainer = document.getElementById("session-kept-lines");
  if (keptSection && keptContainer) {
    keptSection.style.display = "none";
    keptContainer.innerHTML = "";
    try {
      var kpt = await window.storage.get("saycrd-kept-lines").catch(function() { return null; });
      if (kpt && kpt.value) {
        var allKept = JSON.parse(kpt.value);
        /* Show lines kept from this session (session number = current count) */
        var thisSession = sessionHistory.length;
        var sessionKept = allKept.filter(function(k) { return k.session === thisSession || k.session === thisSession - 1; });
        if (sessionKept.length > 0) {
          sessionKept.forEach(function(k) {
            var lineEl = document.createElement("div");
            lineEl.style.cssText = "padding:.7rem 1rem;border-left:2px solid rgba(214,178,109,.3);background:rgba(214,178,109,.04);border-radius:0 8px 8px 0;font-family:'Fraunces',serif;font-size:1.05rem;color:var(--ink-soft);line-height:1.55;font-style:italic";
            lineEl.textContent = "\u201C" + k.line + "\u201D";
            keptContainer.appendChild(lineEl);
          });
          keptSection.style.display = "";
        }
      }
    } catch(e) {}
  }

  /* Reset clarity input */
  clarityInput.style.display = "";
  clarityInput.value = "";
  claritySaved.classList.remove("visible");

  /* Show noticing immediately */
  noticingSection.style.display = "none";
  if (state.synthesisData && state.synthesisData.noticing) {
    noticingText.textContent = state.synthesisData.noticing;
    try { makeClarifiable(noticingText); } catch(e) {}
    noticingSection.style.display = "";
  }

  /* Save session to history NOW */
  var themes = (state.synthesisData.themes || []).map(function(t) { return { label: t.label, weight: t.weight, userAdded: !!t.userAdded }; });
  var guide = (state.synthesisData.guide || []).map(function(g, idx) {
    var resp = (state.guideResponses && state.guideResponses[idx]) ? state.guideResponses[idx].answer : null;
    return { type: g.type, text: g.text || g.prompt || g.action || g.label || g.message || "", response: resp, skipped: !resp };
  });
  var userItems = (state.userAddedItems || []).map(function(u) { return { type: "yours", text: u.text }; });

  /* Capture raw dump — first 1200 chars of their actual words */
  var rawDump = "";
  try { rawDump = (input && input.value) ? input.value.trim().slice(0, 1200) : ""; } catch(e) {}

  /* Capture map behavior — what they added and connected themselves */
  var mapBehavior = { userNodes: [], userConnections: [] };
  try {
    (state.synthesisData.themes || []).forEach(function(t) {
      if (t.userAdded) mapBehavior.userNodes.push(t.label);
    });
    (state.synthesisData.connections || []).forEach(function(c) {
      if (c.userAdded) mapBehavior.userConnections.push({ from: c.from, to: c.to, label: c.label || "" });
    });
  } catch(e) {}

  /* Session timing */
  var now = new Date();
  var timing = { hour: now.getHours(), dayOfWeek: now.getDay() };
  if (sessionHistory.length > 0) {
    var lastDate = new Date(sessionHistory[sessionHistory.length - 1].date);
    timing.daysSinceLast = Math.round((now - lastDate) / (1000 * 60 * 60 * 24));
  }

  state.currentSession = {
    date: now.toISOString(),
    themes: themes,
    synthesis: state.synthesisData.synthesis || "",
    original_synthesis: state.synthesisData.original_synthesis || state.synthesisData.synthesis || "",
    noticing: state.synthesisData.noticing || "",
    map_title: state.synthesisData.map_title || "",
    clarity: null,
    guide: guide.concat(userItems),
    guideResponses: Object.assign({}, state.guideResponses),
    inlineInteractions: (state.interactions || []).filter(function(i) {
      return i.type === "reflection" || i.type === "correction" || i.type === "clarity";
    }).map(function(i) {
      return { type: i.type, question: (i.data.question || "").slice(0, 200), answer: (i.data.answer || i.data.correction || i.data.text || "").slice(0, 500) };
    }),
    resonance: Object.assign({}, state.resonance),
    rawDump: rawDump,
    mapBehavior: mapBehavior,
    timing: timing,
    surfacedTension: null, /* filled by interaction analysis */
    mapEvolution: null,    /* filled by interaction analysis */
    nodeEngagement: state.nodeEngagement ? Object.assign({}, state.nodeEngagement) : null,
    emergedConnections: (function() {
      /* Capture connections that emerged from guide engagement (not AI-generated) */
      var emerged = [];
      if (state.connections) {
        state.connections.forEach(function(c) {
          if (c.labelEl && c.labelEl.textContent && c.emerged) {
            emerged.push({ from: c.a, to: c.b, label: c.labelEl.textContent || "emerged" });
          }
        });
      }
      return emerged.length > 0 ? emerged : null;
    })(),
    connResponses: state.connResponses ? Object.assign({}, state.connResponses) : null,
    mapWork: (svS && svS.choices && Object.keys(svS.choices).length > 0) ? {
      choices: Object.assign({}, svS.choices),
      added: svS.added ? svS.added.slice() : [],
      rounds: svS.round || 1
    } : null
  };
  sessionHistory.push(state.currentSession);
  saveHistory();
  await saveSessionToDb(state.currentSession); /* ensure _dbId is set before re-synthesis */

  /* ── Guide tracker update — track intention→action ── */
  try {
    var tracker = {};
    try { var tr = await window.storage.get("saycrd-guide-tracker"); if (tr && tr.value) tracker = JSON.parse(tr.value); } catch(e) {}
    var sessionKey = "s" + sessionHistory.length;
    tracker[sessionKey] = (state.currentSession.guide || []).map(function(g, gi) {
      var resp = state.guideResponses && state.guideResponses[gi];
      return {
        type: g.type,
        text: g.text || g.prompt || g.action || "",
        status: resp && resp.answer ? "responded" : "given",
        session: sessionHistory.length,
        date: now.toISOString()
      };
    });
    await window.storage.set("saycrd-guide-tracker", JSON.stringify(tracker));
  } catch(e) { console.warn("Guide tracker save:", e); }

  /* ── Theme co-occurrence tracking ── */
  /* Count how often theme pairs appear together in the same session */
  try {
    var coData = {};
    try { var co = await window.storage.get("saycrd-cooccurrence"); if (co && co.value) coData = JSON.parse(co.value); } catch(e) {}
    var labels = themes.map(function(t) { return t.label.toLowerCase(); }).sort();
    for (var ci = 0; ci < labels.length; ci++) {
      for (var cj = ci + 1; cj < labels.length; cj++) {
        var coKey = labels[ci] + " + " + labels[cj];
        coData[coKey] = (coData[coKey] || 0) + 1;
      }
    }
    await window.storage.set("saycrd-cooccurrence", JSON.stringify(coData));
  } catch(e) { console.log("Co-occurrence tracking skipped:", e); }

  /* Reset save button */
  btnSave.textContent = "Run Session";
  btnSave.style.opacity = "";
  btnSave.style.pointerEvents = "";
  btnSave._saving = false;

  /* Lock session — everything is now read-only but browsable */
  state.sessionLocked = true;
  lockSession();

  /* Transition to Session phase */
  setPhase(3);
});

/* "Continue to What's Growing" — navigates from Session to Growing */
$("btn-to-growing")?.addEventListener("click", function() {
  setPhase(4);
  growingViewer.style.display = "";
  renderGrowing();
  phase4Actions.style.display = "";
});

/* Clarity statement save on Enter — updates existing session */
clarityInput?.addEventListener("keydown", function(e) {
  if (e.key === "Enter" && clarityInput.value.trim().length > 0) {
    var statement = clarityInput.value.trim();
    clarityInput.style.display = "none";
    claritySaved.innerHTML = '<div class="clarity-text">&ldquo;' + statement + '&rdquo;</div><div class="clarity-tag">your clarity</div>';
    claritySaved.classList.add("visible");

    /* Update the saved session with clarity */
    if (state.currentSession) {
      state.currentSession.clarity = statement;
      saveHistory();
      /* Update normalized DB too */
      if (state.currentSession._dbId && currentUser && currentUser.id !== "local-user" && supabaseAvailable) {
        sbClient.from("sessions").update({ clarity: statement }).eq("id", state.currentSession._dbId).then(function() {
          console.log("DB: Clarity updated");
        }).catch(function() {});
        sbClient.from("session_interactions").insert({
          session_id: state.currentSession._dbId,
          user_id: currentUser.id,
          interaction_type: "clarity",
          response: statement
        }).catch(function() {});
      }
    }
    logInteraction("clarity", { text: statement });
  }
});

/* ====================================================================
   WHAT'S GROWING — The system sees your arc
   ==================================================================== */
var noticingSection = $("noticing-section");
var noticingText    = $("noticing-text");
var growingViewer   = $("growing-viewer");
var growingList     = $("growing-list");
var growingEmpty    = $("growing-empty");
var sessionCardEl   = $("session-card");
var phase4Actions   = $("phase4-actions");

/* Session history storage */
var sessionHistory = [];

async function loadHistory() {
  try {
    var result = await window.storage.get("saycrd-sessions");
    if (result && result.value) sessionHistory = JSON.parse(result.value);
  } catch(e) {}
}
async function saveHistory() {
  try {
    await window.storage.set("saycrd-sessions", JSON.stringify(sessionHistory));
  } catch(e) {}
}

/* ── Normalized DB save — writes structured data to proper tables ── */
async function saveSessionToDb(session) {
  if (!currentUser || currentUser.id === "local-user" || !supabaseAvailable) return;
  try {
    /* 1. Insert session row */
    var { data: sRow, error: sErr } = await sbClient
      .from("sessions")
      .insert({
        user_id: currentUser.id,
        created_at: session.date,
        raw_dump: session.rawDump || null,
        synthesis: session.synthesis || null,
        original_synthesis: session.original_synthesis || null,
        noticing: session.noticing || null,
        clarity: session.clarity || null,
        hour_of_day: session.timing ? session.timing.hour : null,
        day_of_week: session.timing ? session.timing.dayOfWeek : null,
        days_since_last: session.timing ? session.timing.daysSinceLast : null
      })
      .select("id")
      .single();

    if (sErr || !sRow) { console.warn("DB session insert failed:", sErr); return; }
    var sessionId = sRow.id;

    /* 2. Insert themes */
    var themeRows = (session.themes || []).map(function(t) {
      return {
        session_id: sessionId,
        user_id: currentUser.id,
        label: t.label,
        weight: t.weight || 1,
        user_added: !!t.userAdded
      };
    });
    if (themeRows.length) {
      await sbClient.from("session_themes").insert(themeRows);
    }

    /* 3. Insert connections */
    var connData = (state.synthesisData && state.synthesisData.connections) || [];
    var connRows = connData.map(function(c) {
      return {
        session_id: sessionId,
        user_id: currentUser.id,
        from_label: c.from,
        to_label: c.to,
        label: c.label || null,
        insight: c.insight || null,
        user_added: !!c.userAdded,
        from_interaction: !!c.fromInteraction
      };
    });
    if (connRows.length) {
      await sbClient.from("session_connections").insert(connRows);
    }

    /* 4. Insert guide items with responses */
    var guideRows = (session.guide || []).map(function(g, gi) {
      var gr = session.guideResponses && session.guideResponses[gi];
      return {
        session_id: sessionId,
        user_id: currentUser.id,
        guide_type: g.type || "notice",
        prompt: g.text || "",
        source_theme: g.source || null,
        response: gr ? gr.answer : (g.response || null),
        echo: gr ? gr.echo : null,
        skipped: !(gr && gr.answer) && !g.response,
        from_interaction: !!g.fromInteraction
      };
    });
    if (guideRows.length) {
      await sbClient.from("session_guides").insert(guideRows);
    }

    /* 5. Insert inline interactions */
    var interRows = (session.inlineInteractions || []).map(function(i) {
      return {
        session_id: sessionId,
        user_id: currentUser.id,
        interaction_type: i.type,
        prompt: i.question || null,
        response: i.answer || null
      };
    });
    /* Also capture resonance as interactions */
    Object.keys(session.resonance || {}).forEach(function(k) {
      var r = session.resonance[k];
      interRows.push({
        session_id: sessionId,
        user_id: currentUser.id,
        interaction_type: "resonance",
        prompt: r.label || k,
        response: r.value || null
      });
    });
    /* Capture map work (confirmed/corrected/rejected) as interactions */
    if (session.mapWork && session.mapWork.choices) {
      Object.keys(session.mapWork.choices).forEach(function(k) {
        var c = session.mapWork.choices[k];
        interRows.push({
          session_id: sessionId,
          user_id: currentUser.id,
          interaction_type: "map_" + (c.choice || "response"),
          prompt: (c.from || "") + " \u2194 " + (c.to || "") + " (" + (c.label || "") + ")",
          response: c.correction || c.choice || null
        });
      });
      /* Capture user-added thoughts */
      (session.mapWork.added || []).forEach(function(thought) {
        interRows.push({
          session_id: sessionId,
          user_id: currentUser.id,
          interaction_type: "map_added",
          prompt: null,
          response: thought
        });
      });
    }
    if (interRows.length) {
      await sbClient.from("session_interactions").insert(interRows);
    }

    /* 6. Update user profile session count */
    var countResult = await sbClient.rpc("get_user_session_count", { uid: currentUser.id });
    var count = (countResult.data) || 1;
    await sbClient.from("user_profiles").upsert({
      user_id: currentUser.id,
      session_count: count,
      updated_at: new Date().toISOString()
    }, { onConflict: "user_id" });

    console.log("DB: Session saved to normalized tables, id=" + sessionId);
    /* Store DB id back on session object for later updates (clarity, etc.) */
    session._dbId = sessionId;
  } catch(e) {
    console.warn("DB normalized save failed (non-critical):", e);
  }
}
try { loadHistory(); } catch(e) {}

/* Highlights storage */
var highlights = [];
async function loadHighlights() {
  try { var r = await window.storage.get("saycrd-highlights"); if (r && r.value) highlights = JSON.parse(r.value); } catch(e) {}
}
async function saveHighlights() {
  try { await window.storage.set("saycrd-highlights", JSON.stringify(highlights)); } catch(e) {}
}
try { loadHighlights(); } catch(e) {}

/* Resonance storage */
async function loadResonance() {
  try { var r = await window.storage.get("saycrd-resonance"); if (r && r.value) state.resonance = JSON.parse(r.value); } catch(e) {}
}
try { loadResonance(); } catch(e) {}

function toggleHighlight(text) {
  var idx = highlights.indexOf(text);
  if (idx >= 0) highlights.splice(idx, 1);
  else highlights.push(text);
  saveHighlights();
}

/* Render the What's Growing viewer — insight-first, not history-first */
function renderGrowing() {
  /* DON'T clear existing content — keep it visible while AI thinks */
  renderReadingGallery();
  if (sessionHistory.length === 0) {
    growingList.innerHTML = "";
    growingEmpty.style.display = "";
    return;
  }
  growingEmpty.style.display = "none";

  if (sessionHistory.length === 1) {
    var s = sessionHistory[0];
    growingList.innerHTML = "";
    var singleWrap = document.createElement("div");
    singleWrap.className = "growing-insight-wrap";
    singleWrap.innerHTML = '<div class="growing-insight-loading"><div class="loading-dots"><span></span><span></span><span></span></div><div class="loading-text">Reading your first session\u2026</div></div>';
    growingList.appendChild(singleWrap);
    runSingleSessionReading(singleWrap, s);

    var demoOffer = document.createElement("div");
    demoOffer.style.cssText = "text-align:center;padding:1.5rem 0 .5rem";
    demoOffer.innerHTML = '<div style="font-size:.75rem;color:var(--ink-soft);margin-bottom:.8rem;opacity:.5">Want to see what cross-session patterns look like?</div><button type="button" id="btn-seed-from-single" style="background:none;border:1px solid rgba(214,178,109,.15);color:var(--accent);padding:.45rem 1.1rem;border-radius:999px;font-family:var(--mono);font-size:.72rem;cursor:pointer;opacity:.6;transition:opacity .2s">Load demo sessions alongside yours</button>';
    growingList.appendChild(demoOffer);
    $("btn-seed-from-single")?.addEventListener("click", function() {
      seedDemoSessions(true);
    });
    return;
  }

  /* 2+ sessions — show a subtle loading indicator OVER existing content, then swap when ready */
  var loadingBanner = document.createElement("div");
  loadingBanner.className = "growing-loading-banner";
  loadingBanner.style.cssText = "position:sticky;top:0;z-index:10;text-align:center;padding:.8rem 1rem;background:rgba(30,28,25,.92);backdrop-filter:blur(8px);border-bottom:1px solid rgba(214,178,109,.08)";
  loadingBanner.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;gap:.8rem"><div class="loading-dots" style="display:flex;gap:.3rem"><span style="width:5px;height:5px;border-radius:50%;background:var(--accent);opacity:.3;animation:dot-pulse 1.2s ease-in-out infinite"></span><span style="width:5px;height:5px;border-radius:50%;background:var(--accent);opacity:.3;animation:dot-pulse 1.2s ease-in-out .2s infinite"></span><span style="width:5px;height:5px;border-radius:50%;background:var(--accent);opacity:.3;animation:dot-pulse 1.2s ease-in-out .4s infinite"></span></div><span style="font-family:Fraunces,serif;font-size:.95rem;color:var(--accent);opacity:.5">Updating across ' + sessionHistory.length + ' sessions\u2026</span></div>';
  
  /* Only add banner if there's existing content to show underneath */
  var hasExisting = growingList.children.length > 0;
  if (hasExisting) {
    growingList.insertBefore(loadingBanner, growingList.firstChild);
  } else {
    /* No existing content — show interim view */
    growingList.innerHTML = "";
  }

  var insightWrap = document.createElement("div");
  insightWrap.className = "growing-insight-wrap";

  if (!hasExisting) {
    /* No old content — show interim content while waiting */
    var interimHtml = '<div style="padding:1.2rem 1.4rem">';
    interimHtml += '<div style="font-family:var(--mono);font-size:.72rem;letter-spacing:.12em;text-transform:uppercase;color:var(--accent);opacity:.5;margin-bottom:1.2rem">Reading across ' + sessionHistory.length + ' sessions\u2026</div>';

    var clarities = sessionHistory.filter(function(s) { return s.clarity; }).slice(-5);
    if (clarities.length > 0) {
      interimHtml += '<div style="margin-bottom:1.4rem">';
      interimHtml += '<div style="font-family:var(--mono);font-size:.68rem;letter-spacing:.1em;text-transform:uppercase;color:var(--ink-soft);opacity:.35;margin-bottom:.6rem">What you\u2019ve named</div>';
      clarities.forEach(function(s) {
        var d = new Date(s.date);
        interimHtml += '<div style="display:flex;gap:.8rem;align-items:baseline;margin-bottom:.5rem;opacity:.6">';
        interimHtml += '<span style="font-family:var(--mono);font-size:.7rem;color:var(--ink-soft);opacity:.5;white-space:nowrap">' + d.toLocaleDateString("en-US", {month:"short",day:"numeric"}) + '</span>';
        interimHtml += '<span style="font-family:Fraunces,serif;font-size:.95rem;color:var(--accent);font-style:italic">\u201C' + s.clarity + '\u201D</span>';
        interimHtml += '</div>';
      });
      interimHtml += '</div>';
    }

    var allThemes = {};
    sessionHistory.forEach(function(s) {
      (s.themes || []).forEach(function(t) { var k = t.label.toLowerCase(); allThemes[k] = (allThemes[k] || 0) + 1; });
    });
    var topThemes = Object.entries(allThemes).sort(function(a,b) { return b[1] - a[1]; }).slice(0, 8);
    if (topThemes.length > 0) {
      interimHtml += '<div style="margin-bottom:1rem">';
      interimHtml += '<div style="font-family:var(--mono);font-size:.68rem;letter-spacing:.1em;text-transform:uppercase;color:var(--ink-soft);opacity:.35;margin-bottom:.6rem">Your recurring landscape</div>';
      interimHtml += '<div style="display:flex;flex-wrap:wrap;gap:.35rem">';
      topThemes.forEach(function(t) {
        var intensity = Math.min(t[1] / sessionHistory.length, 1);
        interimHtml += '<span style="font-size:.78rem;padding:.25rem .7rem;border-radius:999px;background:rgba(214,178,109,' + (0.06 + intensity * 0.15) + ');color:rgba(214,178,109,' + (0.4 + intensity * 0.4) + ');font-family:var(--mono);letter-spacing:.04em">' + t[0] + ' <span style="opacity:.4">' + t[1] + 'x</span></span>';
      });
      interimHtml += '</div></div>';
    }

    interimHtml += '<div class="growing-insight-loading" style="padding:1.5rem 0"><div class="loading-dots"><span></span><span></span><span></span></div><div class="loading-text" style="font-size:.85rem;opacity:.4">Generating deeper patterns\u2026</div></div>';
    interimHtml += '</div>';
    insightWrap.innerHTML = interimHtml;
  }

  /* Always add insightWrap — old content stays visible underneath until this gets filled */
  growingList.appendChild(insightWrap);

  /* When pattern engine replaces insightWrap content, clean up old children + banner */
  if (hasExisting) {
    var oldChildren = Array.from(growingList.children).filter(function(c) { return c !== insightWrap && !c.classList.contains("growing-loading-banner"); });
    var observer = new MutationObserver(function() {
      if (insightWrap.children.length > 0 && !insightWrap.querySelector(".growing-insight-loading")) {
        observer.disconnect();
        var banner = growingList.querySelector(".growing-loading-banner");
        if (banner) banner.remove();
        oldChildren.forEach(function(c) { if (c.parentNode === growingList) c.remove(); });
      }
    });
    observer.observe(insightWrap, { childList: true, subtree: true });
  }

  runPatternEngine(insightWrap);

  /* Collapsed session history at the bottom */
  var historyWrap = document.createElement("div");
  historyWrap.className = "growing-history-wrap";
  var historyToggle = document.createElement("button");
  historyToggle.className = "growing-history-toggle";
  historyToggle.textContent = "Past sessions (" + sessionHistory.length + ")";
  historyToggle.type = "button";
  var historyInner = document.createElement("div");
  historyInner.className = "growing-history-inner";
  historyInner.style.display = "none";

  sessionHistory.slice().reverse().forEach(function(s) {
    var d = new Date(s.date);
    var dateStr = d.toLocaleDateString("en-US", { weekday: "short", month: "short", day: "numeric" });
    var themes = (s.themes || []).map(function(t) { return t.label; }).join(", ");
    var row = document.createElement("div");
    row.className = "growing-history-row";
    row.innerHTML = '<span class="growing-history-date">' + dateStr + '</span><span class="growing-history-themes">' + (themes || "No themes") + '</span>' + (s.clarity ? '<span class="growing-history-clarity">\u201C' + s.clarity + '\u201D</span>' : '');
    historyInner.appendChild(row);
  });

  historyToggle.addEventListener("click", function() {
    var open = historyInner.style.display !== "none";
    historyInner.style.display = open ? "none" : "";
    historyToggle.classList.toggle("open", !open);
  });

  historyWrap.append(historyToggle, historyInner);
  growingList.appendChild(historyWrap);
}

/* ── Pattern Engine: the whole What's Growing experience ── */
async function runPatternEngine(container) {

  /* ── Try loading sessions from DB first (richer, per-session structured data) ── */
  var sessionsForAPI = [];
  var usedDb = false;

  if (currentUser && currentUser.id !== "local-user" && supabaseAvailable) {
    try {
      /* Pull all sessions with their data from normalized tables */
      var dbSessions = await sbClient
        .from("sessions")
        .select("id, created_at, raw_dump, synthesis, original_synthesis, noticing, clarity, hour_of_day, day_of_week, days_since_last")
        .eq("user_id", currentUser.id)
        .order("created_at", { ascending: true });

      if (dbSessions.data && dbSessions.data.length > 0) {
        /* For each session, pull its themes, connections, interactions, guides */
        var sessionIds = dbSessions.data.map(function(s) { return s.id; });

        var [dbThemes, dbConns, dbInteractions, dbGuides] = await Promise.all([
          sbClient.from("session_themes").select("session_id, label, weight, user_added").in("session_id", sessionIds),
          sbClient.from("session_connections").select("session_id, from_label, to_label, label, insight, user_added").in("session_id", sessionIds),
          sbClient.from("session_interactions").select("session_id, interaction_type, prompt, response").in("session_id", sessionIds),
          sbClient.from("session_guides").select("session_id, guide_type, prompt, source_theme, response, echo, skipped").in("session_id", sessionIds)
        ]);

        /* Group by session_id */
        function groupBy(arr, key) {
          var map = {};
          (arr.data || []).forEach(function(item) {
            var k = item[key];
            if (!map[k]) map[k] = [];
            map[k].push(item);
          });
          return map;
        }
        var themesBySession = groupBy(dbThemes, "session_id");
        var connsBySession = groupBy(dbConns, "session_id");
        var interBySession = groupBy(dbInteractions, "session_id");
        var guidesBySession = groupBy(dbGuides, "session_id");

        sessionsForAPI = dbSessions.data.map(function(s, i) {
          var themes = (themesBySession[s.id] || []).map(function(t) {
            var str = t.label + " (weight:" + t.weight + ")";
            if (t.user_added) str += " [USER-ADDED]";
            return str;
          });
          var connections = (connsBySession[s.id] || []).map(function(c) {
            return c.from_label + " → " + c.to_label + (c.label ? " (" + c.label + ")" : "") + (c.insight ? ": " + c.insight : "");
          });
          var interactions = (interBySession[s.id] || []).map(function(inter) {
            if (inter.interaction_type === "reflection") return 'Reading said: "' + (inter.prompt || "").slice(0, 100) + '" → They wrote: "' + (inter.response || "") + '"';
            if (inter.interaction_type === "correction") return 'CORRECTION: "' + (inter.response || "") + '"';
            if (inter.interaction_type === "clarity") return 'Clarity: "' + (inter.response || "") + '"';
            if (inter.interaction_type === "resonance") return 'Resonance on "' + (inter.prompt || "") + '": ' + (inter.response || "");
            return inter.interaction_type + ': "' + (inter.response || "") + '"';
          });
          var guides = (guidesBySession[s.id] || []).map(function(g) {
            var item = { type: g.guide_type, prompt: g.prompt };
            if (g.source_theme) item.source = g.source_theme;
            if (g.response) {
              item.their_answer = g.response;
              /* Detect pushback */
              var lower = (g.response || "").toLowerCase();
              if (lower.indexOf("not") !== -1 || lower.indexOf("don't") !== -1 || lower.indexOf("wasn't") !== -1 || lower.indexOf("actually") !== -1) {
                item.PUSHBACK = true;
                item.correction_note = "User challenged this framing. Do NOT repeat the original characterization.";
              }
            }
            if (g.echo) item.system_echo = g.echo;
            if (g.skipped) item.skipped = true;
            return item;
          });

          var obj = {
            session: i + 1,
            date: s.created_at,
            themes: themes,
            synthesis: s.synthesis || "",
            noticing: s.noticing || "",
            clarity: s.clarity || null,
            raw_words: (s.raw_dump || "").slice(0, 600),
            guide: guides
          };
          if (connections.length) obj.connections = connections;
          if (interactions.length) obj.inline_responses = interactions;
          if (s.hour_of_day !== null) {
            obj.time_of_day = s.hour_of_day < 6 ? "late night" : s.hour_of_day < 12 ? "morning" : s.hour_of_day < 18 ? "afternoon" : "evening";
          }
          if (s.days_since_last !== null) obj.days_since_last = s.days_since_last;
          return obj;
        });

        usedDb = true;
        console.log("Growing: loaded " + sessionsForAPI.length + " sessions from DB (structured)");
      }
    } catch(dbErr) {
      console.warn("Growing: DB load failed, falling back to blob:", dbErr);
      sessionsForAPI = [];
    }
  }

  /* Fall back to blob if DB didn't work */
  if (!usedDb || sessionsForAPI.length === 0) {
    sessionsForAPI = sessionHistory.map(function(s, i) {
    var obj = {
      session: i + 1,
      date: s.date,
      themes: (s.themes || []).map(function(t) {
        var str = t.label + " (weight:" + t.weight + ")";
        if (t.userAdded) str += " [USER-ADDED]";
        return str;
      }),
      synthesis: s.synthesis || "",
      noticing: s.noticing || "",
      clarity: s.clarity || null,
      guide: (s.guide || []).map(function(g, gi) {
        var item = { type: g.type, prompt: g.text };
        if (g.source) item.source = g.source;
        if (g.response) item.their_answer = g.response;
        if (g.skipped) item.skipped = true;
        /* Include guide responses with echoes */
        if (s.guideResponses && s.guideResponses[gi]) {
          var gr = s.guideResponses[gi];
          if (gr.answer) item.their_answer = gr.answer;
          if (gr.echo) item.system_echo = gr.echo;
          if (gr.echoType) item.echo_type = gr.echoType;
          /* Detect pushback: if user's response questions or rejects the framing */
          var lower = (gr.answer || "").toLowerCase();
          if (lower.indexOf("not") !== -1 || lower.indexOf("don't") !== -1 || lower.indexOf("disagree") !== -1 ||
              lower.indexOf("that's not") !== -1 || lower.indexOf("wasn't") !== -1 || lower.indexOf("isn't") !== -1 ||
              lower.indexOf("wouldn't say") !== -1 || lower.indexOf("actually") !== -1 || lower.indexOf("i was") !== -1) {
            item.PUSHBACK = true;
            item.correction_note = "User challenged this framing. System acknowledged. Do NOT repeat the original characterization.";
          }
        }
        return item;
      }),
    };
    /* Raw words — highest signal data */
    if (s.rawDump) obj.raw_words = s.rawDump.slice(0, 600);
    /* Inline interactions — where they responded to the reading in real time */
    if (s.inlineInteractions && s.inlineInteractions.length > 0) {
      obj.inline_responses = s.inlineInteractions.map(function(inter) {
        if (inter.type === "reflection") return 'Reading said: "' + inter.question + '" → They wrote: "' + inter.answer + '"';
        if (inter.type === "correction") return 'They DISAGREED with: "' + inter.question + '" → Said: "' + inter.answer + '"';
        if (inter.type === "clarity") return 'Clarity: "' + inter.answer + '"';
        return inter.answer;
      });
    }
    /* Map behavior — what AI missed that they added */
    if (s.mapBehavior) {
      if (s.mapBehavior.userNodes && s.mapBehavior.userNodes.length > 0) {
        obj.they_added_to_map = s.mapBehavior.userNodes;
      }
      if (s.mapBehavior.userConnections && s.mapBehavior.userConnections.length > 0) {
        obj.they_connected = s.mapBehavior.userConnections.map(function(c) { return c.from + " ↔ " + c.to + (c.label ? " (" + c.label + ")" : ""); });
      }
    }
    /* Timing signals */
    if (s.timing) {
      obj.time_of_day = s.timing.hour < 6 ? "late night" : s.timing.hour < 12 ? "morning" : s.timing.hour < 18 ? "afternoon" : "evening";
      if (s.timing.daysSinceLast !== undefined) obj.days_since_last = s.timing.daysSinceLast;
    }
    if (s.resonance && Object.keys(s.resonance).length > 0) {
      obj.resonance = Object.values(s.resonance).map(function(r) {
        return r.label + ": " + r.value;
      });
    }
    /* Interaction-derived insights */
    if (s.surfacedTension && s.surfacedTension.observation) {
      obj.surfacedTension = s.surfacedTension.observation;
    }
    if (s.mapEvolution) {
      obj.mapEvolution = s.mapEvolution;
    }
    /* Guide engagement depth — which themes they went deep on */
    if (s.nodeEngagement) {
      var engaged = [];
      Object.keys(s.nodeEngagement).forEach(function(k) {
        if (s.nodeEngagement[k] >= 1) engaged.push(k + " (" + s.nodeEngagement[k] + "x engaged)");
      });
      if (engaged.length) obj.engagement_depth = engaged;
    }
    /* Connections that emerged from engagement, not AI */
    if (s.emergedConnections && s.emergedConnections.length) {
      obj.emerged_connections = s.emergedConnections.map(function(c) {
        return c.from + " \u27F7 " + c.to;
      });
    }
    /* Map work — how the user shaped their constellation */
    if (s.mapWork && s.mapWork.choices) {
      var mwConfirmed = [], mwCorrected = [], mwRejected = [];
      Object.keys(s.mapWork.choices).forEach(function(k) {
        var c = s.mapWork.choices[k];
        if (c.choice === "yes") mwConfirmed.push(c.from + " \u2194 " + c.to + " (" + c.label + ")");
        else if (c.correction) mwCorrected.push(c.from + " \u2194 " + c.to + ': user said "' + c.correction + '"');
        else mwRejected.push(c.from + " \u2194 " + c.to + " (" + c.label + ")");
      });
      if (mwConfirmed.length) obj.confirmed_connections = mwConfirmed;
      if (mwCorrected.length) obj.corrected_connections = mwCorrected;
      if (mwRejected.length) obj.rejected_connections = mwRejected;
      if (s.mapWork.added && s.mapWork.added.length) obj.user_added_thoughts = s.mapWork.added;
    }
    /* Legacy connResponses fallback */
    if (!s.mapWork && s.connResponses) {
      var crItems = [];
      Object.keys(s.connResponses).forEach(function(k) {
        var cr = s.connResponses[k];
        if (cr) {
          var line = (cr.from || '') + " \u2194 " + (cr.to || '') + ": " + (cr.choice || cr.value || "responded");
          if (cr.correction) line += ' \u2014 "' + cr.correction + '"';
          if (cr.answer) line += ' \u2014 "' + cr.answer + '"';
          crItems.push(line);
        }
      });
      if (crItems.length) obj.connection_responses = crItems;
    }
    return obj;
  });
  } /* end blob fallback */

  /* Separate current session from history — AI needs to know which is which */
  var latestIdx = sessionsForAPI.length - 1;
  var latestSession = sessionsForAPI[latestIdx];
  var previousSessions = latestIdx > 0 ? sessionsForAPI.slice(0, latestIdx) : [];

  /* Mark the latest session explicitly */
  latestSession.IS_CURRENT_SESSION = true;

  var systemPrompt = 'You are SAYCRD\'s long-memory layer. You see the full arc across sessions. START with the current session, then surface what it reveals about the larger journey.\n\n' +
    'KEY PRINCIPLES:\n' +
    '- The payload contains "current_session" and "previous_sessions." Current session is the ANCHOR.\n' +
    '- The value you provide is CONTINUITY and DEPTH — connecting this session to the journey, and naming what the person might not see from inside their own experience.\n' +
    '- Do NOT project old themes onto the current session if they weren\'t present. But DO notice evolution, deepening, avoidance, or contradiction across sessions.\n' +
    '- Match the session\'s energy. Light session = light reading. But you can note when lightness itself is a shift.\n\n' +
    'WRITING RULES — CRITICAL:\n' +
    '- VARY your sentence openings. NEVER start 3+ sentences with "You" or "You\'ve." Mix structures: start with observations, start with their words, start with the pattern itself, start with what shifted. Example: instead of "You\'ve moved from X to Y. You\'ve started doing Z. You\'ve shown..." write "The movement from X to Y is visible. Where session 3 held urgency, this one holds ease. Something loosened."\n' +
    '- Write TIGHT. Every sentence should earn its place. Cut filler. Cut hedging. If you can say it in 8 words, don\'t use 15.\n' +
    '- Go UNDERNEATH. Don\'t just describe what happened — name what it means. If someone keeps mentioning self-care rituals, the pattern isn\'t "self-care" — it might be "building a container for uncertainty" or "rehearsing gentleness before a hard thing." Look for the function beneath the behavior.\n' +
    '- Name what\'s present but unspoken. Not by labeling it ("you have a blind spot") but by describing the shape of it ("there\'s a consistent gap between the excitement about showing this to others and actually doing it — three sessions now where the sharing stays future-tense").\n' +
    '- Use THEIR language when possible. Their words are more powerful than your analysis.\n\n' +
    'DATA AVAILABLE (in order of signal strength):\n' +
    '- current_session: What they wrote and did TODAY. The anchor.\n' +
    '- previous_sessions: The full journey — arcs, patterns, evolution.\n' +
    '- db_interactions: ALL inline responses, corrections, clarity statements across all sessions.\n' +
    '- db_recurring_themes: Database-verified recurring themes with frequency + avg weight.\n' +
    '- db_recurring_connections: Theme-to-theme connections that recur.\n' +
    '- db_guide_engagement: Response rate to guides.\n' +
    '- db_guide_responses: Actual responses to guide prompts.\n' +
    '- kept_lines: Lines they explicitly asked to keep — SACRED.\n' +
    '- inline_responses: Where they talked back to the reading.\n' +
    '- user_model: System\'s evolving understanding. Build on it — don\'t repeat it.\n' +
    '- personal_ontology: Their CORE FORCES (stable recurring themes) and TENSIONS (how those forces interact). This is the deepest structural data — use it to identify when a core force is active, dormant, evolving, or in tension. If a core tension shows up in the current session, name what it looks like THIS TIME.\n' +
    '- guide_accountability: Tracks their intention→action patterns. total_actions = guide "do" items given across sessions, responded = how many they engaged with, completion_rate = percentage, recent_unfinished = action items they were given but never responded to. If there\'s a pattern of uncommitted actions, the UNSAID or ARC should gently name the gap between intention and follow-through.\n' +
    '- raw_words: Their unfiltered language.\n' +
    '- clarity statements, recurring_pairs, held sections.\n\n' +
    'CORRECTIONS: Items marked PUSHBACK:true — the correction IS the truth. Never repeat rejected characterizations.\n\n' +
    'INTENTION vs ACTION: "I want to" is NOT "I did."\n\n' +
    'CONFIDENCE: Scale certainty to evidence. Never say "obviously" or "clearly." Never say someone is "avoiding" or "performing" unless their words prove it. If they mentioned something casually, treat it as casual — do not dramatize. Short dump = be curious, not declarative.\n\n' +
    'Generate these sections:\n' +
    '1. ARC: 2-3 sentences MAX. Start with THIS session. Connect to the journey. Go underneath — not "what happened" but "what it means." Cut every unnecessary word.\n' +
    '2. RECURRING_GRAVITY: 0-3 items genuinely recurring across 2+ sessions. Each: "label" (2-4 words), "insight" (1 TIGHT sentence — what function does it serve?), "sessions" (count).\n' +
    '3. CONTRADICTION: 0-1. ONE sentence. The shape of it without judging. Omit if none exists.\n' +
    '4. SHIFTS: 1-2 real changes. Each: "label" (2-4 words), "observation" (1 sentence, tight).\n' +
    '5. MIRROR: 1-2 VERBATIM quotes from raw_words. "their_words" exact quote. "what_it_reveals" — 1 sentence, what\'s underneath.\n' +
    '6. UNSAID: 1 sentence. The thing present but unnamed.\n' +
    '7. BECOMING: 1-2 sentences. The movement and the emerging identity. Varied structure.\n\n' +
    'Respond ONLY valid JSON:\n{"arc":"...","recurring_gravity":[{"label":"...","insight":"..."}],"contradiction":{"observation":"..."},"shifts":[{"label":"...","observation":"..."}],"mirror":[{"their_words":"...","what_it_reveals":"..."}],"unsaid":"...","becoming":"..."}';

  /* Load enrichment data */
  var reflections = [];
  try { var rfl = await window.storage.get("saycrd-reflections"); if (rfl && rfl.value) reflections = JSON.parse(rfl.value); } catch(e) {}
  var holds = [];
  try { var hld = await window.storage.get("saycrd-holds"); if (hld && hld.value) holds = JSON.parse(hld.value); } catch(e) {}
  var tapInteractions = [];
  try { var ti = await window.storage.get("saycrd-tap-interactions"); if (ti && ti.value) tapInteractions = JSON.parse(ti.value); } catch(e) {}
  var keptLines = [];
  try { var kpt = await window.storage.get("saycrd-kept-lines"); if (kpt && kpt.value) keptLines = JSON.parse(kpt.value); } catch(e) {}

  /* Load co-occurrence data — theme pairs that recur across sessions */
  var cooccurrence = {};
  try { var coR = await window.storage.get("saycrd-cooccurrence"); if (coR && coR.value) cooccurrence = JSON.parse(coR.value); } catch(e) {}

  /* Load user model — the system's evolving understanding */
  var userModel = "";
  try { var umR = await window.storage.get("saycrd-user-model"); if (umR && umR.value) userModel = umR.value; } catch(e) {}

  /* ── DB Enrichment: pull structured data from normalized tables ── */
  var dbEnrichment = {};
  if (currentUser && currentUser.id !== "local-user" && supabaseAvailable) {
    try {
      /* Recurring themes — themes that appear across multiple sessions */
      var recurResult = await sbClient.rpc("get_recurring_themes", { uid: currentUser.id });
      if (recurResult.data && recurResult.data.length > 0) {
        dbEnrichment.recurring_themes = recurResult.data.map(function(t) {
          return t.label + " (" + t.appearances + " sessions, avg weight " + parseFloat(t.avg_weight).toFixed(1) + ")";
        });
      }

      /* All interactions across sessions — the richest engagement data */
      var interResult = await sbClient
        .from("session_interactions")
        .select("interaction_type, prompt, response, created_at")
        .eq("user_id", currentUser.id)
        .order("created_at", { ascending: false })
        .limit(30);
      if (interResult.data && interResult.data.length > 0) {
        dbEnrichment.all_interactions = interResult.data.map(function(i) {
          var out = { type: i.interaction_type };
          if (i.prompt) out.prompt = i.prompt.slice(0, 150);
          if (i.response) out.response = i.response.slice(0, 300);
          return out;
        });
      }

      /* Theme connections that recur — structural patterns */
      var connResult = await sbClient
        .from("session_connections")
        .select("from_label, to_label, label, insight")
        .eq("user_id", currentUser.id);
      if (connResult.data && connResult.data.length > 0) {
        /* Count connection pairs */
        var connCounts = {};
        connResult.data.forEach(function(c) {
          var pair = [c.from_label, c.to_label].sort().join(" ↔ ");
          if (!connCounts[pair]) connCounts[pair] = { count: 0, labels: [], insights: [] };
          connCounts[pair].count++;
          if (c.label && connCounts[pair].labels.indexOf(c.label) === -1) connCounts[pair].labels.push(c.label);
          if (c.insight && connCounts[pair].insights.indexOf(c.insight) === -1) connCounts[pair].insights.push(c.insight);
        });
        var recurringConns = Object.keys(connCounts)
          .filter(function(k) { return connCounts[k].count >= 2; })
          .sort(function(a, b) { return connCounts[b].count - connCounts[a].count; })
          .slice(0, 8)
          .map(function(k) {
            var c = connCounts[k];
            return k + " (" + c.count + "x" + (c.labels.length ? ", named: " + c.labels.join(", ") : "") + ")";
          });
        if (recurringConns.length) dbEnrichment.recurring_connections = recurringConns;
      }

      /* Guide engagement rate — how often they respond vs skip */
      var guideResult = await sbClient
        .from("session_guides")
        .select("guide_type, skipped, response")
        .eq("user_id", currentUser.id);
      if (guideResult.data && guideResult.data.length > 0) {
        var total = guideResult.data.length;
        var answered = guideResult.data.filter(function(g) { return !g.skipped; }).length;
        dbEnrichment.guide_engagement = {
          total: total,
          answered: answered,
          rate: Math.round((answered / total) * 100) + "%"
        };
        /* Answered guides are the most valuable — include the actual responses */
        var answeredGuides = guideResult.data.filter(function(g) { return !g.skipped && g.response; })
          .slice(-6)
          .map(function(g) { return { type: g.guide_type, response: g.response.slice(0, 200) }; });
        if (answeredGuides.length) dbEnrichment.guide_responses = answeredGuides;
      }

      console.log("DB enrichment loaded:", Object.keys(dbEnrichment));
    } catch(dbErr) {
      console.warn("DB enrichment failed (non-critical):", dbErr);
    }
  }

  var apiPayload = { current_session: latestSession, previous_sessions: previousSessions };
  if (reflections.length > 0) {
    apiPayload.reflections = reflections.slice(-6).map(function(r) {
      var item = { q: r.question, a: r.response };
      if (r.type === "correction") item.correction = true;
      return item;
    });
  }
  if (holds.length > 0) {
    apiPayload.held = holds.slice(-6).map(function(h) {
      return { section: h.section, text: (h.preview || "").slice(0, 80) };
    });
  }
  if (tapInteractions.length > 0) {
    apiPayload.asked = tapInteractions.slice(-5).map(function(t) {
      return { line: (t.line || "").slice(0, 60), said: (t.user_said || "").slice(0, 80) };
    });
  }
  if (keptLines.length > 0) {
    apiPayload.kept_lines = keptLines.slice(-5).map(function(k) {
      return { line: k.line, their_words: k.their_words, session: k.session };
    });
  }

  /* Add co-occurrence — only pairs that appeared 2+ times (the real connections) */
  var strongPairs = Object.keys(cooccurrence).filter(function(k) { return cooccurrence[k] >= 2; })
    .sort(function(a, b) { return cooccurrence[b] - cooccurrence[a]; })
    .slice(0, 8)
    .map(function(k) { return k + " (" + cooccurrence[k] + "x)"; });
  if (strongPairs.length > 0) {
    apiPayload.recurring_pairs = strongPairs;
  }

  /* Add user model if it exists */
  if (userModel) {
    apiPayload.user_model = userModel;
  }

  /* Add personal ontology — core forces + tensions */
  try {
    var ontR = await window.storage.get("saycrd-ontology");
    if (ontR && ontR.value) {
      var ont = JSON.parse(ontR.value);
      if (ont.core_forces && ont.core_forces.length > 0) {
        apiPayload.personal_ontology = {
          core_forces: ont.core_forces,
          tensions: ont.tensions || [],
          session_count: ont.session_count
        };
      }
    }
  } catch(e) {}

  /* Add structured DB enrichment — richer than blob data */
  if (dbEnrichment.recurring_themes) apiPayload.db_recurring_themes = dbEnrichment.recurring_themes;
  if (dbEnrichment.all_interactions) apiPayload.db_interactions = dbEnrichment.all_interactions;
  if (dbEnrichment.recurring_connections) apiPayload.db_recurring_connections = dbEnrichment.recurring_connections;

  /* Guide accountability — intention→action tracking */
  try {
    var tr = await window.storage.get("saycrd-guide-tracker");
    if (tr && tr.value) {
      var tracker = JSON.parse(tr.value);
      var allGuides = [];
      Object.keys(tracker).forEach(function(k) {
        (tracker[k] || []).forEach(function(g) { allGuides.push(g); });
      });
      if (allGuides.length > 0) {
        var doItems = allGuides.filter(function(g) { return g.type === "do" || g.type === "act"; });
        var responded = doItems.filter(function(g) { return g.status === "responded" || g.status === "completed"; });
        apiPayload.guide_accountability = {
          total_actions: doItems.length,
          responded: responded.length,
          completion_rate: doItems.length > 0 ? Math.round(responded.length / doItems.length * 100) : 0,
          recent_unfinished: doItems.filter(function(g) { return g.status === "given"; }).slice(-3).map(function(g) { return g.text; })
        };
      }
    }
  } catch(e) {}
  if (dbEnrichment.guide_engagement) apiPayload.db_guide_engagement = dbEnrichment.guide_engagement;
  if (dbEnrichment.guide_responses) apiPayload.db_guide_responses = dbEnrichment.guide_responses;

  /* Ensure payload fits — truncate previous sessions if needed */
  /* IMPORTANT: Save a clean copy for portrait generation BEFORE truncating */
  var portraitSessions = sessionsForAPI.map(function(s) {
    return JSON.parse(JSON.stringify(s));
  });

  var payloadStr = JSON.stringify(apiPayload);
  var maxPayload = 28000 - systemPrompt.length;
  if (payloadStr.length > maxPayload) {
    /* Pass 1: Trim older sessions' raw words */
    previousSessions.forEach(function(s) {
      if (s.raw_words) s.raw_words = s.raw_words.slice(0, 150) + "...";
    });
    apiPayload.previous_sessions = previousSessions;
    payloadStr = JSON.stringify(apiPayload);
  }
  if (payloadStr.length > maxPayload) {
    /* Pass 2: Trim older sessions' synthesis and guide */
    previousSessions.forEach(function(s) {
      if (s.synthesis) s.synthesis = s.synthesis.slice(0, 80) + "...";
      delete s.guide;
      delete s.resonance;
      delete s.raw_words;
    });
    apiPayload.previous_sessions = previousSessions;
    payloadStr = JSON.stringify(apiPayload);
    /* If still too long, limit previous session count */
    if (payloadStr.length > maxPayload && previousSessions.length > 3) {
      apiPayload.previous_sessions = previousSessions.slice(-3);
      payloadStr = JSON.stringify(apiPayload);
    }
  }

  console.log("Pattern engine: prompt=" + systemPrompt.length + " payload=" + payloadStr.length + " total=" + (systemPrompt.length + payloadStr.length));

  try {
    var raw = await callClaude(systemPrompt, payloadStr, 2500);
    var data = extractJSON(raw);
    container.innerHTML = "";

    /* ════════════════════════════════════════════════════════════════
       CONSOLIDATED GROWING PAGE — infographic style
       ════════════════════════════════════════════════════════════════ */

    /* ── 1. THE ARC — hero section ── */
    if (data.arc) {
      var arcEl = document.createElement("div");
      arcEl.className = "gi-section";
      arcEl.style.cssText = "padding:1.8rem 0 2rem;border-bottom:1px solid rgba(214,178,109,.08)";
      arcEl.innerHTML = '<div style="font-size:.9rem;font-weight:700;text-transform:uppercase;letter-spacing:.2rem;color:var(--accent);opacity:.7;margin-bottom:1rem">\u2728 The Arc</div>' +
        '<div class="gi-arc-text" style="font-family:Fraunces,serif;font-size:1.35rem;color:var(--ink);line-height:1.7;font-weight:300">' + data.arc + '</div>';
      container.appendChild(arcEl);
      try { makeClarifiable(arcEl.querySelector(".gi-arc-text")); } catch(e) {}
    }

    /* ── 2. PATTERNS — gravity + shifts + contradiction in one section ── */
    var hasPatterns = (data.recurring_gravity && data.recurring_gravity.length) || (data.shifts && data.shifts.length) || (data.contradiction && data.contradiction.observation);
    if (hasPatterns) {
      var patEl = document.createElement("div");
      patEl.className = "gi-section";
      patEl.style.cssText = "padding:1.8rem 0 2rem;border-bottom:1px solid rgba(125,183,174,.08)";
      var patHtml = '<div style="font-size:.9rem;font-weight:700;text-transform:uppercase;letter-spacing:.2rem;color:var(--accent-2);opacity:.7;margin-bottom:1.2rem">\u25CE Patterns</div>';

      /* Recurring gravity — compact bullet items */
      if (data.recurring_gravity && data.recurring_gravity.length) {
        data.recurring_gravity.forEach(function(g) {
          patHtml += '<div style="display:flex;align-items:flex-start;gap:.8rem;margin-bottom:1rem">';
          patHtml += '<div style="min-width:8px;width:8px;height:8px;border-radius:50%;background:var(--accent);margin-top:.5rem;flex-shrink:0;box-shadow:0 0 8px rgba(214,178,109,.3)"></div>';
          patHtml += '<div>';
          patHtml += '<div style="font-size:.9rem;font-weight:700;text-transform:uppercase;letter-spacing:.1rem;color:var(--accent);margin-bottom:.25rem">' + g.label + '</div>';
          patHtml += '<div class="gi-gravity-insight" style="font-size:1.1rem;color:var(--ink-soft);line-height:1.6">' + g.insight + '</div>';
          patHtml += '</div></div>';
        });
      }

      /* Shifts — compact with teal accent */
      if (data.shifts && data.shifts.length) {
        data.shifts.forEach(function(s) {
          patHtml += '<div style="display:flex;align-items:flex-start;gap:.8rem;margin-bottom:1rem">';
          patHtml += '<div style="min-width:8px;width:8px;height:8px;border-radius:50%;background:var(--accent-2);margin-top:.5rem;flex-shrink:0;box-shadow:0 0 8px rgba(125,183,174,.3)"></div>';
          patHtml += '<div>';
          patHtml += '<div style="font-size:.9rem;font-weight:700;text-transform:uppercase;letter-spacing:.1rem;color:var(--accent-2);margin-bottom:.25rem">' + s.label + '</div>';
          patHtml += '<div class="gi-shift-text" style="font-size:1.1rem;color:var(--ink-soft);line-height:1.6">' + s.observation + '</div>';
          patHtml += '</div></div>';
        });
      }

      /* Contradiction — coral accent, single line */
      if (data.contradiction && data.contradiction.observation) {
        patHtml += '<div style="display:flex;align-items:flex-start;gap:.8rem;margin-bottom:.5rem">';
        patHtml += '<div style="font-size:1.2rem;color:var(--accent-3);flex-shrink:0;margin-top:.15rem">\u26A1</div>';
        patHtml += '<div>';
        patHtml += '<div style="font-size:.9rem;font-weight:700;text-transform:uppercase;letter-spacing:.1rem;color:var(--accent-3);margin-bottom:.25rem">Contradiction</div>';
        patHtml += '<div class="gi-contradiction-text" style="font-size:1.1rem;color:var(--ink);line-height:1.6">' + data.contradiction.observation + '</div>';
        patHtml += '</div></div>';
      }

      patEl.innerHTML = patHtml;
      container.appendChild(patEl);

      /* Make clarifiable after DOM insertion */
      try {
        patEl.querySelectorAll(".gi-gravity-insight,.gi-shift-text,.gi-contradiction-text").forEach(function(el) { makeClarifiable(el); });
      } catch(e) {}
    }

    /* ── 3. YOUR WORDS + THE DEEPER READ — mirror + unsaid + becoming ── */
    var hasDeeper = (data.mirror && data.mirror.length) || data.unsaid || data.becoming;
    if (hasDeeper) {
      var deepEl = document.createElement("div");
      deepEl.className = "gi-section";
      deepEl.style.cssText = "padding:1.8rem 0 1.5rem";
      var deepHtml = '';

      /* Mirror quotes — large, italic, impactful */
      if (data.mirror && data.mirror.length) {
        data.mirror.forEach(function(m) {
          deepHtml += '<div style="margin-bottom:1.5rem;padding:1rem 0;border-top:1px solid rgba(160,140,200,.06)">';
          deepHtml += '<div style="font-family:Fraunces,serif;font-size:1.25rem;color:var(--ink);font-style:italic;line-height:1.6;margin-bottom:.5rem">\u201C' + m.their_words + '\u201D</div>';
          deepHtml += '<div class="gi-mirror-reveals" style="font-size:1rem;color:#a08cc8;line-height:1.55">' + m.what_it_reveals + '</div>';
          deepHtml += '</div>';
        });
      }

      /* Unsaid + Becoming — compact stacked items */
      if (data.unsaid) {
        deepHtml += '<div style="display:flex;align-items:flex-start;gap:.8rem;margin-bottom:1rem">';
        deepHtml += '<div style="font-size:1.2rem;color:var(--accent-3);opacity:.7;flex-shrink:0;margin-top:.15rem">\u25CC</div>';
        deepHtml += '<div>';
        deepHtml += '<div style="font-size:.85rem;font-weight:700;text-transform:uppercase;letter-spacing:.1rem;color:var(--accent-3);opacity:.7;margin-bottom:.25rem">The Unsaid</div>';
        deepHtml += '<div class="gi-unsaid-text" style="font-size:1.1rem;color:var(--ink-soft);line-height:1.6">' + data.unsaid + '</div>';
        deepHtml += '</div></div>';
      }

      if (data.becoming) {
        deepHtml += '<div style="display:flex;align-items:flex-start;gap:.8rem;margin-bottom:.5rem">';
        deepHtml += '<div style="font-size:1.2rem;color:var(--accent);flex-shrink:0;margin-top:.15rem">\u2736</div>';
        deepHtml += '<div>';
        deepHtml += '<div style="font-size:.85rem;font-weight:700;text-transform:uppercase;letter-spacing:.1rem;color:var(--accent);margin-bottom:.25rem">Who You\u2019re Becoming</div>';
        deepHtml += '<div class="gi-becoming-text" style="font-size:1.15rem;color:var(--accent);line-height:1.6;font-family:Fraunces,serif">' + data.becoming + '</div>';
        deepHtml += '</div></div>';
      }

      deepEl.innerHTML = deepHtml;
      container.appendChild(deepEl);

      /* Make clarifiable after DOM insertion */
      try {
        deepEl.querySelectorAll(".gi-mirror-reveals,.gi-unsaid-text,.gi-becoming-text").forEach(function(el) { makeClarifiable(el); });
      } catch(e) {}
      if (data.becoming) showMapBecoming(data.becoming);
    }

    /* ── Post-reading reflection ── */
    generateReflectionQuestion(container, data);

    /* Store growth data for takeaway card */
    state.growthData = data;

    /* ── User model consolidation — the system learns ── */
    /* After each pattern reading, update the evolving understanding of this person */
    try {
      var modelPrompt = 'You maintain a short evolving summary of a person based on their SAYCRD sessions. This is the system\'s memory — what it has learned about them.\n\n';
      if (userModel) {
        modelPrompt += 'EXISTING MODEL (from previous readings):\n' + userModel + '\n\n';
        modelPrompt += 'Your job: UPDATE this model with new signals. Don\'t repeat what\'s already there — refine it. Strengthen what was confirmed, weaken or remove what was contradicted, add what\'s new.\n\n';
      } else {
        modelPrompt += 'This is the FIRST reading. Create the initial model from scratch.\n\n';
      }

      /* Feed existing ontology for refinement */
      try {
        var ontR = await window.storage.get("saycrd-ontology");
        if (ontR && ontR.value) {
          var existingOnt = JSON.parse(ontR.value);
          if (existingOnt.core_forces && existingOnt.core_forces.length > 0) {
            modelPrompt += 'EXISTING PERSONAL ONTOLOGY (refine, don\'t reinvent):\n';
            modelPrompt += 'Core forces: ' + existingOnt.core_forces.map(function(f) {
              return f.name + ' (weight:' + f.weight + ', ' + (f.active ? 'active' : 'dormant') + ')';
            }).join(', ') + '\n';
            if (existingOnt.tensions && existingOnt.tensions.length > 0) {
              modelPrompt += 'Tensions: ' + existingOnt.tensions.map(function(t) {
                return t.a + ' ↔ ' + t.b + ': ' + t.nature;
              }).join('; ') + '\n';
            }
            modelPrompt += 'This ontology should get MORE STABLE over time. Only change forces if this session provides strong evidence for adding/removing/renaming one.\n\n';
          }
        }
      } catch(e) {}
      modelPrompt += 'LATEST PATTERN ENGINE OUTPUT:\n' + JSON.stringify({ arc: data.arc, gravity: data.recurring_gravity, contradiction: data.contradiction, unsaid: data.unsaid, becoming: data.becoming }) + '\n\n';

      /* Include recent reflections/corrections as calibration */
      if (reflections.length > 0) {
        var recentRef = reflections.slice(-3).map(function(r) {
          return (r.type === "correction" ? "[CORRECTION] " : "[REFLECTION] ") + r.response;
        });
        modelPrompt += 'THEIR RECENT FEEDBACK:\n' + recentRef.join('\n') + '\n\n';
      }

      modelPrompt += 'Write the updated user model. Rules:\n' +
        '- MAX 200 words for the "model" field. Distilled understanding, not summary.\n' +
        '- Include: core patterns, communication style, known blind spots, what lands vs. what misses, corrections to honor.\n' +
        '- Use their actual language where possible (phrases they repeat).\n' +
        '- Flag what you\'re UNCERTAIN about — don\'t overcommit to interpretations.\n' +
        '- If they corrected something, note it explicitly so the system never repeats it.\n' +
        '- Write in second person ("you"), present tense.\n\n' +
        'ALSO generate a "core_forces" array: the 3-5 recurring themes/drives that are STRUCTURALLY central to this person — not just what appeared today, but what keeps appearing across sessions. Each force has:\n' +
        '- "name" (2-4 words — their language when possible)\n' +
        '- "weight" (1-5, how central it is to their inner life)\n' +
        '- "active" (true if it showed up in the latest session, false if dormant)\n' +
        'And a "tensions" array: 1-3 core tensions between forces — the recurring friction points. Each has:\n' +
        '- "a" and "b" (the two force names)\n' +
        '- "nature" (one sentence describing the tension)\n\n' +
        'Think of core_forces as "this person\'s recurring set of inner forces" and tensions as "how those forces interact." This is their personal ontology — it should get MORE STABLE over time, not reinvented each session. Refine what\'s there. Only add/remove a force if there\'s strong evidence.\n\n' +
        'Respond with ONLY valid JSON:\n{"model":"...","core_forces":[{"name":"...","weight":3,"active":true}],"tensions":[{"a":"...","b":"...","nature":"..."}]}';

      var modelRaw = await callClaude(modelPrompt, "Update the user model.", 1200);
      var modelData = extractJSON(modelRaw);
      if (modelData && modelData.model) {
        await window.storage.set("saycrd-user-model", modelData.model);
        console.log("User model updated: " + modelData.model.length + " chars");

        /* Store personal ontology (core forces + tensions) */
        if (modelData.core_forces) {
          var ontology = {
            core_forces: modelData.core_forces,
            tensions: modelData.tensions || [],
            updated: new Date().toISOString(),
            session_count: sessionHistory.length
          };
          await window.storage.set("saycrd-ontology", JSON.stringify(ontology));
          console.log("Ontology updated: " + modelData.core_forces.length + " forces, " + (modelData.tensions || []).length + " tensions");
        }

        /* Also save to normalized user_profiles table */
        if (currentUser && currentUser.id !== "local-user" && supabaseAvailable) {
          sbClient.from("user_profiles").upsert({
            user_id: currentUser.id,
            model_text: modelData.model,
            core_forces: modelData.core_forces || null,
            tensions: modelData.tensions || null,
            updated_at: new Date().toISOString()
          }, { onConflict: "user_id" }).then(function() {
            console.log("DB: User profile + ontology updated");
          }).catch(function(e) { console.warn("DB profile update failed:", e); });
        }
      }
    } catch(modelErr) {
      console.log("User model update skipped:", modelErr);
      /* Non-critical — pattern engine still works without it */
    }

    /* ── Portrait dimensions — the deeper self-portrait (session 3+) ── */
    state.portraitData = null;
    console.log("Portrait check: " + portraitSessions.length + " sessions available (need 3+)");
    if (portraitSessions.length >= 3) {
      /* Show loading indicator while portrait generates */
      var portraitStatus = document.createElement("div");
      portraitStatus.style.cssText = "text-align:center;padding:.8rem;font-size:.8rem;color:var(--ink-soft);opacity:.4;font-style:italic";
      portraitStatus.textContent = "Building your portrait\u2026";
      container.appendChild(portraitStatus);

      try {
        console.log("Portrait: generating...");
        var portraitPrompt = 'You are creating a reflective portrait for the person reading it, based on ' + portraitSessions.length + ' sessions of their writing. Write EVERYTHING in second person — "you," "your," never "they" or "their." You are speaking directly to this person.\n\n' +
          'RULES:\n' +
          '- Write in SECOND PERSON throughout. Say "You value..." not "They value..." Say "Your words reveal..." not "Their words reveal..."\n' +
          '- Everything must be INFERRED from actual words and behavior — never ask, never assume.\n' +
          '- Use raw language as primary evidence. Quote when possible.\n' +
          '- Nothing is scored. Everything is reflected. You\'re a mirror, not a judge.\n' +
          '- If uncertain about something, say so honestly.\n\n' +
          'Generate:\n\n' +
          '1. VALUES (2-3): Core values revealed by language and choices — not what is claimed, but what recurring words and actions reveal. Each: "label" (one word), "evidence" (1 sentence in second person using their raw language), "tension_with" (a value that pulls against this one, if visible — null if not).\n\n' +
          '2. STRENGTHS (2-4): Character strengths showing up consistently across sessions. Draw from: courage, creativity, curiosity, honesty, perseverance, kindness, love, social intelligence, fairness, humility, self-regulation, gratitude, hope, humor, perspective. Each: "name", "evidence" (1 sentence in second person, reference specific moments).\n\n' +
          '3. ALIGNMENT: Where do stated intentions match actual follow-through? And where is there a gap? "coherent" (1 sentence, second person — where words and actions align), "gap" (1 sentence, second person — where there\'s a visible distance between intention and action, or null).\n\n' +
          '4. SELF_AUTHORSHIP: Analyze language for self-directed vs. other-directed motivation. Look for: "I choose/want/believe" (self-authored) vs. "I should/have to/they expect" (externally driven). "signature" (1 sentence, second person), "movement" ("toward_self" / "toward_other" / "stable" / "mixed").\n\n' +
          '5. SEASON: "expansion" / "contraction" / "threshold" / "integration". Just the word.\n\n' +
          '6. EDGE: The dimension where growth is most actively happening between sessions. "label" (2-4 words), "observation" (2 sentences in second person).\n\n' +
          'CRITICAL: Every sentence in values.evidence, strengths.evidence, alignment.coherent, alignment.gap, self_authorship.signature, and edge.observation MUST use "you" or "your" — NEVER "they" or "their".\n\n' +
          'Respond ONLY valid JSON:\n' +
          '{"values":[{"label":"...","evidence":"...","tension_with":"...or null"}],' +
          '"strengths":[{"name":"...","evidence":"..."}],' +
          '"alignment":{"coherent":"...","gap":"...or null"},' +
          '"self_authorship":{"signature":"...","movement":"..."},' +
          '"season":"...","edge":{"label":"...","observation":"..."}}';

        var portraitPayload = JSON.stringify({
          sessions: portraitSessions.slice(-5).map(function(s) {
            return { themes: s.themes, synthesis: (s.synthesis || "").slice(0, 120), raw_words: (s.raw_words || "").slice(0, 600), clarity: s.clarity || "", guide: s.guide };
          })
        });

        console.log("Portrait: payload size = " + portraitPayload.length + " chars");
        var portraitRaw = await callClaude(portraitPrompt, portraitPayload, 1500);
        console.log("Portrait: raw response length = " + (portraitRaw || "").length);
        state.portraitData = extractJSON(portraitRaw);
        if (state.portraitData) {
          console.log("Portrait SUCCESS:", JSON.stringify(state.portraitData).slice(0, 200));
          portraitStatus.textContent = "\u2713 Portrait ready";
          setTimeout(function() { portraitStatus.remove(); }, 2000);
        } else {
          console.warn("Portrait: extractJSON returned null. Raw:", (portraitRaw || "").slice(0, 300));
          portraitStatus.textContent = "Portrait couldn\u2019t parse — check console";
          setTimeout(function() { portraitStatus.remove(); }, 4000);
        }
      } catch(portraitErr) {
        console.error("Portrait FAILED:", portraitErr.message || portraitErr);
        portraitStatus.textContent = "Portrait skipped";
        setTimeout(function() { portraitStatus.remove(); }, 3000);
      }
    }

    /* ── Takeaway button ── */
    var takeawayWrap = document.createElement("div");
    takeawayWrap.style.cssText = "text-align:center;padding:3rem 1.5rem 2rem;margin-top:1.5rem;border-top:1px solid rgba(244,241,234,.06);background:linear-gradient(180deg,transparent,rgba(214,178,109,.03))";
    var takeawayHint = document.createElement("div");
    takeawayHint.style.cssText = "font-size:.85rem;color:var(--ink-soft);margin-bottom:1rem;opacity:.5";
    takeawayHint.textContent = "See everything in one place";
    var takeawayBtn = document.createElement("button");
    takeawayBtn.className = "cta";
    takeawayBtn.style.cssText = "font-size:1rem;padding:.85rem 2.8rem;box-shadow:0 12px 30px rgba(214,178,109,.25)";
    takeawayBtn.textContent = "View your reading \u2192";
    takeawayBtn.addEventListener("click", function() { generateTakeawayCard(); });
    takeawayWrap.append(takeawayHint, takeawayBtn);
    container.appendChild(takeawayWrap);

  } catch(err) {
    var errMsg = (err && err.message) ? err.message : String(err);
    container.innerHTML = '<div style="color:var(--ink-soft);font-size:.95rem;padding:2rem;text-align:center">' +
      '<div style="font-style:italic;margin-bottom:1rem">The pattern reading couldn\u2019t complete.</div>' +
      '<div style="font-size:.85rem;opacity:.4;margin-bottom:1.2rem;word-break:break-word">' + errMsg.slice(0, 200) + '</div>' +
      '<button type="button" class="cta ghost" style="padding:.5rem 1.2rem;font-size:.85rem" id="retry-growing">Try again</button>' +
      '</div>';
    $("retry-growing")?.addEventListener("click", function() { renderGrowing(); });
    console.error("Pattern engine error:", err);
  }
}

/* ── Post-reading reflection: one question, one response, one naming ── */
async function generateReflectionQuestion(container, readingData) {
  /* Build a summary of what the reading contained */
  var readingSummary = "";
  if (readingData.arc) readingSummary += "Arc: " + readingData.arc + "\n";
  if (readingData.recurring_gravity && readingData.recurring_gravity.length) {
    readingSummary += "Recurring themes: " + readingData.recurring_gravity.map(function(g) { return g.label + " — " + g.insight; }).join("; ") + "\n";
  }
  if (readingData.contradiction && readingData.contradiction.observation) {
    readingSummary += "Contradiction: " + readingData.contradiction.observation + "\n";
  }
  if (readingData.unsaid) readingSummary += "The unsaid: " + readingData.unsaid + "\n";
  if (readingData.becoming) readingSummary += "Becoming: " + readingData.becoming + "\n";

  try {
    var questionPrompt = 'You just generated a deep pattern reading for someone. Here is what surfaced:\n\n' +
      readingSummary + '\n' +
      'Now generate ONE question for them to sit with after reading this. Rules:\n' +
      '- The question must be SPECIFIC to their reading — reference something concrete that surfaced\n' +
      '- It should create a productive tension — name a contradiction, an edge, or something they haven\'t said yet\n' +
      '- Not "how does that feel?" — that\'s generic. More like: "The arc says X but the gravity keeps pulling you to Y — which one are you protecting?"\n' +
      '- Short. One sentence. Warm but unflinching.\n' +
      '- 2nd person.\n\n' +
      'Respond with ONLY valid JSON:\n{"question":"..."}';

    var raw = await callClaude(questionPrompt, "Generate the reflection question.");
    var qData = extractJSON(raw);
    var question = qData.question;
    if (!question) return;

    /* Render the reflection card */
    var refEl = document.createElement("div");
    refEl.className = "gi-section gi-reflection";

    var head = document.createElement("div");
    head.className = "gi-head";
    head.style.justifyContent = "center";
    head.innerHTML = '<div class="gi-icon">\u25EF</div><div class="gi-label">One More Thing</div>';

    var qEl = document.createElement("div");
    qEl.className = "gi-reflection-question";
    qEl.textContent = question;

    var inputEl = document.createElement("textarea");
    inputEl.className = "gi-reflection-input";
    inputEl.placeholder = "Take your time\u2026";
    inputEl.rows = 3;

    var hint = document.createElement("div");
    hint.className = "gi-reflection-hint";
    hint.textContent = "Enter to share \u00B7 Only you and the system will see this";

    /* Correction toggle */
    var corrToggle = document.createElement("div");
    corrToggle.className = "gi-reflection-toggle";
    corrToggle.textContent = "Something in the reading wasn\u2019t right \u2192";
    var isCorrection = false;
    var originalQuestion = question;

    corrToggle.addEventListener("click", function() {
      if (!isCorrection) {
        isCorrection = true;
        qEl.textContent = "What did the reading get wrong \u2014 and what\u2019s more true?";
        inputEl.placeholder = "Tell the system where it missed\u2026";
        hint.textContent = "Enter to save \u00B7 This corrects the next reading";
        corrToggle.textContent = "\u2190 Back to the question";
      } else {
        isCorrection = false;
        qEl.textContent = originalQuestion;
        inputEl.placeholder = "Take your time\u2026";
        hint.textContent = "Enter to share \u00B7 Only you and the system will see this";
        corrToggle.textContent = "Something in the reading wasn\u2019t right \u2192";
      }
    });

    refEl.append(head, qEl, inputEl, hint, corrToggle);
    container.appendChild(refEl);

    /* Handle response */
    inputEl.addEventListener("keydown", async function(ke) {
      if (ke.key === "Enter" && !ke.shiftKey && inputEl.value.trim().length > 0) {
        ke.preventDefault();
        var response = inputEl.value.trim();

        /* Disable input */
        inputEl.disabled = true;
        inputEl.style.opacity = ".5";
        hint.textContent = "";
        corrToggle.style.display = "none";

        /* Save immediately */
        var reflectionRecord = {
          date: new Date().toISOString(),
          question: isCorrection ? "CORRECTION: What did the reading get wrong?" : question,
          response: response,
          type: isCorrection ? "correction" : "reflection",
          reading_arc: readingData.arc || "",
          reading_unsaid: readingData.unsaid || ""
        };
        try {
          var existing = [];
          try { var r = await window.storage.get("saycrd-reflections"); if (r && r.value) existing = JSON.parse(r.value); } catch(e) {}
          existing.push(reflectionRecord);
          await window.storage.set("saycrd-reflections", JSON.stringify(existing));
        } catch(ex) {}
        logInteraction(isCorrection ? "correction" : "reflection", { question: question, answer: response });

        /* Generate the naming sentence */
        try {
          var namingPrompt;
          if (isCorrection) {
            namingPrompt = 'The user just corrected their pattern reading. They said the reading got something wrong.\n\n' +
              'Their correction:\n"' + response + '"\n\n' +
              'Generate ONE short sentence. Rules:\n' +
              '- Acknowledge you heard the correction. Don\'t defend the reading.\n' +
              '- Show you take their word as truth — they know themselves better.\n' +
              '- Short. Under 15 words. Warm, not apologetic.\n' +
              '- Tone: "Got it. That changes things." / "Good. Now the system knows." / "That distinction matters."\n\n' +
              'Respond with ONLY valid JSON:\n{"naming":"..."}';
          } else {
            namingPrompt = 'The user just read their pattern reading and you asked them:\n"' + question + '"\n\n' +
              'They responded:\n"' + response + '"\n\n' +
              'Generate ONE short sentence in response. Rules:\n' +
              '- Not an insight. Not a reflection. A NAMING — acknowledge what they just did.\n' +
              '- Prove you actually read what they wrote. Reference something specific.\n' +
              '- Short enough to feel like a breath. Under 15 words.\n' +
              '- Warm. Not clinical. Not therapeutic. Human.\n' +
              '- Examples of the right tone: "That\'s the thing underneath the thing." / "You just named what the reading was circling." / "That\'s been waiting to be said."\n\n' +
              'Respond with ONLY valid JSON:\n{"naming":"..."}';
          }

          var namingRaw = await callClaude(namingPrompt, "Their response: " + response);
          var namingData = extractJSON(namingRaw);
          var naming = namingData.naming || "Heard.";

          /* Replace input with naming */
          inputEl.remove();
          hint.remove();
          if (corrToggle.parentNode) corrToggle.remove();

          var responseWrap = document.createElement("div");
          responseWrap.className = "gi-reflection-response";

          var namingEl = document.createElement("div");
          namingEl.className = "gi-reflection-naming";
          namingEl.textContent = naming;

          var savedEl = document.createElement("div");
          savedEl.className = "gi-reflection-saved";
          savedEl.textContent = isCorrection ? "Correction saved. The system won\u2019t repeat that." : "Saved. This shapes the next reading.";

          responseWrap.append(namingEl, savedEl);
          refEl.appendChild(responseWrap);

        } catch(namingErr) {
          /* Graceful fallback — still saved */
          inputEl.remove();
          hint.remove();
          if (corrToggle.parentNode) corrToggle.remove();
          var fallback = document.createElement("div");
          fallback.className = "gi-reflection-response";
          fallback.innerHTML = '<div class="gi-reflection-naming">' + (isCorrection ? "Noted." : "Heard.") + '</div><div class="gi-reflection-saved">' + (isCorrection ? "Correction saved. The system won\u2019t repeat that." : "Saved. This shapes the next reading.") + '</div>';
          refEl.appendChild(fallback);
        }
      }
    });
  } catch(err) {
    console.error("Reflection question error:", err);
    /* Non-critical — just don't show the reflection card */
  }
}

/* ── Reading Storage ── */
async function saveCurrentReading(sd, gd, dateStr, sessionCount) {
  try {
    var readings = [];
    try {
      var stored = await window.storage.get("saycrd-readings");
      if (stored && stored.value) readings = JSON.parse(stored.value);
    } catch(e) {}

    /* Compact the data — only what's needed to re-render */
    var reading = {
      id: Date.now().toString(36),
      date: new Date().toISOString(),
      dateStr: dateStr,
      sessionCount: sessionCount,
      synthesisData: {
        themes: sd.themes || [],
        connections: sd.connections || [],
        synthesis: sd.synthesis || "",
        map_title: sd.map_title || "",
        guide: sd.guide || [],
        noticing: sd.noticing || ""
      },
      growthData: gd ? {
        arc: gd.arc || "",
        recurring_gravity: gd.recurring_gravity || [],
        contradiction: gd.contradiction || null,
        shifts: gd.shifts || [],
        mirror: gd.mirror || [],
        unsaid: gd.unsaid || "",
        becoming: gd.becoming || ""
      } : null,
      portraitData: (state.portraitData) ? state.portraitData : null
    };

    /* Don't duplicate — check if same date already exists */
    var today = new Date().toISOString().slice(0,10);
    readings = readings.filter(function(r) {
      return r.date.slice(0,10) !== today;
    });
    readings.push(reading);

    /* Keep last 20 readings max */
    if (readings.length > 20) readings = readings.slice(-20);

    await window.storage.set("saycrd-readings", JSON.stringify(readings));
  } catch(e) {
    console.warn("Could not save reading:", e);
  }
}

async function loadReadings() {
  try {
    var stored = await window.storage.get("saycrd-readings");
    if (stored && stored.value) return JSON.parse(stored.value);
  } catch(e) {}
  return [];
}

async function renderReadingGallery() {
  var gallery = document.getElementById("reading-gallery");
  if (!gallery) return;

  var readings = await loadReadings();
  if (readings.length === 0) { gallery.style.display = "none"; return; }

  gallery.style.display = "";
  gallery.innerHTML = '';

  var title = document.createElement("div");
  title.className = "reading-gallery-title";
  title.textContent = "Past Readings";
  gallery.appendChild(title);

  var row = document.createElement("div");
  row.className = "reading-gallery-row";

  /* Most recent first */
  readings.slice().reverse().forEach(function(r, i) {
    var card = document.createElement("div");
    card.className = "reading-gallery-card" + (i === 0 ? " rgc-current" : "");

    var d = new Date(r.date);
    var dStr = d.toLocaleDateString("en-US", { month: "short", day: "numeric" });

    var mapTitle = (r.synthesisData && r.synthesisData.map_title) || "";
    var themes = (r.synthesisData && r.synthesisData.themes) ?
      r.synthesisData.themes.map(function(t) { return t.label; }).join(", ") : "";

    card.innerHTML = '<div class="rgc-date">' + dStr + '</div>' +
      '<div class="rgc-title">' + (mapTitle || "Session reading") + '</div>' +
      (themes ? '<div class="rgc-themes">' + themes + '</div>' : '');

    card.addEventListener("click", function() {
      generateTakeawayCard(r);
    });

    row.appendChild(card);
  });

  gallery.appendChild(row);
}

/* ── Takeaway Card Generator v5 — THE GIFT ── */
async function generateTakeawayCard(storedReading) {
  var sd = storedReading ? storedReading.synthesisData : (state.synthesisData || {});
  var gd = storedReading ? storedReading.growthData : (state.growthData || {});
  var pd = storedReading ? (storedReading.portraitData || null) : (state.portraitData || null);
  var session = storedReading ? {} : (state.currentSession || {});
  var sessions = [];
  try { var sh = await window.storage.get("saycrd-sessions"); if (sh && sh.value) sessions = JSON.parse(sh.value); } catch(e) {}
  var holds = [];
  try { var hld = await window.storage.get("saycrd-holds"); if (hld && hld.value) holds = JSON.parse(hld.value); } catch(e) {}
  var reflections = [];
  try { var rfl = await window.storage.get("saycrd-reflections"); if (rfl && rfl.value) reflections = JSON.parse(rfl.value); } catch(e) {}
  var keptLines = [];
  try { var kpt = await window.storage.get("saycrd-kept-lines"); if (kpt && kpt.value) keptLines = JSON.parse(kpt.value); } catch(e) {}

  var now = storedReading ? new Date(storedReading.date) : new Date();
  var dateStr = now.toLocaleDateString("en-US", { month: "long", day: "numeric", year: "numeric" });
  var sessionCount = storedReading ? (storedReading.sessionCount || sessions.length) : sessions.length;

  /* ── Season-driven palette ── */
  var season = (pd && pd.season) ? pd.season : "default";
  var seasonPalette = {
    expansion: { primary: "244,196,109", secondary: "255,218,140", bg: "#0d0f08", accent: "rgba(244,196,109,.85)", glow: "rgba(255,218,140,.12)", label: "Season of Expansion" },
    contraction: { primary: "140,165,195", secondary: "100,140,180", bg: "#080a0f", accent: "rgba(140,165,195,.85)", glow: "rgba(100,140,180,.1)", label: "Season of Contraction" },
    threshold: { primary: "244,196,109", secondary: "240,139,115", bg: "#0a0808", accent: "rgba(244,196,109,.95)", glow: "rgba(240,139,115,.12)", label: "Season of Threshold" },
    integration: { primary: "180,195,170", secondary: "155,200,185", bg: "#090d0b", accent: "rgba(180,195,170,.85)", glow: "rgba(155,200,185,.1)", label: "Season of Integration" },
    default: { primary: "244,196,109", secondary: "94,211,192", bg: "#060910", accent: "rgba(244,196,109,.85)", glow: "rgba(214,178,109,.08)", label: "" }
  };
  var sp = seasonPalette[season] || seasonPalette["default"];

  var si = 0;
  function sc() { si++; return 'tk-s tk-d' + Math.min(si, 20); }
  function esc(s) { return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  /* Symbol map for guide types */
  var guideIcons = { act: '\u2192', sit: '\u25CB', deepen: '\u25C7', release: '\u2197', surrender: '\u221E', do: '\u2192', notice: '\u25CE', ask: '\u25C7' };
  /* Color map */
  var colors = ['244,196,109','94,211,192','240,139,115','154,208,255','180,160,220'];

  var html = '<button class="takeaway-close" aria-label="Close">\u00D7</button>';

  /* ── Card header: brand + date ── */
  html += '<div style="padding:3rem 2rem 2rem;text-align:center">';
  html += '<div style="font-size:3.2rem;letter-spacing:.6em;color:rgba('+sp.primary+',.85);text-transform:uppercase;font-weight:700;font-family:Space Grotesk,sans-serif;text-indent:.6em">SAYCRD</div>';
  html += '<div style="font-size:1.3rem;color:rgba(247,241,231,.92);margin-top:.7rem;font-family:Fraunces,serif;font-weight:300;letter-spacing:.04em">'+dateStr+(sessionCount>1?' \u00B7 Session '+sessionCount:'')+'</div>';
  if (sp.label && pd) {
    html += '<div style="font-size:1.08rem;letter-spacing:.2em;text-transform:uppercase;color:rgba('+sp.primary+',.85);margin-top:.6rem;font-family:Space Grotesk,sans-serif">'+sp.label+'</div>';
  }
  html += '</div>';

  /* ════════════════════════════════════════════════════════════════
     1. CONSTELLATION — dramatic size range, proper spacing
     ════════════════════════════════════════════════════════════════ */
  if (sd.themes && sd.themes.length) {
    var themes = sd.themes;
    var conns = sd.connections || [];
    var W = 600, H = 560;
    var cx = W/2, cy = H/2;

    /* Find weight range */
    var maxW = 1, minW = 5;
    themes.forEach(function(t) {
      var w = t.weight||1;
      if (w > maxW) maxW = w;
      if (w < minW) minW = w;
    });
    var wRange = Math.max(maxW - minW, 1);

    /* Build nodes with DRAMATIC size differences */
    var nodes = [];
    var aStep = (Math.PI * 2) / themes.length;
    themes.forEach(function(t, i) {
      var w = t.weight || 1;
      var norm = (w - minW) / wRange; /* 0..1 */
      var r = 18 + norm * 50; /* 18px to 68px — huge range */
      var angle = aStep * i - Math.PI / 2;
      var dist = 50 + (1 - norm) * 120; /* heavy = center, light = outer */
      nodes.push({
        x: cx + Math.cos(angle) * dist,
        y: cy + Math.sin(angle) * dist,
        r: r, label: t.label, weight: w, norm: norm,
        col: colors[i % colors.length]
      });
    });

    /* Force separation — 200 iters, very aggressive spacing */
    for (var iter = 0; iter < 200; iter++) {
      for (var a = 0; a < nodes.length; a++) {
        for (var b = a+1; b < nodes.length; b++) {
          var dx = nodes[b].x - nodes[a].x;
          var dy = nodes[b].y - nodes[a].y;
          var d = Math.sqrt(dx*dx + dy*dy) || 1;
          /* Min distance: sum of radii + 60px for labels */
          var minD = nodes[a].r + nodes[b].r + 65;
          if (d < minD) {
            var f = (minD - d) * 0.22;
            nodes[a].x -= (dx/d)*f; nodes[a].y -= (dy/d)*f;
            nodes[b].x += (dx/d)*f; nodes[b].y += (dy/d)*f;
          }
        }
        /* Very gentle center pull */
        nodes[a].x += (cx - nodes[a].x) * 0.003;
        nodes[a].y += (cy - nodes[a].y) * 0.003;
        /* Generous bounds */
        var pad = nodes[a].r + 50;
        nodes[a].x = Math.max(pad, Math.min(W - pad, nodes[a].x));
        nodes[a].y = Math.max(55 + nodes[a].r, Math.min(H - 20 - nodes[a].r, nodes[a].y));
      }
    }

    var svg = '<svg viewBox="0 0 '+W+' '+H+'" xmlns="http://www.w3.org/2000/svg">';

    /* Defs */
    svg += '<defs>';
    svg += '<radialGradient id="tkA1"><stop offset="0%" stop-color="rgba(244,196,109,.06)"/><stop offset="100%" stop-color="transparent"/></radialGradient>';
    svg += '<radialGradient id="tkA2"><stop offset="0%" stop-color="rgba(94,211,192,.04)"/><stop offset="100%" stop-color="transparent"/></radialGradient>';
    svg += '<filter id="tkG"><feGaussianBlur stdDeviation="3" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
    svg += '<filter id="tkG2"><feGaussianBlur stdDeviation="8" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
    svg += '</defs>';

    /* Ambient */
    svg += '<circle cx="'+cx+'" cy="'+cy+'" r="240" fill="url(#tkA1)"/>';
    svg += '<circle cx="'+(cx+80)+'" cy="'+(cy-60)+'" r="180" fill="url(#tkA2)"/>';

    /* Connection lines — thick, glowing, labeled */
    conns.forEach(function(c, ci) {
      var fromN = null, toN = null;
      nodes.forEach(function(n) { if (n.label===c.from) fromN=n; if (n.label===c.to) toN=n; });
      if (fromN && toN) {
        var mx = (fromN.x+toN.x)/2, my = (fromN.y+toN.y)/2;
        var ddx = toN.x-fromN.x, ddy = toN.y-fromN.y;
        var len = Math.sqrt(ddx*ddx+ddy*ddy)||1;
        var offX = (-ddy/len)*22, offY = (ddx/len)*22;
        var col = colors[ci % colors.length];
        /* Glow */
        svg += '<path d="M'+fromN.x+','+fromN.y+' Q'+(mx+offX)+','+(my+offY)+' '+toN.x+','+toN.y+'" fill="none" stroke="rgba('+col+',.06)" stroke-width="10" filter="url(#tkG2)"/>';
        /* Line */
        svg += '<path d="M'+fromN.x+','+fromN.y+' Q'+(mx+offX)+','+(my+offY)+' '+toN.x+','+toN.y+'" fill="none" stroke="rgba('+col+',.25)" stroke-width="2"/>';
        /* Label */
        if (c.label) {
          svg += '<text x="'+(mx+offX*0.3)+'" y="'+(my+offY*0.3-7)+'" text-anchor="middle" fill="rgba('+col+',.55)" font-size="14" font-family="Space Grotesk,sans-serif" letter-spacing=".06em" font-weight="700">'+esc(c.label.toUpperCase())+'</text>';
        }
      }
    });

    /* Theme nodes — each a different color, dramatic sizing */
    nodes.forEach(function(n) {
      var col = n.col;
      var w = n.weight;

      /* Animated pulse ring for heaviest */
      if (n.norm >= 0.7) {
        svg += '<circle cx="'+n.x+'" cy="'+n.y+'" r="'+(n.r+25)+'" fill="none" stroke="rgba('+col+',.08)" stroke-width="1">';
        svg += '<animate attributeName="r" values="'+(n.r+20)+';'+(n.r+30)+';'+(n.r+20)+'" dur="4s" repeatCount="indefinite"/>';
        svg += '<animate attributeName="opacity" values="1;.2;1" dur="4s" repeatCount="indefinite"/>';
        svg += '</circle>';
        svg += '<circle cx="'+n.x+'" cy="'+n.y+'" r="'+(n.r+14)+'" fill="rgba('+col+',.015)" stroke="rgba('+col+',.1)" stroke-width=".8"/>';
      }
      if (n.norm >= 0.4) {
        svg += '<circle cx="'+n.x+'" cy="'+n.y+'" r="'+(n.r+8)+'" fill="none" stroke="rgba('+col+',.07)" stroke-width=".6"/>';
      }

      /* Main circle */
      var fillOp = 0.05 + n.norm * 0.08;
      var strokeOp = 0.2 + n.norm * 0.3;
      svg += '<circle cx="'+n.x+'" cy="'+n.y+'" r="'+n.r+'" fill="rgba('+col+','+fillOp+')" stroke="rgba('+col+','+strokeOp+')" stroke-width="1.5"/>';

      /* Bright core — size scales with weight */
      var coreR = 2.5 + n.norm * 5;
      svg += '<circle cx="'+n.x+'" cy="'+n.y+'" r="'+coreR+'" fill="rgba('+col+','+(0.3+n.norm*0.4)+')" filter="url(#tkG)"/>';

      /* Label — NEVER cut off */
      var label = n.label;
      var fSize = n.r >= 50 ? 15 : (n.r >= 35 ? 13.5 : 12.5);
      var maxCharsPerLine = n.r >= 50 ? 14 : (n.r >= 35 ? 11 : 20);
      var labelInside = n.r >= 35;

      var words = label.split(' ');
      var lines = []; var line = '';
      words.forEach(function(wd) {
        if ((line+' '+wd).trim().length > maxCharsPerLine && line) { lines.push(line.trim()); line = wd; }
        else { line = (line+' '+wd).trim(); }
      });
      if (line) lines.push(line);

      var lh = fSize * 1.35;
      if (labelInside) {
        var startY = n.y - ((lines.length-1)*lh)/2 + fSize*0.35;
        lines.forEach(function(l, li) {
          svg += '<text x="'+n.x+'" y="'+(startY+li*lh)+'" text-anchor="middle" fill="rgba(247,241,231,.88)" font-size="'+fSize+'" font-family="Space Grotesk,sans-serif" font-weight="600">'+esc(l)+'</text>';
        });
      } else {
        var startY2 = n.y + n.r + 16;
        lines.forEach(function(l, li) {
          svg += '<text x="'+n.x+'" y="'+(startY2+li*lh)+'" text-anchor="middle" fill="rgba(247,241,231,.65)" font-size="'+fSize+'" font-family="Space Grotesk,sans-serif" font-weight="600">'+esc(l)+'</text>';
        });
      }

      /* Weight badge for >= 3 */
      if (w >= 3) {
        var bx = n.x + n.r * 0.7, by = n.y - n.r * 0.7;
        svg += '<circle cx="'+bx+'" cy="'+by+'" r="8" fill="rgba('+col+',.15)" stroke="rgba('+col+',.3)" stroke-width=".8"/>';
        svg += '<text x="'+bx+'" y="'+(by+3.5)+'" text-anchor="middle" fill="rgba('+col+',.8)" font-size="11.5" font-family="Space Grotesk,sans-serif" font-weight="700">'+w+'</text>';
      }
    });

    svg += '</svg>';
    html += '<div class="tk-constellation '+sc()+'">'+svg+'</div>';
  }

  /* ════════════════════════════════════════════════════════════════
     MAP TITLE — huge, unmissable
     ════════════════════════════════════════════════════════════════ */
  if (sd.map_title) {
    html += '<div class="tk-map-title '+sc()+'">';
    html += '<div class="tk-map-title-text">'+esc(sd.map_title)+'</div>';
    html += '<div class="tk-map-title-sub">\u25C8 The shape of what\u2019s present</div>';
    html += '</div>';
  }

  /* ════════════════════════════════════════════════════════════════
     2. THE READING — large, bright pullquote
     ════════════════════════════════════════════════════════════════ */
  if (sd.synthesis) {
    html += '<div class="tk-reading '+sc()+'"><div class="tk-reading-text">'+sd.synthesis+'</div></div>';
  }


  html += '<div class="tk-div"></div>';

  /* ════════════════════════════════════════════════════════════════
     CONSOLIDATED CARD — clean infographic layout
     ════════════════════════════════════════════════════════════════ */

  /* ── 1. WHAT SURFACED — connections + guide as bullet items ── */
  var hasSurfaced = (sd.connections && sd.connections.length) || (sd.guide && sd.guide.length);
  if (hasSurfaced) {
    html += '<div class="'+sc()+'" style="padding:1rem 2rem 1.2rem">';
    html += '<div style="font-size:1.8rem;font-weight:300;letter-spacing:.3rem;text-transform:uppercase;color:rgba('+sp.primary+',.85);font-family:Space Grotesk,sans-serif;margin-bottom:1.2rem">What Surfaced</div>';

    /* Connections as compact rows */
    if (sd.connections && sd.connections.length) {
      sd.connections.forEach(function(c) {
        html += '<div style="display:flex;align-items:flex-start;gap:.8rem;margin-bottom:.9rem">';
        html += '<div style="min-width:6px;width:6px;height:6px;border-radius:50%;background:rgba(244,196,109,.7);margin-top:.55rem;flex-shrink:0;box-shadow:0 0 8px rgba(244,196,109,.3)"></div>';
        html += '<div>';
        html += '<div style="font-size:1.08rem;letter-spacing:.08em;text-transform:uppercase;color:rgba(244,196,109,.85);font-family:Space Grotesk,sans-serif;font-weight:600;margin-bottom:.2rem">'+esc(c.from)+' \u27F7 '+esc(c.to)+'</div>';
        if (c.insight) html += '<div style="font-size:1.12rem;color:rgba(247,241,231,.92);font-family:Fraunces,serif;line-height:1.55">'+esc(c.insight)+'</div>';
        html += '</div></div>';
      });
    }

    /* Guide items as compact rows */
    if (sd.guide && sd.guide.length) {
      var guideIcn = { do:'\u25B9', notice:'\u25CB', ask:'\u003F', release:'\u2192', act:'\u25B9', sit:'\u25CB', deepen:'\u003F', surrender:'\u2192' };
      var guideCols = { do:'94,211,192', notice:'154,208,255', ask:'244,196,109', release:'240,139,115', act:'94,211,192', sit:'154,208,255', deepen:'244,196,109', surrender:'240,139,115' };
      sd.guide.forEach(function(g) {
        var gc = guideCols[g.type] || '94,211,192';
        html += '<div style="display:flex;align-items:flex-start;gap:.8rem;margin-bottom:.7rem">';
        html += '<div style="min-width:22px;width:22px;height:22px;border-radius:50%;background:rgba('+gc+',.1);border:1px solid rgba('+gc+',.25);display:flex;align-items:center;justify-content:center;font-size:1.08rem;color:rgba('+gc+',.8);flex-shrink:0;margin-top:.15rem">'+(guideIcn[g.type]||'\u2022')+'</div>';
        html += '<div style="font-size:1.12rem;color:rgba(247,241,231,.92);font-family:Fraunces,serif;line-height:1.55">'+esc(g.text || g.prompt || g.action || g.label || '')+'</div>';
        html += '</div>';
      });
    }
    html += '</div>';
    html += '<div class="tk-div"></div>';
  }

  /* ── 2. PATTERNS — gravity bars + arc + big stat numbers ── */
  var hasPatterns = (gd.recurring_gravity && gd.recurring_gravity.length) || sessionCount > 1;
  if (hasPatterns) {
    html += '<div class="'+sc()+'" style="padding:1rem 2rem 1.2rem">';
    html += '<div style="font-size:1.8rem;font-weight:300;letter-spacing:.3rem;text-transform:uppercase;color:rgba(240,139,115,.85);font-family:Space Grotesk,sans-serif;margin-bottom:1rem">Patterns</div>';

    /* Big stat row */
    var themeCount = (sd.themes || []).length;
    var connCount = (sd.connections || []).length;
    html += '<div style="display:flex;gap:2rem;margin-bottom:1.3rem;flex-wrap:wrap">';
    html += '<div style="text-align:center"><div style="font-size:2.8rem;font-weight:200;color:rgba(244,196,109,.9);font-family:Space Grotesk,sans-serif;line-height:1">'+themeCount+'</div><div style="font-size:1.12rem;letter-spacing:.12em;text-transform:uppercase;color:rgba(244,196,109,.85);font-family:Space Grotesk,sans-serif">themes</div></div>';
    html += '<div style="text-align:center"><div style="font-size:2.8rem;font-weight:200;color:rgba(94,211,192,.9);font-family:Space Grotesk,sans-serif;line-height:1">'+connCount+'</div><div style="font-size:1.12rem;letter-spacing:.12em;text-transform:uppercase;color:rgba(94,211,192,.85);font-family:Space Grotesk,sans-serif">connections</div></div>';
    html += '<div style="text-align:center"><div style="font-size:2.8rem;font-weight:200;color:rgba(240,139,115,.9);font-family:Space Grotesk,sans-serif;line-height:1">'+sessionCount+'</div><div style="font-size:1.12rem;letter-spacing:.12em;text-transform:uppercase;color:rgba(240,139,115,.85);font-family:Space Grotesk,sans-serif">session'+(sessionCount!==1?'s':'')+'</div></div>';
    html += '</div>';

    /* Gravity bars — compact */
    if (gd.recurring_gravity && gd.recurring_gravity.length) {
      var gItems = gd.recurring_gravity.slice(0,5);
      var maxWeight = gItems[0] ? (gItems[0].weight || gItems[0].sessions || 5) : 5;
      gItems.forEach(function(g, i) {
        var pct = Math.round(((g.weight || g.sessions || 1) / maxWeight) * 100);
        var col = colors[i % colors.length];
        html += '<div style="display:flex;align-items:center;gap:.8rem;margin-bottom:.5rem">';
        html += '<div style="width:90px;font-size:1.1rem;color:rgba('+col+',.8);font-family:Space Grotesk,sans-serif;font-weight:600;text-align:right;flex-shrink:0">'+esc(g.label)+'</div>';
        html += '<div style="flex:1;height:8px;background:rgba(247,241,231,.04);border-radius:4px;overflow:hidden"><div style="width:'+pct+'%;height:100%;background:rgba('+col+',.6);border-radius:4px;box-shadow:0 0 12px rgba('+col+',.2)"></div></div>';
        html += '</div>';
      });
    }

    /* Arc timeline — minimal */
    if (sessionCount > 1) {
      html += '<div style="margin-top:1.2rem">';
      var aW = 520, aH = 50;
      var asvg = '<svg viewBox="0 0 '+aW+' '+aH+'" xmlns="http://www.w3.org/2000/svg">';
      asvg += '<defs><linearGradient id="ag5" x1="0" y1="0" x2="1" y2="0"><stop offset="0%" stop-color="rgba(244,196,109,.1)"/><stop offset="50%" stop-color="rgba(94,211,192,.35)"/><stop offset="100%" stop-color="rgba(244,196,109,.5)"/></linearGradient></defs>';
      var lineY = 20;
      asvg += '<line x1="20" y1="'+lineY+'" x2="'+(aW-20)+'" y2="'+lineY+'" stroke="url(#ag5)" stroke-width="3" stroke-linecap="round"/>';
      asvg += '<line x1="20" y1="'+lineY+'" x2="'+(aW-20)+'" y2="'+lineY+'" stroke="url(#ag5)" stroke-width="14" opacity=".08"/>';
      var dots = Math.min(sessionCount, 10);
      var displaySessions = sessions.slice(-dots);
      for (var d = 0; d < dots; d++) {
        var t = dots === 1 ? 0.5 : d / (dots - 1);
        var dx = 20 + t * (aW - 40);
        var isCurr = d === dots - 1;
        var dR = isCurr ? 6 : 3;
        var dCol = isCurr ? 'rgba(244,196,109,1)' : 'rgba(247,241,231,.25)';
        asvg += '<circle cx="'+dx+'" cy="'+lineY+'" r="'+dR+'" fill="'+dCol+'"'+(isCurr?' filter="url(#tkG)"':'')+'/>';
        if (displaySessions[d] && displaySessions[d].date && (d === 0 || isCurr)) {
          var sDate = new Date(displaySessions[d].date);
          var sLabel = sDate.toLocaleDateString("en-US", { month: "short", day: "numeric" });
          asvg += '<text x="'+dx+'" y="'+(lineY+18)+'" text-anchor="middle" fill="rgba(247,241,231,.85)" font-size="14" font-family="Space Grotesk,sans-serif">'+esc(sLabel)+'</text>';
        }
      }
      asvg += '</svg>';
      html += asvg;
      if (gd.arc) html += '<div style="font-size:1.12rem;color:rgba(247,241,231,.92);font-family:Fraunces,serif;font-style:italic;line-height:1.55;margin-top:.3rem">'+gd.arc+'</div>';
      html += '</div>';
    }

    html += '</div>';
    html += '<div class="tk-div"></div>';
  }

  /* ── 3. THE DEEPER READ — contradiction + unsaid + becoming + surfaced tension ── */
  var sTension = session.surfacedTension || state.surfacedTension;
  var mEvolution = session.mapEvolution || state.mapEvolution;
  var hasDeeper = (gd.contradiction && gd.contradiction.observation) || gd.unsaid || gd.becoming || (sTension && sTension.observation);
  if (hasDeeper) {
    html += '<div class="'+sc()+'" style="padding:1rem 2rem 1.2rem">';
    html += '<div style="font-size:1.8rem;font-weight:300;letter-spacing:.3rem;text-transform:uppercase;color:rgba(94,211,192,.85);font-family:Space Grotesk,sans-serif;margin-bottom:1rem">The Deeper Read</div>';

    if (gd.contradiction && gd.contradiction.observation) {
      html += '<div style="display:flex;align-items:flex-start;gap:.8rem;margin-bottom:1rem">';
      html += '<div style="font-size:1.4rem;color:rgba(240,139,115,.85);flex-shrink:0;margin-top:.1rem">\u26A1</div>';
      html += '<div><div style="font-size:1.12rem;letter-spacing:.1em;text-transform:uppercase;color:rgba(240,139,115,.85);font-family:Space Grotesk,sans-serif;font-weight:600;margin-bottom:.25rem">Contradiction</div>';
      html += '<div style="font-size:1.12rem;color:rgba(247,241,231,.92);font-family:Fraunces,serif;line-height:1.6">'+esc(gd.contradiction.observation)+'</div></div></div>';
    }

    if (sTension && sTension.observation) {
      html += '<div style="display:flex;align-items:flex-start;gap:.8rem;margin-bottom:1rem">';
      html += '<div style="font-size:1.4rem;color:rgba(244,196,109,.85);flex-shrink:0;margin-top:.1rem">\u25C8</div>';
      html += '<div><div style="font-size:1.12rem;letter-spacing:.1em;text-transform:uppercase;color:rgba(244,196,109,.85);font-family:Space Grotesk,sans-serif;font-weight:600;margin-bottom:.25rem">What your responses revealed</div>';
      html += '<div style="font-size:1.12rem;color:rgba(247,241,231,.92);font-family:Fraunces,serif;line-height:1.6">'+esc(sTension.observation)+'</div></div></div>';
    }

    if (gd.unsaid) {
      html += '<div style="display:flex;align-items:flex-start;gap:.8rem;margin-bottom:1rem">';
      html += '<div style="font-size:1.4rem;color:rgba(154,208,255,.85);flex-shrink:0;margin-top:.1rem">\u25CC</div>';
      html += '<div><div style="font-size:1.12rem;letter-spacing:.1em;text-transform:uppercase;color:rgba(154,208,255,.85);font-family:Space Grotesk,sans-serif;font-weight:600;margin-bottom:.25rem">The unsaid</div>';
      html += '<div style="font-size:1.12rem;color:rgba(247,241,231,.92);font-family:Fraunces,serif;line-height:1.6">'+esc(gd.unsaid)+'</div></div></div>';
    }

    if (gd.becoming) {
      html += '<div style="display:flex;align-items:flex-start;gap:.8rem;margin-bottom:.5rem">';
      html += '<div style="font-size:1.4rem;color:rgba(244,196,109,.85);flex-shrink:0;margin-top:.1rem">\u2726</div>';
      html += '<div><div style="font-size:1.12rem;letter-spacing:.1em;text-transform:uppercase;color:rgba(244,196,109,.85);font-family:Space Grotesk,sans-serif;font-weight:600;margin-bottom:.25rem">Who you\u2019re becoming</div>';
      html += '<div style="font-size:1.15rem;color:rgba(244,196,109,.8);font-family:Fraunces,serif;line-height:1.6;font-weight:400">'+esc(gd.becoming)+'</div></div></div>';
    }

    if (mEvolution) {
      html += '<div style="font-size:1.08rem;color:rgba(247,241,231,.92);font-family:Fraunces,serif;font-style:italic;line-height:1.55;margin-top:.5rem;padding-left:2.2rem">'+esc(mEvolution)+'</div>';
    }

    html += '</div>';
    html += '<div class="tk-div"></div>';
  }

  /* ── 4. YOUR PORTRAIT — all dimensions in one clean grid ── */
  if (pd) {
    var portraitItems = [];

    if (pd.values && pd.values.length) {
      pd.values.forEach(function(v) {
        portraitItems.push({ icon: '\u25C9', label: v.label, detail: v.evidence || '', color: '244,196,109', category: 'value' });
      });
    }
    if (pd.strengths && pd.strengths.length) {
      pd.strengths.forEach(function(s) {
        portraitItems.push({ icon: '\u2726', label: s.name, detail: s.evidence || '', color: '94,211,192', category: 'strength' });
      });
    }
    if (pd.edge && sessionCount >= 4) {
      portraitItems.push({ icon: '\u2738', label: pd.edge.label || 'Growing edge', detail: pd.edge.observation || '', color: sp.primary, category: 'edge' });
    }
    if (pd.self_authorship && sessionCount >= 6 && pd.self_authorship.signature) {
      var mvmtLabel = { toward_self: "Becoming more self-directed", toward_other: "Drawn outward", stable: "Consistent voice", mixed: "In flux" };
      portraitItems.push({ icon: '\u270D', label: mvmtLabel[pd.self_authorship.movement] || 'Your voice', detail: pd.self_authorship.signature, color: '154,208,255', category: 'voice' });
    }
    if (pd.alignment && sessionCount >= 5) {
      if (pd.alignment.coherent) portraitItems.push({ icon: '\u2713', label: 'Aligned', detail: pd.alignment.coherent, color: '180,210,170', category: 'alignment' });
      if (pd.alignment.gap && pd.alignment.gap !== "null") portraitItems.push({ icon: '\u25CB', label: 'Gap', detail: pd.alignment.gap, color: '240,139,115', category: 'alignment' });
    }

    if (portraitItems.length > 0) {
      html += '<div class="'+sc()+'" style="padding:1rem 2rem 1.2rem">';
      html += '<div style="font-size:1.8rem;font-weight:300;letter-spacing:.3rem;text-transform:uppercase;color:rgba(154,208,255,.85);font-family:Space Grotesk,sans-serif;margin-bottom:1rem">Your Portrait</div>';

      /* Two-column grid */
      html += '<div style="display:grid;grid-template-columns:1fr 1fr;gap:.7rem">';
      portraitItems.forEach(function(item) {
        html += '<div style="padding:.8rem 1rem;border-radius:12px;background:rgba('+item.color+',.05);border:1px solid rgba('+item.color+',.12)">';
        html += '<div style="display:flex;align-items:center;gap:.5rem;margin-bottom:.3rem">';
        html += '<span style="font-size:1.1rem;color:rgba('+item.color+',.7)">'+item.icon+'</span>';
        html += '<span style="font-size:1.1rem;font-weight:700;letter-spacing:.08em;text-transform:uppercase;color:rgba('+item.color+',.85);font-family:Space Grotesk,sans-serif">'+esc(item.label)+'</span>';
        html += '</div>';
        if (item.detail) html += '<div style="font-size:1.1rem;color:rgba(247,241,231,.92);font-family:Fraunces,serif;line-height:1.5">'+esc(item.detail)+'</div>';
        html += '</div>';
      });
      html += '</div></div>';
      html += '<div class="tk-div"></div>';
    }
  }

  /* ── 5. YOUR WORDS — mirror + noticing + clarity combined ── */
  var hasWords = (gd.mirror && gd.mirror.length) || sd.noticing || session.clarity;
  if (hasWords) {
    html += '<div class="'+sc()+'" style="padding:1rem 2rem 1.2rem">';
    html += '<div style="font-size:1.8rem;font-weight:300;letter-spacing:.3rem;text-transform:uppercase;color:rgba(244,196,109,.85);font-family:Space Grotesk,sans-serif;margin-bottom:1rem">Your Words</div>';

    /* Clarity — the most important line */
    if (session.clarity) {
      html += '<div style="font-size:1.3rem;color:rgba(94,211,192,.85);font-family:Fraunces,serif;line-height:1.55;margin-bottom:1.2rem;padding:.8rem 0;border-top:1px solid rgba(94,211,192,.1);border-bottom:1px solid rgba(94,211,192,.1)">';
      html += '\u201C'+esc(session.clarity)+'\u201D';
      html += '</div>';
    }

    /* Mirror quotes — compact */
    if (gd.mirror && gd.mirror.length) {
      gd.mirror.forEach(function(m) {
        html += '<div style="display:flex;align-items:flex-start;gap:.7rem;margin-bottom:.7rem">';
        html += '<div style="font-size:1.2rem;color:rgba(154,208,255,.85);flex-shrink:0">\u275D</div>';
        html += '<div>';
        html += '<div style="font-size:1.12rem;color:rgba(247,241,231,.92);font-family:Fraunces,serif;line-height:1.5;font-style:italic">\u201C'+esc(m.their_words)+'\u201D</div>';
        if (m.what_it_reveals) html += '<div style="font-size:1.08rem;color:rgba(154,208,255,.85);font-family:Space Grotesk,sans-serif;margin-top:.2rem">'+esc(m.what_it_reveals)+'</div>';
        html += '</div></div>';
      });
    }

    /* Noticing — the system's quiet observation */
    if (sd.noticing) {
      html += '<div style="margin-top:.8rem;padding:.7rem 0;border-top:1px solid rgba(247,241,231,.06)">';
      html += '<div style="font-size:1.12rem;letter-spacing:.1em;text-transform:uppercase;color:rgba(244,196,109,.85);font-family:Space Grotesk,sans-serif;margin-bottom:.3rem">\u25CE Noticing</div>';
      html += '<div style="font-size:1.08rem;color:rgba(247,241,231,.92);font-family:Fraunces,serif;font-style:italic;line-height:1.55">'+esc(sd.noticing)+'</div>';
      html += '</div>';
    }

    html += '</div>';
    html += '<div class="tk-div"></div>';
  }

  /* ── Hold dots ── */
  if (holds.length > 0) {
    html += '<div class="tk-holds '+sc()+'">';
    html += '<div class="tk-holds-dots">';
    holds.forEach(function() { html += '<div class="tk-hold-dot"></div>'; });
    html += '</div></div>';
  }

  /* ── SESSION PULSE — three directly measurable metrics ── */
  if (sessionCount >= 2) {
    var depthScore = 0, engagementScore = 0, returnScore = 0;

    /* DEPTH: How much you poured in THIS session (characters written) */
    var thisRawDump = session.rawDump || "";
    var thisGuideResponses = session.guideResponses || {};
    var thisConnResponses = session.connResponses || {};
    var totalChars = thisRawDump.length;
    Object.keys(thisGuideResponses).forEach(function(k) {
      totalChars += (thisGuideResponses[k].answer || "").length;
      if (thisGuideResponses[k].followup) totalChars += thisGuideResponses[k].followup.length;
    });
    Object.keys(thisConnResponses).forEach(function(k) {
      totalChars += (thisConnResponses[k].answer || "").length;
      if (thisConnResponses[k].followup) totalChars += thisConnResponses[k].followup.length;
    });
    /* 0-100 scale: 200 chars = 20, 500 = 50, 1000+ = 85+ */
    depthScore = Math.round(Math.min(totalChars / 12, 100));
    depthScore = Math.max(depthScore, 5); /* wrote something = floor */

    /* ENGAGEMENT: What you touched vs. what was offered */
    var opportunities = (sd.guide || session.guide || []).length + (sd.connections || []).length;
    var touched = Object.keys(thisGuideResponses).length + Object.keys(thisConnResponses).length;
    if (session.clarity) touched++;
    if (opportunities > 0) {
      engagementScore = Math.round((touched / opportunities) * 85);
    }
    /* Bonus for follow-ups (went beyond the minimum) */
    var followups = 0;
    Object.keys(thisGuideResponses).forEach(function(k) { if (thisGuideResponses[k].followup) followups++; });
    Object.keys(thisConnResponses).forEach(function(k) { if (thisConnResponses[k].followup) followups++; });
    engagementScore = Math.min(engagementScore + followups * 8, 100);
    engagementScore = Math.max(engagementScore, touched > 0 ? 10 : 0);

    /* RETURN: Showing up over time */
    var daysSinceFirst = 1;
    if (sessions.length > 1) {
      var first = new Date(sessions[0].date);
      var last = new Date(sessions[sessions.length - 1].date);
      daysSinceFirst = Math.max(1, Math.round((last - first) / 86400000));
    }
    var weeksActive = Math.max(daysSinceFirst / 7, 1);
    var sessionsPerWeek = sessionCount / weeksActive;
    returnScore = Math.round(Math.min(
      sessionCount * 10 +                         /* each session counts */
      Math.min(sessionsPerWeek * 15, 30),          /* consistency bonus capped */
      100
    ));

    /* Build arc gauge SVG */
    function arcGauge(label, score, color) {
      var w = 155, h = 100, r = 56, cx = w/2, cy = 85;
      var startAngle = Math.PI;
      var endAngle = 0;
      var scoreAngle = startAngle + (endAngle - startAngle) * (score / 100);
      function arcPath(a1, a2) {
        var x1 = cx + r * Math.cos(a1), y1 = cy + r * Math.sin(a1);
        var x2 = cx + r * Math.cos(a2), y2 = cy + r * Math.sin(a2);
        var large = Math.abs(a2 - a1) > Math.PI ? 1 : 0;
        return 'M ' + x1 + ' ' + y1 + ' A ' + r + ' ' + r + ' 0 ' + large + ' 1 ' + x2 + ' ' + y2;
      }
      var svg = '<svg width="' + w + '" height="' + h + '" viewBox="0 0 ' + w + ' ' + h + '">';
      /* Track */
      svg += '<path d="' + arcPath(startAngle, endAngle) + '" fill="none" stroke="rgba(247,241,231,.06)" stroke-width="8" stroke-linecap="round"/>';
      /* Fill */
      if (score > 2) {
        svg += '<path d="' + arcPath(startAngle, scoreAngle) + '" fill="none" stroke="rgba(' + color + ',.7)" stroke-width="8" stroke-linecap="round"/>';
        /* Glow */
        svg += '<path d="' + arcPath(startAngle, scoreAngle) + '" fill="none" stroke="rgba(' + color + ',.2)" stroke-width="16" stroke-linecap="round"/>';
      }
      /* Score */
      svg += '<text x="' + cx + '" y="' + (cy - 14) + '" text-anchor="middle" fill="rgba(' + color + ',.95)" font-size="26" font-family="Space Grotesk,sans-serif" font-weight="700">' + score + '</text>';
      /* Label */
      svg += '<text x="' + cx + '" y="' + (cy + 6) + '" text-anchor="middle" fill="rgba(" + color + ",.8)" font-size="14" font-family="Space Grotesk,sans-serif" letter-spacing=".12em">' + label + '</text>';
      svg += '</svg>';
      return svg;
    }

    html += '<div class="tk-div"></div>';
    html += '<div class="' + sc() + '" style="padding:1.2rem 1.6rem 1rem">';
    html += '<div class="tk-sheader"><span class="tk-sheader-icon" style="color:rgba('+sp.primary+',.85)">\u25C9</span><span class="tk-sheader-text" style="color:rgba('+sp.primary+',.85)">Session Pulse</span></div>';
    html += '<div style="display:flex;justify-content:center;gap:.5rem;margin-top:.5rem">';
    html += '<div style="text-align:center">' + arcGauge('DEPTH', depthScore, '244,196,109') + '</div>';
    html += '<div style="text-align:center">' + arcGauge('ENGAGEMENT', engagementScore, '94,211,192') + '</div>';
    html += '<div style="text-align:center">' + arcGauge('RETURN', returnScore, '240,139,115') + '</div>';
    html += '</div>';
    html += '<div style="text-align:center;font-size:1.1rem;color:rgba(247,241,231,.92);margin-top:.4rem;font-family:Space Grotesk,sans-serif">What you wrote, what you touched, how often you show up</div>';
    html += '</div>';
  }

  /* ── Lines You Kept — treasured moments from their sessions ── */
  if (keptLines.length > 0) {
    html += '<div class="tk-div"></div>';
    html += '<div class="tk-kept '+sc()+'" style="padding:1rem 2.2rem 1.4rem">';
    html += '<div class="tk-sheader"><span class="tk-sheader-icon" style="color:var(--gold)">\u2661</span><span class="tk-sheader-text" style="color:var(--gold)">Lines You Kept</span></div>';
    keptLines.slice(-4).forEach(function(k) {
      html += '<div style="margin:.8rem 0;padding:.8rem 1rem;border-left:2px solid rgba(244,196,109,.25);background:rgba(244,196,109,.04);border-radius:0 8px 8px 0">';
      html += '<div style="font-family:var(--display);font-size:1.12rem;color:var(--hi);line-height:1.5;font-style:italic">\u201C'+esc(k.line)+'\u201D</div>';
      html += '</div>';
    });
    html += '</div>';
  }

  /* ── Parting thought — generated async ── */
  html += '<div class="tk-parting" id="tk-parting"><div class="tk-parting-loading">\u2026</div></div>';

  html += '<div class="tk-div"></div>';
  /* ── Footer ── */
  html += '<div class="tk-footer"><span>\u25C8 Clarity, not control.</span><span>'+dateStr+'</span></div>';

  /* ── Download action bar ── */
  html += '<div class="tk-actions">';
  html += '<button class="tk-action-btn" id="tk-btn-png"><span class="tk-action-icon">\u25A3</span> Save Image</button>';
  html += '<button class="tk-action-btn" id="tk-btn-pdf"><span class="tk-action-icon">\u25A1</span> Save PDF</button>';
  html += '</div>';

  /* ════════ RENDER ════════ */
  var overlay = document.createElement("div");
  overlay.className = "takeaway-overlay";
  var card = document.createElement("div");
  card.className = "takeaway-card";
  if (sp.bg !== "#060910") card.style.background = sp.bg;
  card.innerHTML = html;
  overlay.appendChild(card);
  document.body.appendChild(overlay);

  /* ── Generate parting thought async ── */
  (async function() {
    var partingEl = card.querySelector("#tk-parting");
    if (!partingEl) return;
    try {
      var seeds = [];
      if (sd.synthesis) seeds.push(sd.synthesis);
      if (sd.map_title) seeds.push("Map: " + sd.map_title);
      if (gd && gd.becoming) seeds.push("Becoming: " + gd.becoming);
      if (gd && gd.arc) seeds.push("Arc: " + gd.arc);
      if (gd && gd.unsaid) seeds.push("Unsaid: " + gd.unsaid);
      if (sd.themes) seeds.push("Themes: " + sd.themes.map(function(t){return t.label;}).join(", "));

      var partingPrompt = 'You are the parting voice of SAYCRD. The user has just finished reading their session infographic. Based on what emerged in their session, offer them ONE of the following (choose whichever feels most alive for this person):\n\n' +
        '- A real quote from a poet, philosopher, writer, mystic, or psychologist that speaks directly to what they are holding. Include the author.\n' +
        '- A single original thought — something to sit with, not solve. Written as though a wise friend is leaving them with one last thing at the door.\n\n' +
        'Rules:\n- Maximum 35 words for the thought/quote\n- If using a real quote, it MUST be accurate. If unsure, write an original one instead.\n- Do not explain it. Do not connect it back to their session explicitly. Trust them to feel why it matters.\n- Respond with ONLY JSON: {"text":"...","source":"author name or empty string if original"}';

      var raw = await callClaude(partingPrompt, seeds.join("\n"), 300);
      var data = extractJSON(raw);
      if (data && data.text) {
        partingEl.innerHTML = '<div class="tk-parting-label">Something to sit with</div>' +
          '<div class="tk-parting-text">\u201C' + data.text.replace(/&/g,'&amp;').replace(/</g,'&lt;') + '\u201D</div>' +
          (data.source ? '<div class="tk-parting-source">\u2014 ' + data.source.replace(/&/g,'&amp;').replace(/</g,'&lt;') + '</div>' : '<div class="tk-parting-source">\u25C8</div>');
        partingEl.classList.add("visible");
      } else {
        partingEl.remove();
      }
    } catch(e) {
      console.warn("Parting thought:", e);
      partingEl.remove();
    }
  })();

  /* ── Save reading for gallery (skip if viewing a stored one) ── */
  if (!storedReading && sd.themes) {
    saveCurrentReading(sd, gd, dateStr, sessionCount);
  }

  /* ── Download: PNG ── */
  card.querySelector("#tk-btn-png").addEventListener("click", async function() {
    var btn = this;
    btn.classList.add("tk-saving");
    btn.textContent = "Rendering\u2026";
    try {
      /* Load html2canvas from CDN */
      if (!window.html2canvas) {
        await new Promise(function(resolve, reject) {
          var s = document.createElement("script");
          s.src = "https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js";
          s.onload = resolve;
          s.onerror = function() { reject(new Error("CDN load failed")); };
          document.head.appendChild(s);
        });
      }

      var actionsEl = card.querySelector(".tk-actions");
      var closeEl = card.querySelector(".takeaway-close");
      if (actionsEl) actionsEl.style.display = "none";
      if (closeEl) closeEl.style.display = "none";

      /* Force all animated elements to be fully visible for capture */
      var animated = card.querySelectorAll(".tk-s, .takeaway-card, .tk-unsaid::before, .tk-unsaid::after, .tk-hold-dot");
      var savedStyles = [];
      animated.forEach(function(el) {
        savedStyles.push(el.style.cssText);
        el.style.opacity = "1";
        el.style.transform = "none";
        el.style.animation = "none";
      });
      /* Also force the card itself */
      var cardSaved = card.style.cssText;
      card.style.opacity = "1";
      card.style.transform = "none";
      card.style.animation = "none";

      var canvas = await html2canvas(card, {
        backgroundColor: "#060910",
        scale: 2,
        useCORS: true,
        logging: false,
        allowTaint: true
      });

      /* Restore styles */
      animated.forEach(function(el, i) { el.style.cssText = savedStyles[i]; });
      card.style.cssText = cardSaved;
      if (actionsEl) actionsEl.style.display = "";
      if (closeEl) closeEl.style.display = "";

      /* Try download link first */
      var dataUrl = canvas.toDataURL("image/png");
      var filename = "saycrd-reading-" + now.toISOString().slice(0,10) + ".png";

      try {
        /* Blob approach — more reliable for downloads */
        var byteString = atob(dataUrl.split(",")[1]);
        var ab = new ArrayBuffer(byteString.length);
        var ia = new Uint8Array(ab);
        for (var bi = 0; bi < byteString.length; bi++) ia[bi] = byteString.charCodeAt(bi);
        var blob = new Blob([ab], { type: "image/png" });
        var blobUrl = URL.createObjectURL(blob);
        var link = document.createElement("a");
        link.href = blobUrl;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(function() { URL.revokeObjectURL(blobUrl); }, 5000);
      } catch(dlErr) {
        /* Fallback: open in new tab */
        window.open(dataUrl, "_blank");
      }

      btn.innerHTML = '<span class="tk-action-icon">\u2713</span> Saved!';
      btn.classList.remove("tk-saving");
      setTimeout(function() { btn.innerHTML = '<span class="tk-action-icon">\u25A3</span> Save Image'; }, 2500);
    } catch(e) {
      console.error("PNG export error:", e);
      /* Fallback: open card HTML in new window for manual screenshot */
      try {
        var w = window.open("", "_blank");
        if (w) {
          w.document.write('<!DOCTYPE html><html><head><style>body{margin:0;background:#060910}</style></head><body>');
          var actEl = card.querySelector(".tk-actions");
          var clEl = card.querySelector(".takeaway-close");
          if (actEl) actEl.style.display = "none";
          if (clEl) clEl.style.display = "none";
          w.document.write(card.outerHTML);
          if (actEl) actEl.style.display = "";
          if (clEl) clEl.style.display = "";
          w.document.write('</body></html>');
          w.document.close();
        }
      } catch(popupErr) {}
      btn.innerHTML = '<span class="tk-action-icon">\u25A3</span> Save Image';
      btn.classList.remove("tk-saving");
    }
  });

  /* ── Download: PDF via print ── */
  card.querySelector("#tk-btn-pdf").addEventListener("click", function() {
    try {
      /* Try native print first */
      window.print();
    } catch(printErr) {
      /* Fallback: open clean version in new tab for printing */
      try {
        var actEl = card.querySelector(".tk-actions");
        var clEl = card.querySelector(".takeaway-close");
        if (actEl) actEl.style.display = "none";
        if (clEl) clEl.style.display = "none";
        var styles = "";
        document.querySelectorAll("style, link[rel=stylesheet]").forEach(function(s) {
          styles += s.outerHTML;
        });
        var w = window.open("", "_blank");
        if (w) {
          w.document.write('<!DOCTYPE html><html><head>' + styles + '<style>body{margin:0;background:#020406;display:flex;justify-content:center;padding:1rem}@media print{body{padding:0}.takeaway-card{box-shadow:none;border:none;border-radius:0;max-width:100%}}</style></head><body>');
          w.document.write(card.outerHTML);
          w.document.write('</body></html>');
          w.document.close();
          setTimeout(function() { w.print(); }, 500);
        }
        if (actEl) actEl.style.display = "";
        if (clEl) clEl.style.display = "";
      } catch(fallbackErr) {
        console.error("PDF fallback error:", fallbackErr);
      }
    }
  });

  card.querySelector(".takeaway-close").addEventListener("click", function() {
    overlay.style.opacity = "0"; overlay.style.transition = "opacity .3s ease";
    setTimeout(function() { overlay.remove(); }, 300);
  });
  overlay.addEventListener("click", function(e) {
    if (e.target === overlay) {
      overlay.style.opacity = "0"; overlay.style.transition = "opacity .3s ease";
      setTimeout(function() { overlay.remove(); }, 300);
    }
  });
}

/* ── Seed demo sessions for previewing What's Growing ── */
function seedDemoSessions(keepExisting) {
  var now = Date.now();
  var day = 86400000;
  var demos = [
    {
      date: new Date(now - day * 12).toISOString(),
      themes: [
        { label: "overcommitting", weight: 5 },
        { label: "resentment building", weight: 4 },
        { label: "need to prove myself", weight: 4 },
        { label: "fear of disappointing", weight: 3 },
        { label: "exhaustion", weight: 3 }
      ],
      synthesis: "You\u2019re running a cycle where saying yes to others means saying no to yourself, and the resentment you feel is the cost of that bargain. There\u2019s a deep equation here: your worth is earned through sacrifice, and rest feels like failure.",
      noticing: "The system notices that \u2018proving myself\u2019 and \u2018fear of disappointing\u2019 appear to be two sides of the same belief \u2014 that acceptance is conditional.",
      clarity: "I keep saying yes because I\u2019m afraid of what happens if I stop being useful.",
      guide: [
        { type: "deepen", text: "What would you lose if people saw you resting?", response: "They\u2019d think I don\u2019t care. Or worse, that I was never as capable as they thought." },
        { type: "act", text: "Choose one commitment this week to withdraw from. Notice what arises." },
        { type: "sit", text: "Sit with the word \u2018enough.\u2019 Where does it land in your body?" },
        { type: "release", text: "The version of you that needs to be indispensable \u2014 thank them and let them rest." }
      ]
    },
    {
      date: new Date(now - day * 6).toISOString(),
      themes: [
        { label: "creative stagnation", weight: 4 },
        { label: "comparison", weight: 4 },
        { label: "longing for meaning", weight: 5 },
        { label: "overcommitting", weight: 3 },
        { label: "guilt about wanting more", weight: 3 }
      ],
      synthesis: "Something in you is hungry \u2014 not for more tasks but for something that matters. The comparison isn\u2019t really about other people; it\u2019s a signal that you\u2019re measuring your life against a version you haven\u2019t let yourself pursue.",
      noticing: "The system sees \u2018overcommitting\u2019 returning from your last session, now alongside \u2018creative stagnation.\u2019 The pattern suggests you fill time with obligations so you don\u2019t have to face the emptiness of not creating.",
      clarity: "I\u2019m not creatively blocked. I\u2019m afraid that what I make won\u2019t justify the space it takes.",
      guide: [
        { type: "deepen", text: "When did you first learn that creating needed to be justified?", response: "My dad. He was a musician who gave it up. He always said art was a luxury you earn after you\u2019ve built something real." },
        { type: "act", text: "Make something small this week that no one will see. Let it be bad." },
        { type: "sit", text: "Sit with the phrase \u2018building something real.\u2019 Whose voice says it?" },
        { type: "surrender", text: "Your father\u2019s unlived dream is not your debt." }
      ]
    },
    {
      date: new Date(now - day * 1).toISOString(),
      themes: [
        { label: "softening", weight: 3 },
        { label: "grief", weight: 4 },
        { label: "permission", weight: 5 },
        { label: "overcommitting", weight: 2 },
        { label: "father", weight: 4 }
      ],
      synthesis: "Something is shifting. The grief you\u2019re touching isn\u2019t yours alone \u2014 you\u2019re carrying your father\u2019s surrender alongside your own unlived work. The permission you\u2019re looking for isn\u2019t coming from outside. It never was.",
      noticing: "\u2018Overcommitting\u2019 has dropped from weight 5 to weight 2 across your sessions. Something loosened. Meanwhile \u2018father\u2019 has appeared for the first time, named directly now rather than hiding inside other themes.",
      clarity: "I don\u2019t need permission. I need to grieve what he gave up so I can stop protecting it.",
      guide: [
        { type: "deepen", text: "What are you protecting by carrying his unlived dream?", response: "If I let it go, it\u2019s like admitting he was wrong to stop. And I\u2019m not ready to say that about him." },
        { type: "sit", text: "Sit with both truths: he made his choice, and you get to make yours." },
        { type: "act", text: "Write your father a letter you\u2019ll never send. Tell him what you\u2019re keeping and what you\u2019re letting go." },
        { type: "release", text: "The belief that choosing yourself means betraying him." }
      ]
    }
  ];

  if (keepExisting) {
    sessionHistory = demos.concat(sessionHistory);
  } else {
    sessionHistory = demos;
  }
  try { window.storage.set("saycrd-sessions", JSON.stringify(sessionHistory)); } catch(e) {}
  renderGrowing();
}

/* ── Single Session AI Reading ── */
async function runSingleSessionReading(container, session) {
  var sessionForAPI = {
    date: session.date,
    themes: (session.themes || []).map(function(t) { return t.label + " (weight:" + t.weight + ")"; }),
    synthesis: session.synthesis || "",
    noticing: session.noticing || "",
    clarity: session.clarity || null,
    guide: (session.guide || []).map(function(g) {
      var item = { type: g.type, prompt: g.text };
      if (g.response) item.their_answer = g.response;
      return item;
    })
  };
  if (session.rawDump) sessionForAPI.raw_words = session.rawDump.slice(0, 800);
  if (session.inlineInteractions && session.inlineInteractions.length > 0) {
    sessionForAPI.inline_responses = session.inlineInteractions.map(function(inter) {
      if (inter.type === "reflection") return 'Reading said: "' + inter.question + '" → They wrote: "' + inter.answer + '"';
      if (inter.type === "correction") return 'They DISAGREED: "' + inter.answer + '"';
      return inter.answer;
    });
  }
  if (session.guideResponses) {
    Object.keys(session.guideResponses).forEach(function(k) {
      var gr = session.guideResponses[k];
      if (gr && gr.answer && sessionForAPI.guide[k]) {
        sessionForAPI.guide[k].their_answer = gr.answer;
        if (gr.echo) sessionForAPI.guide[k].echo = gr.echo;
      }
    });
  }

  var systemPrompt = 'You are the reflection layer of SAYCRD. You have ONE session from this person. Your job is not to summarize what they already saw \u2014 it\u2019s to go deeper than the session itself went.\n\n' +
    'You have their themes, the AI synthesis they received, their clarity statement, their answers to guide questions, and critically \u2014 their INLINE RESPONSES where they talked back to the reading in real time. These inline responses are the highest signal: they show what landed, what cracked them open, what they pushed back on.\n\n' +
    'Generate these sections:\n\n' +
    '1. DEEPER_READ: 2-3 sentences. Go beneath the synthesis they already received. What is the thing underneath the thing? What did the session touch that it didn\u2019t name? 2nd person, warm, direct.\n\n' +
    '2. MIRROR: 1-2 items. The most revealing things THEY said \u2014 pulled from their guide responses or clarity statement. Choose quotes that reveal something the person may not realize they revealed. Each has "their_words" (exact quote) and "what_it_reveals" (1 sentence).\n\n' +
    '3. TENSION: 0-1 item. A tension within this single session \u2014 something that pulls in two directions. Where their themes point one way but their words point another. Has "observation" (1-2 sentences). Omit if there\u2019s no real tension.\n\n' +
    '4. SEED: 1 sentence. Something planted in this session that hasn\u2019t grown yet. A thread to watch. Frame it as something to notice going forward.\n\n' +
    '5. RETURN_PROMPT: 1 sentence. A question for them to sit with before their next session. Not a homework assignment \u2014 a wondering.\n\n' +
    'Respond with ONLY valid JSON:\n' +
    '{"deeper_read":"...","mirror":[{"their_words":"...","what_it_reveals":"..."}],"tension":{"observation":"..."},"seed":"...","return_prompt":"..."}';

  try {
    var raw = await callClaude(systemPrompt, JSON.stringify(sessionForAPI), 1500);
    var data = extractJSON(raw);
    container.innerHTML = "";

    /* Session count + date */
    var header = document.createElement("div");
    var d = new Date(session.date);
    header.style.cssText = "font-size:.85rem;letter-spacing:.18rem;text-transform:uppercase;color:var(--ink-soft);margin-bottom:1.8rem;opacity:.5";
    header.textContent = "First session \u00B7 " + d.toLocaleDateString("en-US", { month: "long", day: "numeric" });
    container.appendChild(header);

    /* Deeper read */
    if (data.deeper_read) {
      var drEl = document.createElement("div");
      drEl.className = "gi-section gi-arc";
      drEl.innerHTML = '<div class="gi-head"><div class="gi-icon">\u2728</div><div class="gi-label">Beneath the Surface</div></div><div class="gi-arc-text">' + data.deeper_read + '</div>';
      container.appendChild(drEl);
    }

    /* Mirror */
    if (data.mirror && data.mirror.length) {
      var mirrorEl = document.createElement("div");
      mirrorEl.className = "gi-section gi-mirror";
      mirrorEl.innerHTML = '<div class="gi-head"><div class="gi-icon">\u25C8</div><div class="gi-label">Your Words, Reflected</div></div>';
      data.mirror.forEach(function(m) {
        var item = document.createElement("div");
        item.className = "gi-mirror-item";
        item.innerHTML = '<div class="gi-mirror-quote">\u201C' + m.their_words + '\u201D</div><div class="gi-mirror-reveals">' + m.what_it_reveals + '</div>';
        mirrorEl.appendChild(item);
      });
      container.appendChild(mirrorEl);
    }

    /* Tension */
    if (data.tension && data.tension.observation) {
      var tenEl = document.createElement("div");
      tenEl.className = "gi-section gi-contradiction";
      tenEl.innerHTML = '<div class="gi-head"><div class="gi-icon">\u26A1</div><div class="gi-label">The Tension</div></div><div class="gi-contradiction-text">' + data.tension.observation + '</div>';
      container.appendChild(tenEl);
    }

    /* Seed */
    if (data.seed) {
      var seedEl = document.createElement("div");
      seedEl.className = "gi-section gi-shifts";
      seedEl.innerHTML = '<div class="gi-head"><div class="gi-icon">\u2740</div><div class="gi-label">What\u2019s Planted</div></div><div style="font-size:1.1rem;color:var(--ink-soft);line-height:1.65">' + data.seed + '</div>';
      container.appendChild(seedEl);
    }

    /* Return prompt with reply */
    if (data.return_prompt) {
      var rpEl = document.createElement("div");
      rpEl.className = "gi-section gi-unsaid";
      rpEl.innerHTML = '<div class="gi-head"><div class="gi-icon">\u25CC</div><div class="gi-label">Before Your Next Session</div></div><div class="gi-unsaid-text">' + data.return_prompt + '</div>';

      /* Reply area */
      var replyWrap = document.createElement("div");
      replyWrap.style.cssText = "margin-top:1.8rem;max-width:480px;margin-left:auto;margin-right:auto;opacity:0;animation:reflection-in .8s ease .6s forwards";

      var replyInput = document.createElement("textarea");
      replyInput.className = "gi-reflection-input";
      replyInput.placeholder = "If something comes up\u2026";
      replyInput.rows = 2;

      var replyHint = document.createElement("div");
      replyHint.className = "gi-reflection-hint";
      replyHint.textContent = "Enter to share \u00B7 This carries into your next reading";

      replyWrap.append(replyInput, replyHint);
      rpEl.appendChild(replyWrap);
      container.appendChild(rpEl);

      /* Handle reply */
      replyInput.addEventListener("keydown", async function(ke) {
        if (ke.key === "Enter" && !ke.shiftKey && replyInput.value.trim().length > 0) {
          ke.preventDefault();
          var response = replyInput.value.trim();
          replyInput.disabled = true;
          replyInput.style.opacity = ".5";

          /* Save as reflection */
          var record = {
            date: new Date().toISOString(),
            question: data.return_prompt,
            response: response,
            type: "return_prompt"
          };
          try {
            var existing = [];
            try { var r = await window.storage.get("saycrd-reflections"); if (r && r.value) existing = JSON.parse(r.value); } catch(e) {}
            existing.push(record);
            await window.storage.set("saycrd-reflections", JSON.stringify(existing));
          } catch(ex) {}

          /* Generate naming */
          try {
            var namingPrompt = 'The user was given this prompt to sit with after their session:\n"' + data.return_prompt + '"\n\n' +
              'They responded:\n"' + response + '"\n\n' +
              'Generate ONE short sentence. Not an insight. A naming — acknowledge what they just did. Prove you read it. Under 15 words. Warm.\n\n' +
              'Respond with ONLY valid JSON:\n{"naming":"..."}';
            var namingRaw = await callClaude(namingPrompt, "Their response: " + response);
            var namingData = extractJSON(namingRaw);
            var naming = namingData.naming || "Heard.";

            replyInput.remove();
            replyHint.remove();
            var responseEl = document.createElement("div");
            responseEl.className = "gi-reflection-response";
            responseEl.innerHTML = '<div class="gi-reflection-naming">' + naming + '</div><div class="gi-reflection-saved">Saved. This carries forward.</div>';
            replyWrap.appendChild(responseEl);
          } catch(ne) {
            replyInput.remove();
            replyHint.remove();
            var fallback = document.createElement("div");
            fallback.className = "gi-reflection-response";
            fallback.innerHTML = '<div class="gi-reflection-naming">Heard.</div><div class="gi-reflection-saved">Saved. This carries forward.</div>';
            replyWrap.appendChild(fallback);
          }
        }
      });
    }

  } catch(err) {
    container.innerHTML = '<div style="color:var(--ink-soft);font-size:.95rem;font-style:italic;padding:2rem;text-align:center">The reading needs a moment. Try again shortly.</div>';
    console.error("Single session reading error:", err);
  }
}

$("btn-seed-demo")?.addEventListener("click", function() { seedDemoSessions(); });

/* Preview growing from any phase */
$("btn-preview-growing")?.addEventListener("click", function() {
  try { loadHistory(); } catch(e) {}
  state._previewFrom = state.phase;
  if (sessionHistory.length < 2) { seedDemoSessions(); }
  else { renderGrowing(); }
  setPhase(4);
  growingViewer.style.display = "";
  phase4Actions.style.display = "";
});

$("btn-view-growing")?.addEventListener("click", function(e) {
  e.preventDefault();
  try { loadHistory(); } catch(ex) {}
  renderGrowing();
  setPhase(4);
  growingViewer.style.display = "";
  phase4Actions.style.display = "";
});

$("btn-view-takeaway")?.addEventListener("click", async function() {
  /* If growth data isn't loaded yet, run it silently first */
  if (!state.growthData) {
    try {
      await loadHistory();
      /* Build the same pattern engine call but just store the data */
      if (sessionHistory.length > 0) {
        var sessionsPayload = sessionHistory.map(function(s, i) {
          var parts = ["Session " + (i + 1) + " (" + new Date(s.date).toLocaleDateString() + ")"];
          if (s.themes) parts.push("Themes: " + s.themes.map(function(t) { return t.label + " (w:" + (t.weight || 1) + ")"; }).join(", "));
          if (s.synthesis) parts.push("Reading: " + s.synthesis);
          if (s.clarity) parts.push("Clarity: \"" + s.clarity + "\"");
          if (s.noticing) parts.push("Noticing: " + s.noticing);
          return parts.join(" | ");
        }).join("\n\n");
        /* Minimal pattern call just for data */
        var patternPrompt = growingViewer.querySelector(".gi-section") ? null : "already loaded";
      }
    } catch(e) {}
  }
  generateTakeawayCard();
});

$("btn-growing-takeaway")?.addEventListener("click", function() { generateTakeawayCard(); });

$("growing-back")?.addEventListener("click", function(e) {
  e.preventDefault();
  /* Return to previous phase if we jumped from preview */
  if (state._previewFrom !== undefined) {
    setPhase(state._previewFrom);
    state._previewFrom = undefined;
    return;
  }
  setPhase(3);
});

/* ── Hero parallax ── */
const hero = $("hero-visual");
document.addEventListener("mousemove", e => {
  if (!hero) return;
  const b = hero.getBoundingClientRect();
  hero.style.transform = `translate(${((e.clientX-b.left)/b.width-.5)*6}px,${((e.clientY-b.top)/b.height-.5)*6}px)`;
});
    </script>
  </body>
</html>
